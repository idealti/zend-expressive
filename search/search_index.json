{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Features PSR-15 Middleware Create middleware applications, using as many layers as you want, and the architecture your project needs. PSR-7 HTTP Messages Built to consume PSR-7 ! Routing Route requests to middleware using the routing library of your choice . Dependency Injection Make your code flexible and robust, using the dependency injection container of your choice . Templating Create templated responses , using a variety of template engines. Error Handling Handle errors gracefully , using templated error pages, whoops , or your own solution! Get Started Now! Installation is only a Composer command away! $ composer create-project zendframework/zend-expressive-skeleton expressive Expressive provides interfaces for routing and templating, letting you choose what to use, and how you want to implement it. Our unique installer allows you to select your choices when starting your project! {: .center-block } Learn More {: .btn .btn-lg .btn-primary} Applications, Simplified Write middleware: $pathMiddleware = function ( ServerRequestInterface $request, RequestHandlerInterface $handler ) { $uri = $request->getUri(); $path = $uri->getPath(); return new TextResponse('You visited ' . $path, 200, ['X-Path' => $path]); }; And add it to an application: $app->get('/path', $pathMiddleware); Learn More {: .btn .btn-lg .btn-primary} Learn more Features overview Quick Start Or use the sidebar menu to navigate to the section you're interested in.","title":"Home"},{"location":"#features","text":"","title":"Features"},{"location":"#get-started-now","text":"Installation is only a Composer command away! $ composer create-project zendframework/zend-expressive-skeleton expressive Expressive provides interfaces for routing and templating, letting you choose what to use, and how you want to implement it. Our unique installer allows you to select your choices when starting your project! {: .center-block } Learn More {: .btn .btn-lg .btn-primary}","title":"Get Started Now!"},{"location":"#applications-simplified","text":"Write middleware: $pathMiddleware = function ( ServerRequestInterface $request, RequestHandlerInterface $handler ) { $uri = $request->getUri(); $path = $uri->getPath(); return new TextResponse('You visited ' . $path, 200, ['X-Path' => $path]); }; And add it to an application: $app->get('/path', $pathMiddleware); Learn More {: .btn .btn-lg .btn-primary}","title":"Applications, Simplified"},{"location":"#learn-more","text":"Features overview Quick Start Or use the sidebar menu to navigate to the section you're interested in.","title":"Learn more"},{"location":"why-expressive/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/why-expressive/'; });","title":"_reference_why_expressive?"},{"location":"cookbook/autowiring-routes-and-pipelines/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/cookbook/autowiring-routes-and-pipelines/'; });","title":"_cookbook_autowiring_routes_and_pipeline_middleware"},{"location":"cookbook/common-prefix-for-routes/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/cookbook/common-prefix-for-routes/'; });","title":"_cookbook_prepending_a_common_path_to_all_routes"},{"location":"cookbook/custom-404-page-handling/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v1/cookbook/custom-404-page-handling/'; });","title":"_cookbook_setting_custom_404_page_handling"},{"location":"cookbook/debug-toolbars/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/cookbook/debug-toolbars/'; });","title":"_cookbook_enabling_debug_toolbars"},{"location":"cookbook/flash-messengers/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/cookbook/flash-messengers/'; });","title":"_cookbook_flash_messengers"},{"location":"cookbook/modular-layout/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v1/cookbook/modular-layout/'; });","title":"_cookbook_building_modular_applications"},{"location":"cookbook/passing-data-between-middleware/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/cookbook/passing-data-between-middleware/'; });","title":"_cookbook_passing_data_between_middleware"},{"location":"cookbook/route-specific-pipeline/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/cookbook/route-specific-pipeline/'; });","title":"_cookbook_route-specific_middleware_pipelines"},{"location":"cookbook/setting-locale-depending-routing-parameter/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/cookbook/setting-locale-depending-routing-parameter/'; });","title":"_cookbook_setting_a_locale_based_on_a_routing_parameter"},{"location":"cookbook/setting-locale-without-routing-parameter/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/cookbook/setting-locale-without-routing-parameter/'; });","title":"_cookbook_setting_a_locale_without_a_routing_parameter"},{"location":"cookbook/using-a-base-path/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/cookbook/using-a-base-path/'; });","title":"_cookbook_using_Expressive_from_a_subdirectory"},{"location":"cookbook/using-custom-view-helpers/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/cookbook/using-custom-view-helpers/'; });","title":"_cookbook_registering_custom_view_helpers_when_using_zend-view"},{"location":"cookbook/using-routed-middleware-class-as-controller/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v2/cookbook/using-routed-middleware-class-as-controller/'; });","title":"_cookbook_handling_multiple_routes_in_a_single_class"},{"location":"cookbook/using-zend-form-view-helpers/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/cookbook/using-zend-form-view-helpers/'; });","title":"_cookbook_using_zend-form_view_helpers"},{"location":"features/application/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/application/'; });","title":"_features_application"},{"location":"features/emitters/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/emitters/'; });","title":"_features_emitters"},{"location":"features/error-handling/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/error-handling/'; });","title":"_features_error_handling"},{"location":"features/middleware-types/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/middleware-types/'; });","title":"_features_middleware_types"},{"location":"features/modular-applications/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/modular-applications/'; });","title":"_features_modular_applications"},{"location":"features/container/aura-di/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/container/aura-di/'; });","title":"_features_container_using_aura.di"},{"location":"features/container/delegator-factories/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/container/delegator-factories/'; });","title":"_features_container_delegator_factories"},{"location":"features/container/factories/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/container/factories/'; });","title":"_features_container_factories"},{"location":"features/container/intro/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/container/intro/'; });","title":"_features_container_intro"},{"location":"features/container/pimple/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/container/pimple/'; });","title":"_features_container_using_pimple"},{"location":"features/container/zend-servicemanager/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/container/zend-servicemanager/'; });","title":"_features_container_using_zend-servicemanager"},{"location":"features/helpers/body-parse/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/helpers/body-parse/'; });","title":"_features_helpers_body_parsing_middleware"},{"location":"features/helpers/content-length/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/helpers/content-length/'; });","title":"_features_helpers_content_length_middleware"},{"location":"features/helpers/intro/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/helpers/intro/'; });","title":"_features_helpers_intro"},{"location":"features/helpers/server-url-helper/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/helpers/server-url-helper/'; });","title":"_features_helpers_serverurlhelper"},{"location":"features/helpers/url-helper/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/helpers/url-helper/'; });","title":"_features_helpers_urlhelper"},{"location":"features/middleware/implicit-methods-middleware/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/middleware/implicit-methods-middleware/'; });","title":"_features_middleware_implicit_head_and_options_middleware"},{"location":"features/router/aura/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/router/aura/'; });","title":"_features_router_using_aura"},{"location":"features/router/fast-route/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/router/fast-route/'; });","title":"_features_router_using_fastroute"},{"location":"features/router/interface/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/router/interface/'; });","title":"_features_router_interface"},{"location":"features/router/intro/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/router/intro/'; });","title":"_features_router_introduction"},{"location":"features/router/piping/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/router/piping/'; });","title":"_features_router_piping"},{"location":"features/router/uri-generation/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/router/uri-generation/'; });","title":"_features_router_uri_generation"},{"location":"features/router/zf2/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/router/zf2/'; });","title":"_features_router_using_the ZF2 Router"},{"location":"features/template/interface/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/template/interface/'; });","title":"_features_template_interface"},{"location":"features/template/intro/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/template/intro/'; });","title":"_features_template_intro"},{"location":"features/template/middleware/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/template/middleware/'; });","title":"_features_template_middleware"},{"location":"features/template/plates/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/template/plates/'; });","title":"_features_template_plates"},{"location":"features/template/twig/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/template/twig/'; });","title":"_features_template_twig"},{"location":"features/template/zend-view/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/features/template/zend-view/'; });","title":"_features_template_zend-view"},{"location":"getting-started/features/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/getting-started/features/'; });","title":"_getting_started_overview"},{"location":"getting-started/skeleton/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/getting-started/quick-start/'; });","title":"_getting_started_skeleton"},{"location":"getting-started/standalone/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v2/getting-started/standalone/'; });","title":"_getting_started_standalone"},{"location":"reference/cli-tooling/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/reference/cli-tooling/'; });","title":"_reference_cli_tooling"},{"location":"reference/expressive-projects/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/reference/expressive-projects/'; });","title":"_reference_expressive_Projects"},{"location":"reference/usage-examples/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v2/reference/usage-examples/'; });","title":"_reference_usage_examples"},{"location":"reference/migration/rc-to-v1/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v1/reference/migration/rc-to-v1/'; });","title":"_migration_from_rc5_and_earlier"},{"location":"reference/migration/to-v1-1/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v1/reference/migration/to-v1-1/'; });","title":"_migration_to_expressive_1.1"},{"location":"reference/migration/to-v2/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive/v3/reference/migration/'; });","title":"_migration_to_v2"},{"location":"v1/","text":"Expressive: PSR-7 Middleware in Minutes Expressive builds on Stratigility to provide a minimalist PSR-7 middleware framework for PHP, with the following features: Routing. Choose your own router; we support: Aura.Router FastRoute zend-router DI Containers, via container-interop . All middleware composed in Expressive may be retrieved from the composed container. Optionally, templating. We support: Plates Twig ZF2's PhpRenderer Error handling. Create templated error pages, or use tools like whoops for debugging purposes. Nested middleware applications. Write an application, and compose it later in another, optionally under a separate subpath. Simplfied installation . Our custom Composer -based installer prompts you for your initial stack choices, giving you exactly the base you want to start from. Essentially, Expressive allows you to develop using the tools you prefer, and provides minimal structure and facilities to ease your development. Should I choose it over Zend\\Mvc? That\u2019s a good question. Here\u2019s what we recommend. If you\u2019re keen to get started, then keep reading and get started writing your first middleware application today!","title":"Expressive: PSR-7 Middleware in Minutes"},{"location":"v1/#expressive-psr-7-middleware-in-minutes","text":"Expressive builds on Stratigility to provide a minimalist PSR-7 middleware framework for PHP, with the following features: Routing. Choose your own router; we support: Aura.Router FastRoute zend-router DI Containers, via container-interop . All middleware composed in Expressive may be retrieved from the composed container. Optionally, templating. We support: Plates Twig ZF2's PhpRenderer Error handling. Create templated error pages, or use tools like whoops for debugging purposes. Nested middleware applications. Write an application, and compose it later in another, optionally under a separate subpath. Simplfied installation . Our custom Composer -based installer prompts you for your initial stack choices, giving you exactly the base you want to start from. Essentially, Expressive allows you to develop using the tools you prefer, and provides minimal structure and facilities to ease your development. Should I choose it over Zend\\Mvc? That\u2019s a good question. Here\u2019s what we recommend. If you\u2019re keen to get started, then keep reading and get started writing your first middleware application today!","title":"Expressive: PSR-7 Middleware in Minutes"},{"location":"v1/why-expressive/","text":"Should You Choose zend-expressive Over zend-mvc? We recommend that you choose Expressive for any new project \u2014 if the choice is yours to make . Why Use zend-mvc? zend-mvc is a proven platform, with half a decade of development behind it. It is stable and battle-tested in production platforms. Because it is opinionated about project structure and architecture, fewer decisions need be made up front; developers know where new code goes, and how it will wire into the overall application. Additionally, a number of training courses exist, including offerings by Zend , allowing you or your team to fully learn the framework and take advantage of all its features. Finally, zend-mvc has a lively module ecosystem , allowing you to add features and capabilities to your application without needing to develop them from scratch. We Recommend Expressive zend-mvc has many preconceptions about how things work, yet they're very broad and general. What\u2019s more, it also has several pre-wired structures in place that may either aid you \u2014 or get in your way. As a result, you are required to know a lot of what those things are \u2014 if you want to use it optimally. And to acquire that depth of knowledge, you\u2019re going to need to spend a lot of time digging deep into zend-mvc\u2019s internals before you begin to get the most out of it. To quote Zend Framework project lead, Matthew Weier O\u2019Phinney : The problem is that zend-mvc is anything but beginner-friendly at this point. You're required to deep dive into the event manager, service manager, and module system \u2014 right from the outset; And to do this you need more than a passing understanding of object-oriented programming and a range of design patterns. Expressive (specifically applications based on the Expressive Skeleton Installer ) on the other hand, comes with barely any of these assumptions and requirements. It provides a very minimalist structure. Essentially all you have to become familiar with are five core components. These are: A DI container. A router. An error handler for development. A template engine (if you\u2019re not creating an API). PSR-7 messages and http-interop (future PSR-15) middleware. In many cases, these are provided for you by the skeleton, and do not require any additional knowledge on your part. Given that, you can quickly get up to speed with the framework and begin creating the application that you need. We believe that this approach \u2014 in contrast to the zend-mvc approach \u2014 is more flexible and accommodating. What\u2019s more, you can mix and match the types of applications that you create. Do you just need an API? Great; you can do that quite quickly. Do you want an HTML-based front-end? That\u2019s available too. When building applications with Expressive, you can make use of the various Zend components, or any third-party components or middleware. You can pick and choose what you need, as and when you need it. You\u2019re not bound by many, if any, constraints and design decisions. In Conclusion For what it\u2019s worth, we\u2019re not saying that zend-mvc is a poor choice! What we are saying is: The learning curve, from getting started to building the first application, is significantly lower with Expressive The ways in which you can create applications, whether through multiple pieces of middleware or by combining multiple Expressive apps, into one larger one, is a much more efficient and fluid way to work Ultimately, the choice is always up to you, your team, and your project\u2019s needs. We just want to ensure that you\u2019ve got all the information you need, to make an informed decision.","title":"Why choose Expressive?"},{"location":"v1/why-expressive/#should-you-choose-zend-expressive-over-zend-mvc","text":"We recommend that you choose Expressive for any new project \u2014 if the choice is yours to make .","title":"Should You Choose zend-expressive Over zend-mvc?"},{"location":"v1/why-expressive/#why-use-zend-mvc","text":"zend-mvc is a proven platform, with half a decade of development behind it. It is stable and battle-tested in production platforms. Because it is opinionated about project structure and architecture, fewer decisions need be made up front; developers know where new code goes, and how it will wire into the overall application. Additionally, a number of training courses exist, including offerings by Zend , allowing you or your team to fully learn the framework and take advantage of all its features. Finally, zend-mvc has a lively module ecosystem , allowing you to add features and capabilities to your application without needing to develop them from scratch.","title":"Why Use zend-mvc?"},{"location":"v1/why-expressive/#we-recommend-expressive","text":"zend-mvc has many preconceptions about how things work, yet they're very broad and general. What\u2019s more, it also has several pre-wired structures in place that may either aid you \u2014 or get in your way. As a result, you are required to know a lot of what those things are \u2014 if you want to use it optimally. And to acquire that depth of knowledge, you\u2019re going to need to spend a lot of time digging deep into zend-mvc\u2019s internals before you begin to get the most out of it. To quote Zend Framework project lead, Matthew Weier O\u2019Phinney : The problem is that zend-mvc is anything but beginner-friendly at this point. You're required to deep dive into the event manager, service manager, and module system \u2014 right from the outset; And to do this you need more than a passing understanding of object-oriented programming and a range of design patterns. Expressive (specifically applications based on the Expressive Skeleton Installer ) on the other hand, comes with barely any of these assumptions and requirements. It provides a very minimalist structure. Essentially all you have to become familiar with are five core components. These are: A DI container. A router. An error handler for development. A template engine (if you\u2019re not creating an API). PSR-7 messages and http-interop (future PSR-15) middleware. In many cases, these are provided for you by the skeleton, and do not require any additional knowledge on your part. Given that, you can quickly get up to speed with the framework and begin creating the application that you need. We believe that this approach \u2014 in contrast to the zend-mvc approach \u2014 is more flexible and accommodating. What\u2019s more, you can mix and match the types of applications that you create. Do you just need an API? Great; you can do that quite quickly. Do you want an HTML-based front-end? That\u2019s available too. When building applications with Expressive, you can make use of the various Zend components, or any third-party components or middleware. You can pick and choose what you need, as and when you need it. You\u2019re not bound by many, if any, constraints and design decisions.","title":"We Recommend Expressive"},{"location":"v1/why-expressive/#in-conclusion","text":"For what it\u2019s worth, we\u2019re not saying that zend-mvc is a poor choice! What we are saying is: The learning curve, from getting started to building the first application, is significantly lower with Expressive The ways in which you can create applications, whether through multiple pieces of middleware or by combining multiple Expressive apps, into one larger one, is a much more efficient and fluid way to work Ultimately, the choice is always up to you, your team, and your project\u2019s needs. We just want to ensure that you\u2019ve got all the information you need, to make an informed decision.","title":"In Conclusion"},{"location":"v1/cookbook/common-prefix-for-routes/","text":"How can I prepend a common path to all my routes? You may have multiple middlewares providing their own functionality: $middleware1 = new UserMiddleware(); $middleware2 = new ProjectMiddleware(); $app = AppFactory::create(); $app->pipe($middleware1); $app->pipe($middleware2); $app->run(); Let's assume the above represents an API. As your application progresses, you may have a mixture of different content, and now want to have the above segregated under the path /api . This is essentially the same problem as addressed in the \"Segregating your application to a subpath\" example. To accomplish it: Create a new application. Pipe the previous application to the new one, under the path /api . $middleware1 = new UserMiddleware(); $middleware2 = new ProjectMiddleware(); $api = AppFactory::create(); $api->pipe($middleware1); $api->pipe($middleware2); $app = AppFactory::create(); $app->pipe('/api', $api); $app->run(); The above works, because every Application instance is itself middleware, and, more specifically, an instance of Stratigility's MiddlewarePipe , which provides the ability to compose middleware.","title":"Prepending a common path to all routes"},{"location":"v1/cookbook/common-prefix-for-routes/#how-can-i-prepend-a-common-path-to-all-my-routes","text":"You may have multiple middlewares providing their own functionality: $middleware1 = new UserMiddleware(); $middleware2 = new ProjectMiddleware(); $app = AppFactory::create(); $app->pipe($middleware1); $app->pipe($middleware2); $app->run(); Let's assume the above represents an API. As your application progresses, you may have a mixture of different content, and now want to have the above segregated under the path /api . This is essentially the same problem as addressed in the \"Segregating your application to a subpath\" example. To accomplish it: Create a new application. Pipe the previous application to the new one, under the path /api . $middleware1 = new UserMiddleware(); $middleware2 = new ProjectMiddleware(); $api = AppFactory::create(); $api->pipe($middleware1); $api->pipe($middleware2); $app = AppFactory::create(); $app->pipe('/api', $api); $app->run(); The above works, because every Application instance is itself middleware, and, more specifically, an instance of Stratigility's MiddlewarePipe , which provides the ability to compose middleware.","title":"How can I prepend a common path to all my routes?"},{"location":"v1/cookbook/custom-404-page-handling/","text":"How can I set custom 404 page handling? In some cases, you may want to handle 404 errors separately from the final handler . This can be done by registering middleware that operates late \u2014 specifically, after the routing middleware. Such middleware will be executed if no other middleware has executed, and/or when all other middleware calls return $next() without returning a response. Such situations typically mean that no middleware was able to complete the request. Your 404 handler can take one of two approaches: It can set the response status and call $next() with an error condition. In such a case, the final handler will likely be executed, but will have an explicit 404 status to work with. It can create and return a 404 response itself. Calling next with an error condition In the first approach, the NotFound middleware can be as simple as this: namespace Application; class NotFound { public function __invoke($req, $res, $next) { // Other things can be done here; e.g., logging return $next($req, $res->withStatus(404), 'Page Not Found'); } } This example uses the third, optional argument to $next() , which is an error condition. Internally, the final handler will typically see this, and return an error page of some sort. Since we set the response status, and it's an error status code, that status code will be used in the generated response. The TemplatedErrorHandler will use the error template in this particular case, so you will likely need to make some accommodations for 404 responses in that template if you choose this approach. 404 Middleware In the second approach, the NotFound middleware will return a full response. In our example here, we will render a specific template, and use this to seed and return a response. namespace Application; use Zend\\Expressive\\Template\\TemplateRendererInterface; class NotFound { private $renderer; public function __construct(TemplateRendererInterface $renderer) { $this->renderer = $renderer; } public function __invoke($req, $res, $next) { // other things can be done here; e.g., logging // Now set the response status and write to the body $response = $res->withStatus(404); $response->getBody()->write($this->renderer->render('error::not-found')); return $response; } } This approach allows you to have an application-specific workflow for 404 errors that does not rely on the final handler. Registering custom 404 handlers We can register either Application\\NotFound class above as service in the service container . In the case of the second approach, you would also need to provide a factory for creating the middleware (to ensure you inject the template renderer). From there, you still need to register the middleware. This middleware is not routed, and thus needs to be piped to the application instance. You can do this via either configuration, or manually. To do this via configuration, add an entry under the middleware_pipeline configuration, after the dispatch middleware: 'middleware_pipeline' => [ /* ... */ 'routing' => [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Zend\\Expressive\\Helper\\UrlHelperMiddleware::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], [ 'middleware' => 'Application\\NotFound', 'priority' => -1, ], /* ... */ ], The above example assumes you are using the ApplicationFactory and/or the Expressive skeleton to manage your application instantiation and configuration. To manually add the middleware, you will need to pipe it to the application instance: $app->pipe($container->get('Application\\NotFound')); This must be done after : calling $app->pipeDispatchMiddleware() , OR pulling the Application instance from the service container (assuming you used the ApplicationFactory ). This is to ensure that the NotFound middleware executes after any routed middleware, as you only want it to execute if no routed middleware was selected.","title":"Setting custom 404 page handling"},{"location":"v1/cookbook/custom-404-page-handling/#how-can-i-set-custom-404-page-handling","text":"In some cases, you may want to handle 404 errors separately from the final handler . This can be done by registering middleware that operates late \u2014 specifically, after the routing middleware. Such middleware will be executed if no other middleware has executed, and/or when all other middleware calls return $next() without returning a response. Such situations typically mean that no middleware was able to complete the request. Your 404 handler can take one of two approaches: It can set the response status and call $next() with an error condition. In such a case, the final handler will likely be executed, but will have an explicit 404 status to work with. It can create and return a 404 response itself.","title":"How can I set custom 404 page handling?"},{"location":"v1/cookbook/custom-404-page-handling/#calling-next-with-an-error-condition","text":"In the first approach, the NotFound middleware can be as simple as this: namespace Application; class NotFound { public function __invoke($req, $res, $next) { // Other things can be done here; e.g., logging return $next($req, $res->withStatus(404), 'Page Not Found'); } } This example uses the third, optional argument to $next() , which is an error condition. Internally, the final handler will typically see this, and return an error page of some sort. Since we set the response status, and it's an error status code, that status code will be used in the generated response. The TemplatedErrorHandler will use the error template in this particular case, so you will likely need to make some accommodations for 404 responses in that template if you choose this approach.","title":"Calling next with an error condition"},{"location":"v1/cookbook/custom-404-page-handling/#404-middleware","text":"In the second approach, the NotFound middleware will return a full response. In our example here, we will render a specific template, and use this to seed and return a response. namespace Application; use Zend\\Expressive\\Template\\TemplateRendererInterface; class NotFound { private $renderer; public function __construct(TemplateRendererInterface $renderer) { $this->renderer = $renderer; } public function __invoke($req, $res, $next) { // other things can be done here; e.g., logging // Now set the response status and write to the body $response = $res->withStatus(404); $response->getBody()->write($this->renderer->render('error::not-found')); return $response; } } This approach allows you to have an application-specific workflow for 404 errors that does not rely on the final handler.","title":"404 Middleware"},{"location":"v1/cookbook/custom-404-page-handling/#registering-custom-404-handlers","text":"We can register either Application\\NotFound class above as service in the service container . In the case of the second approach, you would also need to provide a factory for creating the middleware (to ensure you inject the template renderer). From there, you still need to register the middleware. This middleware is not routed, and thus needs to be piped to the application instance. You can do this via either configuration, or manually. To do this via configuration, add an entry under the middleware_pipeline configuration, after the dispatch middleware: 'middleware_pipeline' => [ /* ... */ 'routing' => [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Zend\\Expressive\\Helper\\UrlHelperMiddleware::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], [ 'middleware' => 'Application\\NotFound', 'priority' => -1, ], /* ... */ ], The above example assumes you are using the ApplicationFactory and/or the Expressive skeleton to manage your application instantiation and configuration. To manually add the middleware, you will need to pipe it to the application instance: $app->pipe($container->get('Application\\NotFound')); This must be done after : calling $app->pipeDispatchMiddleware() , OR pulling the Application instance from the service container (assuming you used the ApplicationFactory ). This is to ensure that the NotFound middleware executes after any routed middleware, as you only want it to execute if no routed middleware was selected.","title":"Registering custom 404 handlers"},{"location":"v1/cookbook/debug-toolbars/","text":"How can I get a debug toolbar for my Expressive application? Many modern frameworks and applications provide debug toolbars: in-browser toolbars to provide profiling information of the request executed. These can provide invaluable details into application objects, database queries, and more. As an Expressive user, how can you get similar functionality? Zend Server Z-Ray Zend Server ships with a tool called Z-Ray , which provides both a debug toolbar and debug console (for API debugging). Z-Ray is also currently available as a standalone technology preview , and can be added as an extension to an existing PHP installation. When using Zend Server or the standalone Z-Ray, you do not need to make any changes to your application whatsoever to benefit from it; you simply need to make sure Z-Ray is enabled and/or that you've setup a security token to selectively enable it on-demand. See the Z-Ray documentation for full usage details. bitExpert/prophiler-psr7-middleware Another option is bitExpert's prophiler-psr7-middleware . This package wraps fabfuel/prophiler , which provides a PHP-based profiling tool and toolbar; the bitExpert package wraps this in PSR-7 middleware to make consumption in those paradigms trivial. To add the toolbar middleware to your application, use composer: $ composer require bitExpert/prophiler-psr7-middleware From there, you will need to create a factory for the middleware, and add it to your middleware pipeline. Stephan Hochd\u00f6rfer, author of the package, has written a post detailing these steps . Use locally! One minor change we recommend over the directions Stephan provides is that you configure the factory and middleware in the config/autoload/middleware-pipeline.local.php file, vs the .global version. Doing so enables the middleware and toolbar only in the local environment \u2014 and not in production, where you likely do not want to expose such information! php-middleware/php-debug-bar php-middleware/php-debug-bar provides a PSR-7 middleware wrapper around maximebf/php-debugbar , a popular framework-agnostic debug bar for PHP projects. First, install the middleware in your application: $ composer require php-middleware/php-debug-bar This package provides a config provider. You can add it to your application in one of two ways: If you are using the ConfigManager , add an entry for it: php $configManager = new Zend\\Expressive\\ConfigManager\\ConfigManager([ PhpMiddleware\\PhpDebugBar\\ConfigProvider::class, new Zend\\Expressive\\ConfigManager\\PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'), ]); If you are not using the ConfigManager, create a new configuration file, config/autoload/php-debugbar.global.php , with the following contents: ```php <?php use PhpMiddleware\\PhpDebugBar\\ConfigProvider; $provider = new ConfigProvider(); return $provider(); ``` Use locally! Remember to enable PhpMiddleware\\PhpDebugBar\\ConfigProvider only in your development enviroments!","title":"Enabling debug toolbars"},{"location":"v1/cookbook/debug-toolbars/#how-can-i-get-a-debug-toolbar-for-my-expressive-application","text":"Many modern frameworks and applications provide debug toolbars: in-browser toolbars to provide profiling information of the request executed. These can provide invaluable details into application objects, database queries, and more. As an Expressive user, how can you get similar functionality?","title":"How can I get a debug toolbar for my Expressive application?"},{"location":"v1/cookbook/debug-toolbars/#zend-server-z-ray","text":"Zend Server ships with a tool called Z-Ray , which provides both a debug toolbar and debug console (for API debugging). Z-Ray is also currently available as a standalone technology preview , and can be added as an extension to an existing PHP installation. When using Zend Server or the standalone Z-Ray, you do not need to make any changes to your application whatsoever to benefit from it; you simply need to make sure Z-Ray is enabled and/or that you've setup a security token to selectively enable it on-demand. See the Z-Ray documentation for full usage details.","title":"Zend Server Z-Ray"},{"location":"v1/cookbook/debug-toolbars/#bitexpertprophiler-psr7-middleware","text":"Another option is bitExpert's prophiler-psr7-middleware . This package wraps fabfuel/prophiler , which provides a PHP-based profiling tool and toolbar; the bitExpert package wraps this in PSR-7 middleware to make consumption in those paradigms trivial. To add the toolbar middleware to your application, use composer: $ composer require bitExpert/prophiler-psr7-middleware From there, you will need to create a factory for the middleware, and add it to your middleware pipeline. Stephan Hochd\u00f6rfer, author of the package, has written a post detailing these steps .","title":"bitExpert/prophiler-psr7-middleware"},{"location":"v1/cookbook/debug-toolbars/#php-middlewarephp-debug-bar","text":"php-middleware/php-debug-bar provides a PSR-7 middleware wrapper around maximebf/php-debugbar , a popular framework-agnostic debug bar for PHP projects. First, install the middleware in your application: $ composer require php-middleware/php-debug-bar This package provides a config provider. You can add it to your application in one of two ways: If you are using the ConfigManager , add an entry for it: php $configManager = new Zend\\Expressive\\ConfigManager\\ConfigManager([ PhpMiddleware\\PhpDebugBar\\ConfigProvider::class, new Zend\\Expressive\\ConfigManager\\PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'), ]); If you are not using the ConfigManager, create a new configuration file, config/autoload/php-debugbar.global.php , with the following contents: ```php <?php use PhpMiddleware\\PhpDebugBar\\ConfigProvider; $provider = new ConfigProvider(); return $provider(); ```","title":"php-middleware/php-debug-bar"},{"location":"v1/cookbook/flash-messengers/","text":"How Can I Implement Flash Messages? Flash messages are used to display one-time messages to a user. A typical use case is for setting and later displaying a successful submission via a Post/Redirect/Get (PRG) workflow, where the flash message would be set during the POST request, but displayed during the GET request. (PRG is used to prevent double-submission of forms.) As such, flash messages usually are session-based; the message is set in one request, and accessed and cleared in another. Expressive does not provide native session facilities out-of-the-box, which means you will need: Session functionality. Flash message functionality, for handling message expiry from the session after first access. A number of flash message libraries already exist that can be integrated via middleware, and these typically either use PHP's ext/session functionality or have a dependency on a session library. Two such libraries are slim/flash and damess/expressive-session-middleware. slim/flash Slim's Flash messages service provider can be used in Expressive. It uses PHP's native session support. First, you'll need to add it to your application: $ composer require slim/flash Once you have, you'll need to create a factory to return middleware that will add the flash message provider to the request: namespace App; use Slim\\Flash\\Messages; class SlimFlashMiddlewareFactory { public function __invoke($container) { return function ($request, $response, $next) { // Start the session whenever we use this! session_start(); return $next( $request->withAttribute('flash', new Messages()), $response ); }; } } Now, let's register it with our middleware pipeline. In config/autoload/middleware-pipeline.global.php , make the following additions: return [ 'dependencies' => [ 'factories' => [ 'App\\SlimFlashMiddleware' => App\\SlimFlashMiddlewareFactory::class, /* ... */ ], /* ... */ ], 'middleware_pipeline' => [ 'always' => [ 'middleware' => [ 'App\\SlimFlashMiddleware', /* ... */ ], 'priority' => 10000, ], /* ... */ ], ]; Where to register the flash middleware Sessions can sometimes be expensive. As such, you may not want the flash middleware enabled for every request. If this is the case, add the flash middleware as part of a route-specific pipeline instead. From here, you can add and read messages by accessing the request's flash attribute. As an example, middleware generating messages might read as follows: use Zend\\Diactoros\\Response\\RedirectResponse; public function __invoke($request, $response, $next) { $flash = $request->getAttribute('flash'); $flash->addMessage('message', 'Hello World!'); return new RedirectResponse('/other-middleware'); } And middleware consuming the message might read: public function __invoke($request, $response, $next) { $flash = $request->getAttribute('flash'); $messages = $flash->getMessages(); // ... } From there, it's a matter of providing the flash messages to your template. damess/expressive-session-middleware and Aura.Session damess/expressive-session-middleware provides middleware for initializing an Aura.Session instance; Aura.Session provides flash messaging capabilities as part of its featureset. Install it via Composer: $ composer require damess/expressive-session-middleware In config/autoload/dependencies.global.php , add an entry for Aura.Session: return [ 'dependencies' => [ 'factories' => [ Aura\\Session\\Session::class => DaMess\\Factory\\AuraSessionFactory::class, /* ... */ ], /* ... */ ], ]; In config/autoload/middleware-pipeline.global.php , add a factory entry for the damess/expressive-session-middleware , and add it to the middleware pipeline: return [ 'dependencies' => [ 'factories' => [ DaMess\\Http\\SessionMiddleware::class => DaMess\\Factory\\SessionMiddlewareFactory::class, /* ... */ ], /* ... */ ], 'middleware_pipeline' => [ 'always' => [ 'middleware' => [ DaMess\\Http\\SessionMiddleware::class, /* ... */ ], 'priority' => 10000, ], /* ... */ ], ]; Where to register the session middleware Sessions can sometimes be expensive. As such, you may not want the session middleware enabled for every request. If this is the case, add the session middleware as part of a route-specific pipeline instead. Once enabled, the SessionMiddleware will inject the Aura.Session instance into the request as the session attribute; you can thus retrieve it within middleware using the following: $session = $request->getAttribute('session'); To create and consume flash messages, use Aura.Session's flash values . As an example, the middleware that is processing a POST request might set a flash message: use Zend\\Diactoros\\Response\\RedirectResponse; public function __invoke($request, $response, $next) { $session = $request->getAttribute('session'); $session->getSegment(__NAMESPACE__) ->setFlash('message', 'Hello World!'); return new RedirectResponse('/other-middleware'); } Another middleware, to which the original middleware redirects, might look like this: public function __invoke($request, $response, $next) { $session = $request->getAttribute('session'); $message = $session->getSegment(__NAMESPACE__) ->getFlash('message'); // ... } From there, it's a matter of providing the flash messages to your template.","title":"Flash Messengers"},{"location":"v1/cookbook/flash-messengers/#how-can-i-implement-flash-messages","text":"Flash messages are used to display one-time messages to a user. A typical use case is for setting and later displaying a successful submission via a Post/Redirect/Get (PRG) workflow, where the flash message would be set during the POST request, but displayed during the GET request. (PRG is used to prevent double-submission of forms.) As such, flash messages usually are session-based; the message is set in one request, and accessed and cleared in another. Expressive does not provide native session facilities out-of-the-box, which means you will need: Session functionality. Flash message functionality, for handling message expiry from the session after first access. A number of flash message libraries already exist that can be integrated via middleware, and these typically either use PHP's ext/session functionality or have a dependency on a session library. Two such libraries are slim/flash and damess/expressive-session-middleware.","title":"How Can I Implement Flash Messages?"},{"location":"v1/cookbook/flash-messengers/#slimflash","text":"Slim's Flash messages service provider can be used in Expressive. It uses PHP's native session support. First, you'll need to add it to your application: $ composer require slim/flash Once you have, you'll need to create a factory to return middleware that will add the flash message provider to the request: namespace App; use Slim\\Flash\\Messages; class SlimFlashMiddlewareFactory { public function __invoke($container) { return function ($request, $response, $next) { // Start the session whenever we use this! session_start(); return $next( $request->withAttribute('flash', new Messages()), $response ); }; } } Now, let's register it with our middleware pipeline. In config/autoload/middleware-pipeline.global.php , make the following additions: return [ 'dependencies' => [ 'factories' => [ 'App\\SlimFlashMiddleware' => App\\SlimFlashMiddlewareFactory::class, /* ... */ ], /* ... */ ], 'middleware_pipeline' => [ 'always' => [ 'middleware' => [ 'App\\SlimFlashMiddleware', /* ... */ ], 'priority' => 10000, ], /* ... */ ], ];","title":"slim/flash"},{"location":"v1/cookbook/flash-messengers/#damessexpressive-session-middleware-and-aurasession","text":"damess/expressive-session-middleware provides middleware for initializing an Aura.Session instance; Aura.Session provides flash messaging capabilities as part of its featureset. Install it via Composer: $ composer require damess/expressive-session-middleware In config/autoload/dependencies.global.php , add an entry for Aura.Session: return [ 'dependencies' => [ 'factories' => [ Aura\\Session\\Session::class => DaMess\\Factory\\AuraSessionFactory::class, /* ... */ ], /* ... */ ], ]; In config/autoload/middleware-pipeline.global.php , add a factory entry for the damess/expressive-session-middleware , and add it to the middleware pipeline: return [ 'dependencies' => [ 'factories' => [ DaMess\\Http\\SessionMiddleware::class => DaMess\\Factory\\SessionMiddlewareFactory::class, /* ... */ ], /* ... */ ], 'middleware_pipeline' => [ 'always' => [ 'middleware' => [ DaMess\\Http\\SessionMiddleware::class, /* ... */ ], 'priority' => 10000, ], /* ... */ ], ];","title":"damess/expressive-session-middleware and Aura.Session"},{"location":"v1/cookbook/modular-layout/","text":"How can I make my application modular? Zend Framework 2 applications have a concept of modules, independent units that can provide configuration, services, and hooks into its MVC lifecycle. This functionality is provided by zend-modulemanager. While zend-modulemanager could be used with Expressive, we suggest another approach: modules that are based only on configuration. This powerful approach doesn't affect performance, and offers extensive flexibility: each module can provide its own services (with factories), default configuration, and routes. This cookbook will show how to organize modules using mtymek/expressive-config-manager , a lightweight library that aggregates and merges configuration, optionally caching it. Install the configuration manager The configuration manager is available in Packagist: $ composer require mtymek/expressive-config-manager Generate your config The default Expressive skeleton installs a config/config.php file, which aggregates all configuration. When using the configuration manager, you will need to replace the contents of that file with the following code: <?php use Zend\\Expressive\\ConfigManager\\ConfigManager; use Zend\\Expressive\\ConfigManager\\PhpFileProvider; $configManager = new ConfigManager([ new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'), ]); return new ArrayObject($configManager->getMergedConfig()); If you open your application in a browser, it should still work in exactly the same way as it was before. Now you can start adding your modules. First module ConfigManager does not force you to use any particular structure for your module; its only requirement is to expose default configuration using a \"config provider\", which is simply an invokable class that returns a configuration array. For instance, this is how your module could provide its own routes: namespace MyModule; class ModuleConfig { public function __invoke() { return [ 'routes' => [ [ 'name' => 'api.list-transactions', 'path' => '/api/transactions', 'middleware' => App\\Action\\ListTransactionsAction::class, 'allowed_methods' => ['GET'], ], [ 'name' => 'api.refund-transaction', 'path' => '/api/refund', 'middleware' => App\\Action\\RefundAction::class, 'allowed_methods' => ['POST'], ], ], ]; } } Enabling the module Finally, you can enable your module by adding a reference to your config class within the arguments of the ConfigManager constructor in the config/config.php file: $configManager = new ConfigManager([ MyModule\\ModuleConfig::class, new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'), ]); Caching configuration In order to provide configuration caching, two things must occur: First, you must define a config_cache_enabled key in your configuration somewhere. Second, you must pass a second argument to the ConfigManager , the location of the cache file to use. The config_cache_enabled key can be defined in any of your configuration providers, including the autoloaded configuration files. We recommend defining them in two locations: config/autoload/global.php should define the value to true , as the production setting. config/autoload/local.php should also define the setting, and use a value appropriate to the current environment. In development, for instance, this would be false . // config/autoload/global.php return [ 'config_cache_enabled' => true, /* ... */ ]; // config/autoload/local.php return [ 'config_cache_enabled' => false, // <- development! /* ... */ ]; You would then alter your config/config.php file to add the second argument. The following example builds on the previous, and demonstrates having the AppConfig entry enabled. The configuration will be cached to data/config-cache.php in the application root: $configManager = new ConfigManager([ App\\AppConfig::class, new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'), ], 'data/config-cache.php'); When the configuration cache path is present, if the config_cache_enabled flag is enabled, then configuration will be read from the cached configuration, instead of parsing and merging the various configuration sources. Final notes This approach may look simple, but it is flexible and powerful: You pass a list of config providers to the ConfigManager constructor. Configuration is merged in the same order as it is passed, with later entries having precedence. You can override module configuration using *.global.php and *.local.php files. If cached config is found, ConfigManager does not iterate over provider list. For more details, please refer to the Config Manager Documentation .","title":"Building modular applications"},{"location":"v1/cookbook/modular-layout/#how-can-i-make-my-application-modular","text":"Zend Framework 2 applications have a concept of modules, independent units that can provide configuration, services, and hooks into its MVC lifecycle. This functionality is provided by zend-modulemanager. While zend-modulemanager could be used with Expressive, we suggest another approach: modules that are based only on configuration. This powerful approach doesn't affect performance, and offers extensive flexibility: each module can provide its own services (with factories), default configuration, and routes. This cookbook will show how to organize modules using mtymek/expressive-config-manager , a lightweight library that aggregates and merges configuration, optionally caching it.","title":"How can I make my application modular?"},{"location":"v1/cookbook/modular-layout/#install-the-configuration-manager","text":"The configuration manager is available in Packagist: $ composer require mtymek/expressive-config-manager","title":"Install the configuration manager"},{"location":"v1/cookbook/modular-layout/#generate-your-config","text":"The default Expressive skeleton installs a config/config.php file, which aggregates all configuration. When using the configuration manager, you will need to replace the contents of that file with the following code: <?php use Zend\\Expressive\\ConfigManager\\ConfigManager; use Zend\\Expressive\\ConfigManager\\PhpFileProvider; $configManager = new ConfigManager([ new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'), ]); return new ArrayObject($configManager->getMergedConfig()); If you open your application in a browser, it should still work in exactly the same way as it was before. Now you can start adding your modules.","title":"Generate your config"},{"location":"v1/cookbook/modular-layout/#first-module","text":"ConfigManager does not force you to use any particular structure for your module; its only requirement is to expose default configuration using a \"config provider\", which is simply an invokable class that returns a configuration array. For instance, this is how your module could provide its own routes: namespace MyModule; class ModuleConfig { public function __invoke() { return [ 'routes' => [ [ 'name' => 'api.list-transactions', 'path' => '/api/transactions', 'middleware' => App\\Action\\ListTransactionsAction::class, 'allowed_methods' => ['GET'], ], [ 'name' => 'api.refund-transaction', 'path' => '/api/refund', 'middleware' => App\\Action\\RefundAction::class, 'allowed_methods' => ['POST'], ], ], ]; } }","title":"First module"},{"location":"v1/cookbook/modular-layout/#enabling-the-module","text":"Finally, you can enable your module by adding a reference to your config class within the arguments of the ConfigManager constructor in the config/config.php file: $configManager = new ConfigManager([ MyModule\\ModuleConfig::class, new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'), ]);","title":"Enabling the module"},{"location":"v1/cookbook/modular-layout/#caching-configuration","text":"In order to provide configuration caching, two things must occur: First, you must define a config_cache_enabled key in your configuration somewhere. Second, you must pass a second argument to the ConfigManager , the location of the cache file to use. The config_cache_enabled key can be defined in any of your configuration providers, including the autoloaded configuration files. We recommend defining them in two locations: config/autoload/global.php should define the value to true , as the production setting. config/autoload/local.php should also define the setting, and use a value appropriate to the current environment. In development, for instance, this would be false . // config/autoload/global.php return [ 'config_cache_enabled' => true, /* ... */ ]; // config/autoload/local.php return [ 'config_cache_enabled' => false, // <- development! /* ... */ ]; You would then alter your config/config.php file to add the second argument. The following example builds on the previous, and demonstrates having the AppConfig entry enabled. The configuration will be cached to data/config-cache.php in the application root: $configManager = new ConfigManager([ App\\AppConfig::class, new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'), ], 'data/config-cache.php'); When the configuration cache path is present, if the config_cache_enabled flag is enabled, then configuration will be read from the cached configuration, instead of parsing and merging the various configuration sources.","title":"Caching configuration"},{"location":"v1/cookbook/modular-layout/#final-notes","text":"This approach may look simple, but it is flexible and powerful: You pass a list of config providers to the ConfigManager constructor. Configuration is merged in the same order as it is passed, with later entries having precedence. You can override module configuration using *.global.php and *.local.php files. If cached config is found, ConfigManager does not iterate over provider list. For more details, please refer to the Config Manager Documentation .","title":"Final notes"},{"location":"v1/cookbook/route-specific-pipeline/","text":"How can I specify a route-specific middleware pipeline? Sometimes you may want to use a middleware pipeline only if a particular route is matched. As an example, for an API resource, you might want to: check for authentication credentials check for authorization for the selected action parse the incoming body validate the parsed body parameters before you actually execute the selected middleware. The above might each be encapsulated as discrete middleware, but should be executed within the routed middleware's context. You can accomplish this in one of two ways: Have your middleware service resolve to a MiddlewarePipe instance that composes the various middlewares. Specify an array of middlewares (either as actual instances, or as container service names); this effectively creates and returns a MiddlewarePipe . Resolving to a MiddlewarePipe You can do this programmatically within a container factory, assuming you are using a container that supports factories. use Interop\\Container\\ContainerInterface; use Zend\\Stratigility\\MiddlewarePipe; class ApiResourcePipelineFactory { public function __invoke(ContainerInterface $container) { $pipeline = new MiddlewarePipe(); // These correspond to the bullet points above $pipeline->pipe($container->get('AuthenticationMiddleware')); $pipeline->pipe($container->get('AuthorizationMiddleware')); $pipeline->pipe($container->get('BodyParsingMiddleware')); $pipeline->pipe($container->get('ValidationMiddleware')); // This is the actual middleware you're routing to. $pipeline->pipe($container->get('ApiResource')); return $pipeline; } } This gives you full control over the creation of the pipeline. You would, however, need to ensure that you map the middleware to the pipeline factory when setting up your container configuration. One alternative when using zend-servicemanager is to use a delegator factory . Delegator factories allow you to decorate the primary factory used to create the middleware in order to change the instance or return an alternate instance. In this case, we'd do the latter. The following is an example: use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\DelegatorFactoryInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; use Zend\\Stratigility\\MiddlewarePipe; class ApiResourcePipelineDelegatorFactory implements DelegatorFactoryInterface { /** * zend-servicemanager v3 support */ public function __invoke( ContainerInterface $container, $name, callable $callback, array $options = null ) { $pipeline = new MiddlewarePipe(); // These correspond to the bullet points above $pipeline->pipe($container->get('AuthenticationMiddleware')); $pipeline->pipe($container->get('AuthorizationMiddleware')); $pipeline->pipe($container->get('BodyParsingMiddleware')); $pipeline->pipe($container->get('ValidationMiddleware')); // This is the actual middleware you're routing to. $pipeline->pipe($callback()); return $pipeline; } /** * zend-servicemanager v2 support */ public function createDelegatorWithName( ServiceLocatorInterface $container, $name, $requestedName, $callback ) { return $this($container, $name, $callback); } } When configuring the container, you'd do something like the following: return [ 'dependencies' => [ 'factories' => [ 'AuthenticationMiddleware' => '...', 'AuthorizationMiddleware' => '...', 'BodyParsingMiddleware' => '...', 'ValidationMiddleware' => '...', 'ApiResourceMiddleware' => '...', ], 'delegators' => [ 'ApiResourceMiddleware' => [ 'ApiResourcePipelineDelegatorFactory', ], ], ], ]; This approach allows you to cleanly separate the factory for your middleware from the pipeline you want to compose it in, and allows you to re-use the pipeline creation across multiple middleware if desired. Middleware Arrays If you'd rather not create a factory for each such middleware, the other option is to use arrays of middlewares in your configuration or when routing manually. Via configuration looks like this: return [ 'routes' => [ [ 'name' => 'api-resource', 'path' => '/api/resource[/{id:[a-f0-9]{32}}]', 'allowed_methods' => ['GET', 'POST', 'PATCH', 'DELETE'], 'middleware' => [ 'AuthenticationMiddleware', 'AuthorizationMiddleware', 'BodyParsingMiddleware', 'ValidationMiddleware', 'ApiResourceMiddleware', ], ], ], ]; Manual routing looks like this: $app->route('/api/resource[/{id:[a-f0-9]{32}}]', [ 'AuthenticationMiddleware', 'AuthorizationMiddleware', 'BodyParsingMiddleware', 'ValidationMiddleware', 'ApiResourceMiddleware', ], ['GET', 'POST', 'PATCH', 'DELETE'], 'api-resource'); When either of these approaches are used, the individual middleware listed MUST be one of the following: a callable middleware; a service name of middleware available in the container; a fully qualified class name of a directly instantiable (no constructor arguments) middleware class. This approach is essentially equivalent to creating a factory that returns a middleware pipeline. What about pipeline middleware configuration? What if you want to do this with your pipeline middleware configuration? The answer is that the syntax is exactly the same! return [ 'middleware_pipeline' => [ 'api' => [ 'path' => '/api', 'middleware' => [ 'AuthenticationMiddleware', 'AuthorizationMiddleware', 'BodyParsingMiddleware', 'ValidationMiddleware', ], 'priority' => 100, ], ], ];","title":"Route-specific middleware pipelines"},{"location":"v1/cookbook/route-specific-pipeline/#how-can-i-specify-a-route-specific-middleware-pipeline","text":"Sometimes you may want to use a middleware pipeline only if a particular route is matched. As an example, for an API resource, you might want to: check for authentication credentials check for authorization for the selected action parse the incoming body validate the parsed body parameters before you actually execute the selected middleware. The above might each be encapsulated as discrete middleware, but should be executed within the routed middleware's context. You can accomplish this in one of two ways: Have your middleware service resolve to a MiddlewarePipe instance that composes the various middlewares. Specify an array of middlewares (either as actual instances, or as container service names); this effectively creates and returns a MiddlewarePipe .","title":"How can I specify a route-specific middleware pipeline?"},{"location":"v1/cookbook/route-specific-pipeline/#resolving-to-a-middlewarepipe","text":"You can do this programmatically within a container factory, assuming you are using a container that supports factories. use Interop\\Container\\ContainerInterface; use Zend\\Stratigility\\MiddlewarePipe; class ApiResourcePipelineFactory { public function __invoke(ContainerInterface $container) { $pipeline = new MiddlewarePipe(); // These correspond to the bullet points above $pipeline->pipe($container->get('AuthenticationMiddleware')); $pipeline->pipe($container->get('AuthorizationMiddleware')); $pipeline->pipe($container->get('BodyParsingMiddleware')); $pipeline->pipe($container->get('ValidationMiddleware')); // This is the actual middleware you're routing to. $pipeline->pipe($container->get('ApiResource')); return $pipeline; } } This gives you full control over the creation of the pipeline. You would, however, need to ensure that you map the middleware to the pipeline factory when setting up your container configuration. One alternative when using zend-servicemanager is to use a delegator factory . Delegator factories allow you to decorate the primary factory used to create the middleware in order to change the instance or return an alternate instance. In this case, we'd do the latter. The following is an example: use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\DelegatorFactoryInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; use Zend\\Stratigility\\MiddlewarePipe; class ApiResourcePipelineDelegatorFactory implements DelegatorFactoryInterface { /** * zend-servicemanager v3 support */ public function __invoke( ContainerInterface $container, $name, callable $callback, array $options = null ) { $pipeline = new MiddlewarePipe(); // These correspond to the bullet points above $pipeline->pipe($container->get('AuthenticationMiddleware')); $pipeline->pipe($container->get('AuthorizationMiddleware')); $pipeline->pipe($container->get('BodyParsingMiddleware')); $pipeline->pipe($container->get('ValidationMiddleware')); // This is the actual middleware you're routing to. $pipeline->pipe($callback()); return $pipeline; } /** * zend-servicemanager v2 support */ public function createDelegatorWithName( ServiceLocatorInterface $container, $name, $requestedName, $callback ) { return $this($container, $name, $callback); } } When configuring the container, you'd do something like the following: return [ 'dependencies' => [ 'factories' => [ 'AuthenticationMiddleware' => '...', 'AuthorizationMiddleware' => '...', 'BodyParsingMiddleware' => '...', 'ValidationMiddleware' => '...', 'ApiResourceMiddleware' => '...', ], 'delegators' => [ 'ApiResourceMiddleware' => [ 'ApiResourcePipelineDelegatorFactory', ], ], ], ]; This approach allows you to cleanly separate the factory for your middleware from the pipeline you want to compose it in, and allows you to re-use the pipeline creation across multiple middleware if desired.","title":"Resolving to a MiddlewarePipe"},{"location":"v1/cookbook/route-specific-pipeline/#middleware-arrays","text":"If you'd rather not create a factory for each such middleware, the other option is to use arrays of middlewares in your configuration or when routing manually. Via configuration looks like this: return [ 'routes' => [ [ 'name' => 'api-resource', 'path' => '/api/resource[/{id:[a-f0-9]{32}}]', 'allowed_methods' => ['GET', 'POST', 'PATCH', 'DELETE'], 'middleware' => [ 'AuthenticationMiddleware', 'AuthorizationMiddleware', 'BodyParsingMiddleware', 'ValidationMiddleware', 'ApiResourceMiddleware', ], ], ], ]; Manual routing looks like this: $app->route('/api/resource[/{id:[a-f0-9]{32}}]', [ 'AuthenticationMiddleware', 'AuthorizationMiddleware', 'BodyParsingMiddleware', 'ValidationMiddleware', 'ApiResourceMiddleware', ], ['GET', 'POST', 'PATCH', 'DELETE'], 'api-resource'); When either of these approaches are used, the individual middleware listed MUST be one of the following: a callable middleware; a service name of middleware available in the container; a fully qualified class name of a directly instantiable (no constructor arguments) middleware class. This approach is essentially equivalent to creating a factory that returns a middleware pipeline.","title":"Middleware Arrays"},{"location":"v1/cookbook/route-specific-pipeline/#what-about-pipeline-middleware-configuration","text":"What if you want to do this with your pipeline middleware configuration? The answer is that the syntax is exactly the same! return [ 'middleware_pipeline' => [ 'api' => [ 'path' => '/api', 'middleware' => [ 'AuthenticationMiddleware', 'AuthorizationMiddleware', 'BodyParsingMiddleware', 'ValidationMiddleware', ], 'priority' => 100, ], ], ];","title":"What about pipeline middleware configuration?"},{"location":"v1/cookbook/setting-locale-depending-routing-parameter/","text":"How can I setup the locale depending on a routing parameter? Localized web applications often set the locale (and therefor the language) based on a routing parameter, the session, or a specialized sub-domain. In this recipe we will concentrate on using a routing parameter. Routing parameters Using the approach in this chapter requires that you add a /:locale (or similar) segment to each and every route that can be localized, and, depending on the router used, may also require additional options for specifying constraints. If the majority of your routes are localized, this will become tedious quickly. In such a case, you may want to look at the related recipe on setting the locale without routing parameters . Setting up the route If you want to set the locale depending on an routing parameter, you first have to add a locale parameter to each route that requires localization. In this example we use the locale parameter, which should consist of two lowercase alphabetical characters: return [ 'dependencies' => [ 'invokables' => [ Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\ZendRouter::class, ], 'factories' => [ Application\\Action\\HomePageAction::class => Application\\Action\\HomePageFactory::class, Application\\Action\\ContactPageAction::class => Application\\Action\\ContactPageFactory::class, ], ], 'routes' => [ [ 'name' => 'home', 'path' => '/:locale', 'middleware' => Application\\Action\\HomePageAction::class, 'allowed_methods' => ['GET'], 'options' => [ 'constraints' => [ 'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)', ], ], ], [ 'name' => 'contact', 'path' => '/:locale/contact', 'middleware' => Application\\Action\\ContactPageAction::class, 'allowed_methods' => ['GET'], 'options' => [ 'constraints' => [ 'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)', ], ], ], ], ]; Note: Routing may differ based on router The routing examples in this recipe use syntax for the zend-mvc router, and, as such, may not work in your application. For Aura.Router, the 'home' route as listed above would read: $$$$FENCED_CODE_BLOCK_5e03bdea002220.42363558 For FastRoute: $$$$FENCED_CODE_BLOCK_5e03bdea002387.94565927 As such, be aware as you read the examples that you might not be able to simply cut-and-paste them without modification. Create a route result middleware class for localization To make sure that you can setup the locale after the routing has been processed, you need to implement localization middleware that acts on the route result, and registered in the pipeline immediately following the routing middleware. Such a LocalizationMiddleware class could look similar to this: <?php namespace Application\\I18n; use Locale; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; class LocalizationMiddleware { const LOCALIZATION_ATTRIBUTE = 'locale'; public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next = null) { // Get locale from route, fallback to the user's browser preference $locale = $request->getAttribute( 'locale', Locale::acceptFromHttp( isset($request->getServerParams()['HTTP_ACCEPT_LANGUAGE']) ? $request->getServerParams()['HTTP_ACCEPT_LANGUAGE'] : 'en_US' ) ); // Store the locale as a request attribute return $next($request->withAttribute(self::LOCALIZATION_ATTRIBUTE, $locale), $response); } } Locale::setDefault is unsafe Do not use Locale::setDefault($locale) to set a global static locale. PSR-7 apps may run in async processes, which could lead to another process overwriting the value, and thus lead to unexpected results for your users. Use a request parameter as detailed above instead, as the request is created specific to each process. In your config/autoload/middleware-pipeline.global.php , you'd register the dependency, and inject the middleware into the pipeline following the routing middleware: return [ 'dependencies' => [ 'invokables' => [ LocalizationMiddleware::class => LocalizationMiddleware::class, /* ... */ ], /* ... */ ], 'middleware_pipeline' => [ /* ... */ [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Helper\\UrlHelperMiddleware::class, LocalizationMiddleware::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], /* ... */ ], ];","title":"Setting a locale based on a routing parameter"},{"location":"v1/cookbook/setting-locale-depending-routing-parameter/#how-can-i-setup-the-locale-depending-on-a-routing-parameter","text":"Localized web applications often set the locale (and therefor the language) based on a routing parameter, the session, or a specialized sub-domain. In this recipe we will concentrate on using a routing parameter.","title":"How can I setup the locale depending on a routing parameter?"},{"location":"v1/cookbook/setting-locale-depending-routing-parameter/#setting-up-the-route","text":"If you want to set the locale depending on an routing parameter, you first have to add a locale parameter to each route that requires localization. In this example we use the locale parameter, which should consist of two lowercase alphabetical characters: return [ 'dependencies' => [ 'invokables' => [ Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\ZendRouter::class, ], 'factories' => [ Application\\Action\\HomePageAction::class => Application\\Action\\HomePageFactory::class, Application\\Action\\ContactPageAction::class => Application\\Action\\ContactPageFactory::class, ], ], 'routes' => [ [ 'name' => 'home', 'path' => '/:locale', 'middleware' => Application\\Action\\HomePageAction::class, 'allowed_methods' => ['GET'], 'options' => [ 'constraints' => [ 'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)', ], ], ], [ 'name' => 'contact', 'path' => '/:locale/contact', 'middleware' => Application\\Action\\ContactPageAction::class, 'allowed_methods' => ['GET'], 'options' => [ 'constraints' => [ 'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)', ], ], ], ], ];","title":"Setting up the route"},{"location":"v1/cookbook/setting-locale-depending-routing-parameter/#create-a-route-result-middleware-class-for-localization","text":"To make sure that you can setup the locale after the routing has been processed, you need to implement localization middleware that acts on the route result, and registered in the pipeline immediately following the routing middleware. Such a LocalizationMiddleware class could look similar to this: <?php namespace Application\\I18n; use Locale; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; class LocalizationMiddleware { const LOCALIZATION_ATTRIBUTE = 'locale'; public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next = null) { // Get locale from route, fallback to the user's browser preference $locale = $request->getAttribute( 'locale', Locale::acceptFromHttp( isset($request->getServerParams()['HTTP_ACCEPT_LANGUAGE']) ? $request->getServerParams()['HTTP_ACCEPT_LANGUAGE'] : 'en_US' ) ); // Store the locale as a request attribute return $next($request->withAttribute(self::LOCALIZATION_ATTRIBUTE, $locale), $response); } }","title":"Create a route result middleware class for localization"},{"location":"v1/cookbook/setting-locale-without-routing-parameter/","text":"How can I setup the locale without routing parameters? Localized web applications often set the locale (and therefor the language) based on a routing parameter, the session, or a specialized sub-domain. In this recipe we will concentrate on introspecting the URI path via middleware, which allows you to have a global mechanism for detecting the locale without requiring any changes to existing routes. Distinguishing between routes that require localization If your application has a mixture of routes that require localization, and those that do not, the solution in this recipe may lead to multiple URIs that resolve to the identical action, which may be undesirable. In such cases, you may want to prefix the specific routes that require localization with a required routing parameter; this approach is described in the \"Setting a locale based on a routing parameter\" recipe . Setup a middleware to extract the locale from the URI First, we need to setup middleware that extracts the locale param directly from the request URI's path. If if doesn't find one, it sets a default. If it does find one, it uses the value to setup the locale. It also: amends the request with a truncated path (removing the locale segment). adds the locale segment as the base path of the UrlHelper . namespace Application\\I18n; use Locale; use Zend\\Expressive\\Helper\\UrlHelper; class SetLocaleMiddleware { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } public function __invoke($request, $response, callable $next) { $uri = $request->getUri(); $path = $uri->getPath(); if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) { Locale::setDefault('de_DE'); return $next($request, $response); } $locale = $matches['locale']; Locale::setDefault(Locale::canonicalize($locale)); $this->helper->setBasePath($locale); return $next( $request->withUri( $uri->withPath(substr($path, 3)) ), $response ); } } Then you will need a factory for the SetLocaleMiddleware to inject the UrlHelper instance. namespace Application\\I18n; use Interop\\Container\\ContainerInterface; use Zend\\Expressive\\Helper\\UrlHelper; class SetLocaleMiddlewareFactory { public function __invoke(ContainerInterface $container) { return new SetLocaleMiddleware( $container->get(UrlHelper::class) ); } } Afterwards, you need to configure the SetLocaleMiddleware in your /config/autoload/middleware-pipeline.global.php file so that it is executed on every request. return [ 'dependencies' => [ /* ... */ 'factories' => [ Application\\I18n\\SetLocaleMiddleware::class => Application\\I18n\\SetLocaleMiddlewareFactory::class, /* ... */ ], ] 'middleware_pipeline' => [ [ 'middleware' => [ Application\\I18n\\SetLocaleMiddleware::class, /* ... */ ], 'priority' => 1000, ], /* ... */ 'routing' => [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Zend\\Expressive\\Helper\\UrlHelperMiddleware::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], /* ... */ ], ]; Url generation in the view Since the UrlHelper has the locale set as a base path, you don't need to worry about generating URLs within your view. Just use the helper to generate a URL and it will do the rest. <?php echo $this->url('your-route') ?> Helpers differ between template renderers The above example is specific to zend-view; syntax will differ for Twig and Plates. Redirecting within your middleware If you want to add the locale parameter when creating URIs within your action middleware, you just need to inject the UrlHelper into your middleware and use it for URL generation: namespace Application\\Action; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\RedirectResponse; use Zend\\Expressive\\Helper\\UrlHelper; class RedirectAction { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } /** * @param ServerRequestInterface $request * @param ResponseInterface $response * @param callable|null $next * * @return RedirectResponse */ public function __invoke( ServerRequestInterface $request, ResponseInterface $response, callable $next = null ) { $routeParams = [ /* ... */ ]; return new RedirectResponse( $this->helper->generate('your-route', $routeParams) ); } } Injecting the UrlHelper into your middleware will also require that the middleware have a factory that manages the injection. As an example, the following would work for the above middleware: namespace Application\\Action; use Interop\\Container\\ContainerInterface; use Zend\\Expressive\\Helper\\UrlHelper; class RedirectActionFactory { public function __invoke(ContainerInterface $container) { return new RedirectAction( $container->get(UrlHelper::class) ); } }","title":"Setting a locale without a routing parameter"},{"location":"v1/cookbook/setting-locale-without-routing-parameter/#how-can-i-setup-the-locale-without-routing-parameters","text":"Localized web applications often set the locale (and therefor the language) based on a routing parameter, the session, or a specialized sub-domain. In this recipe we will concentrate on introspecting the URI path via middleware, which allows you to have a global mechanism for detecting the locale without requiring any changes to existing routes.","title":"How can I setup the locale without routing parameters?"},{"location":"v1/cookbook/setting-locale-without-routing-parameter/#setup-a-middleware-to-extract-the-locale-from-the-uri","text":"First, we need to setup middleware that extracts the locale param directly from the request URI's path. If if doesn't find one, it sets a default. If it does find one, it uses the value to setup the locale. It also: amends the request with a truncated path (removing the locale segment). adds the locale segment as the base path of the UrlHelper . namespace Application\\I18n; use Locale; use Zend\\Expressive\\Helper\\UrlHelper; class SetLocaleMiddleware { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } public function __invoke($request, $response, callable $next) { $uri = $request->getUri(); $path = $uri->getPath(); if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) { Locale::setDefault('de_DE'); return $next($request, $response); } $locale = $matches['locale']; Locale::setDefault(Locale::canonicalize($locale)); $this->helper->setBasePath($locale); return $next( $request->withUri( $uri->withPath(substr($path, 3)) ), $response ); } } Then you will need a factory for the SetLocaleMiddleware to inject the UrlHelper instance. namespace Application\\I18n; use Interop\\Container\\ContainerInterface; use Zend\\Expressive\\Helper\\UrlHelper; class SetLocaleMiddlewareFactory { public function __invoke(ContainerInterface $container) { return new SetLocaleMiddleware( $container->get(UrlHelper::class) ); } } Afterwards, you need to configure the SetLocaleMiddleware in your /config/autoload/middleware-pipeline.global.php file so that it is executed on every request. return [ 'dependencies' => [ /* ... */ 'factories' => [ Application\\I18n\\SetLocaleMiddleware::class => Application\\I18n\\SetLocaleMiddlewareFactory::class, /* ... */ ], ] 'middleware_pipeline' => [ [ 'middleware' => [ Application\\I18n\\SetLocaleMiddleware::class, /* ... */ ], 'priority' => 1000, ], /* ... */ 'routing' => [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Zend\\Expressive\\Helper\\UrlHelperMiddleware::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], /* ... */ ], ];","title":"Setup a middleware to extract the locale from the URI"},{"location":"v1/cookbook/setting-locale-without-routing-parameter/#url-generation-in-the-view","text":"Since the UrlHelper has the locale set as a base path, you don't need to worry about generating URLs within your view. Just use the helper to generate a URL and it will do the rest. <?php echo $this->url('your-route') ?>","title":"Url generation in the view"},{"location":"v1/cookbook/setting-locale-without-routing-parameter/#redirecting-within-your-middleware","text":"If you want to add the locale parameter when creating URIs within your action middleware, you just need to inject the UrlHelper into your middleware and use it for URL generation: namespace Application\\Action; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\RedirectResponse; use Zend\\Expressive\\Helper\\UrlHelper; class RedirectAction { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } /** * @param ServerRequestInterface $request * @param ResponseInterface $response * @param callable|null $next * * @return RedirectResponse */ public function __invoke( ServerRequestInterface $request, ResponseInterface $response, callable $next = null ) { $routeParams = [ /* ... */ ]; return new RedirectResponse( $this->helper->generate('your-route', $routeParams) ); } } Injecting the UrlHelper into your middleware will also require that the middleware have a factory that manages the injection. As an example, the following would work for the above middleware: namespace Application\\Action; use Interop\\Container\\ContainerInterface; use Zend\\Expressive\\Helper\\UrlHelper; class RedirectActionFactory { public function __invoke(ContainerInterface $container) { return new RedirectAction( $container->get(UrlHelper::class) ); } }","title":"Redirecting within your middleware"},{"location":"v1/cookbook/using-a-base-path/","text":"How can I tell my application about a base path? In some environments, your application may be running in a subdirectory of your web root. For example: var/ |- www/ | |- wordpress/ | |- expressive/ | | |- public/ | | | |- index.php where /var/www is the web root, and your Expressive application is in the expressive/ subdirectory. How can you make your application work correctly in this environment? .htaccess in the application root. If you are using Apache, your first step is to add an .htaccess file to your application root, with directives for rewriting to the public/ directory: RewriteEngine On RewriteRule (.*) ./public/$1 Using other web servers If you are using a web-server other than Apache, and know how to do a similar rewrite, we'd love to know! Please submit ideas/instructions to our issue tracker ! Use middleware to rewrite the path The above step ensures that clients can hit the website. Now we need to ensure that the application can route to middleware! To do this, we will add pipeline middleware to intercept the request, and rewrite the URL accordingly. At the time of writing, we have two suggestions: los/basepath provides the basic mechanics of rewriting the URL, and has a stable release. mtymek/blast-base-url provides the URL rewriting mechanics, as well as utilities for generating URIs that retain the base path, but does not have a stable release yet. los/basepath To use los/basepath , install it via Composer, copy the configuration files to your application, and then edit the configuration. To install and copy the configuration: $ composer require los/basepath $ cp vendor/los/basepath/config/los-basepath.global.php.dist config/autoload/los-basepath.global.php We recommend copying the global configuration to a local configuration file as well; this allows you to have the production settings in your global configuration, and development settings in a local configuration (which is excluded from git by default): $ cp config/autoload/los-basepath.global.php config/autoload/los-basepath.local.php Then edit one or both, to change the los_basepath settings: return [ 'los_basepath' => '<base path here>', /* ... */ ]; The base path should be the portion of the web root leading up to the index.php of your application. In the above example, this would be /expressive . mtymek/blast-base-url To use mtymek/blast-base-url , install it via Composer, and register some configuration. To install it: $ composer require mtymek/blast-base-url To configure it, update the file config/autoload/middleware-pipeline.global.php , with the following contents: return [ 'dependencies' => [ 'factories' => [ Blast\\BaseUrl\\BaseUrlMiddleware::class => Blast\\BaseUrl\\BaseUrlMiddlewareFactory::class, /* ... */ ], /* ... */ ], 'middleware_pipeline' => [ [ 'middleware' => [ Blast\\BaseUrl\\BaseUrlMiddleware::class ], 'priority' => 1000 ], /* ... */ 'routing' => [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Zend\\Expressive\\Helper\\UrlHelperMiddleware::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], /* ... */ ], ]; At this point, the middleware will take care of the rewriting for you. No configuration is necessary, as it does auto-detection of the base path based on the request URI and the operating system path to the application. The primary advantage of mtymek/blast-base-url is in its additional features: it injects Zend\\Expressive\\Helper\\UrlHelper with the base path, allowing you to create relative route-based URLs. it provides a new helper, Blast\\BaseUrl\\BasePathHelper , which allows you to create URLs relative to the base path; this is particularly useful for assets. To enable these features, we'll add some configuration to config/autoload/dependencies.global.php file: return [ 'dependencies' => [ 'invokables' => [ Blast\\BaseUrl\\BasePathHelper::class => Blast\\BaseUrl\\BasePathHelper::class, /* ... */ ], ], ]; Finally, if you're using zend-view, you can register a new \"basePath\" helper in your config/autoload/templates.global.php : return [ /* ... */ 'view_helpers' => [ 'factories' => [ 'basePath' => Blast\\BaseUrl\\BasePathViewHelperFactory::class, /* ... */ ], /* ... */ ], ]; Usage of the BasePath helper is as follows: // where $basePathHelper is an instance of Blast\\BaseUrl\\BasePathHelper // as pulled from your container: echo $basePathHelper('/icons/favicon.ico'); // or, from zend-view's PhpRenderer: echo $this->basePath('/icons/favicon.ico');","title":"Using Expressive from a subdirectory"},{"location":"v1/cookbook/using-a-base-path/#how-can-i-tell-my-application-about-a-base-path","text":"In some environments, your application may be running in a subdirectory of your web root. For example: var/ |- www/ | |- wordpress/ | |- expressive/ | | |- public/ | | | |- index.php where /var/www is the web root, and your Expressive application is in the expressive/ subdirectory. How can you make your application work correctly in this environment?","title":"How can I tell my application about a base path?"},{"location":"v1/cookbook/using-a-base-path/#htaccess-in-the-application-root","text":"If you are using Apache, your first step is to add an .htaccess file to your application root, with directives for rewriting to the public/ directory: RewriteEngine On RewriteRule (.*) ./public/$1","title":".htaccess in the application root."},{"location":"v1/cookbook/using-a-base-path/#use-middleware-to-rewrite-the-path","text":"The above step ensures that clients can hit the website. Now we need to ensure that the application can route to middleware! To do this, we will add pipeline middleware to intercept the request, and rewrite the URL accordingly. At the time of writing, we have two suggestions: los/basepath provides the basic mechanics of rewriting the URL, and has a stable release. mtymek/blast-base-url provides the URL rewriting mechanics, as well as utilities for generating URIs that retain the base path, but does not have a stable release yet.","title":"Use middleware to rewrite the path"},{"location":"v1/cookbook/using-custom-view-helpers/","text":"How do you register custom view helpers when using zend-view? If you've selected zend-view as your preferred template renderer, you may want to define and use custom view helpers. How can you use them? Assuming you've used the Expressive skeleton to start your application, you will already have a factory defined for Zend\\View\\HelperPluginManager , and it will be injected into the PhpRenderer instance used. Since the HelperPluginManager is available, we can configure it. Open the file config/autoload/templates.global.php . In that file, you'll see three top-level keys: return [ 'dependencies' => [ /* ... */ ], 'templates' => [ /* ... */ ], 'view_helpers' => [ /* ... */ ], ]; The last is the one you want. In this, you can define service mappings, including aliases, invokables, factories, and abstract factories to define how helpers are named and created. See the zend-view custom helpers documentation for information on how to populate this configuration.","title":"Registering custom view helpers when using zend-view"},{"location":"v1/cookbook/using-custom-view-helpers/#how-do-you-register-custom-view-helpers-when-using-zend-view","text":"If you've selected zend-view as your preferred template renderer, you may want to define and use custom view helpers. How can you use them? Assuming you've used the Expressive skeleton to start your application, you will already have a factory defined for Zend\\View\\HelperPluginManager , and it will be injected into the PhpRenderer instance used. Since the HelperPluginManager is available, we can configure it. Open the file config/autoload/templates.global.php . In that file, you'll see three top-level keys: return [ 'dependencies' => [ /* ... */ ], 'templates' => [ /* ... */ ], 'view_helpers' => [ /* ... */ ], ]; The last is the one you want. In this, you can define service mappings, including aliases, invokables, factories, and abstract factories to define how helpers are named and created. See the zend-view custom helpers documentation for information on how to populate this configuration.","title":"How do you register custom view helpers when using zend-view?"},{"location":"v1/cookbook/using-routed-middleware-class-as-controller/","text":"Handling multiple routes in a single class Typically, in Expressive, we would define one middleware class per route. For a standard CRUD-style application, however, this leads to multiple related classes: AlbumPageIndex AlbumPageEdit AlbumPageAdd If you are familiar with frameworks that provide controllers capable of handling multiple \"actions\", such as those found in Zend Framework 1 and 2, Symfony, CodeIgniter, CakePHP, and other popular frameworks, you may want to apply a similar pattern when using Expressive. In other words, what if we want to use only one middleware class to facilitate all three of the above? In the following example, we'll use an action routing parameter which our middleware class will use in order to determine which internal method to invoke. Consider the following route configuration: return [ /* ... */ 'routes' => [ /* ... */ [ 'name' => 'album', 'path' => '/album[/{action:add|edit}[/{id}]]', 'middleware' => Album\\Action\\AlbumPage::class, 'allowed_methods' => ['GET'], ], /* ... */ ], ]; The above defines a route that will match any of the following: /album /album/add /album/edit/3 The action attribute can thus be one of add or edit , and we can optionally also receive an id attribute (in the latter example, it would be 3 ). Routing definitions may vary Depending on the router you chose when starting your project, your routing definition may differ. The above example uses the default FastRoute implementation. We might then implement Album\\Action\\AlbumPage as follows: namespace Album\\Action; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Template\\TemplateRendererInterface; class AlbumPage { private $template; public function __construct(TemplateRendererInterface $template) { $this->template = $template; } public function __invoke( ServerRequestInterface $request, ResponseInterface $response, callable $next = null ) { switch ($request->getAttribute('action', 'index')) { case 'index': return $this->indexAction($request, $response, $next); case 'add': return $this->addAction($request, $response, $next); case 'edit': return $this->editAction($request, $response, $next); default: // Invalid; thus, a 404! return $response->withStatus(404); } } public function indexAction( ServerRequestInterface $request, ResponseInterface $response, callable $next = null ) { return new HtmlResponse($this->template->render('album::album-page')); } public function addAction( ServerRequestInterface $request, ResponseInterface $response, callable $next = null ) { return new HtmlResponse($this->template->render('album::album-page-add')); } public function editAction( ServerRequestInterface $request, ResponseInterface $response, callable $next = null ) { $id = $request->getAttribute('id', false); if (! $id) { throw new \\InvalidArgumentException('id parameter must be provided'); } return new HtmlResponse( $this->template->render('album::album-page-edit', ['id' => $id]) ); } } This allows us to have the same dependencies for a set of related actions, and, if desired, even have common internal methods each can utilize. This approach is reasonable, but requires that I create a similar __invoke() implementation every time I want to accomplish a similar workflow. Let's create a generic implementation, via an AbstractPage class: namespace App\\Action; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; abstract class AbstractPage { public function __invoke( ServerRequestInterface $request, ResponseInterface $response, callable $next = null ) { $action = $request->getAttribute('action', 'index') . 'Action'; if (! method_exists($this, $action)) { return $response->withStatus(404); } return $this->$action($request, $response, $next); } } The above abstract class pulls the action attribute on invocation, and concatenates it with the word Action . It then uses this value to determine if a corresponding method exists in the current class, and, if so, calls it with the arguments it received; otherwise, it returns a 404 response. Invoking the error stack Instead of returning a 404 response, you could also invoke $next() with an error: $$$$FENCED_CODE_BLOCK_5e03bde9f3df83.39445504 This will then invoke the first error handler middleware capable of handling the error. Our original AlbumPage implementation could then be modified to extend AbstractPage : namespace Album\\Action; use App\\Action\\AbstractPage; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Template\\TemplateRendererInterface; class AlbumPage extends AbstractPage { private $template; public function __construct(TemplateRendererInterface $template) { $this->template = $template; } public function indexAction( /* ... */ ) { /* ... */ } public function addAction( /* ... */ ) { /* ... */ } public function editAction( /* ... */ ) { /* ... */ } } Or use a trait As an alternative to an abstract class, you could define the __invoke() logic in a trait, which you then compose into your middleware: $$$$FENCED_CODE_BLOCK_5e03bde9f3e0a7.71130730 You would then compose it into a class as follows: $$$$FENCED_CODE_BLOCK_5e03bde9f3e1f0.82912865","title":"Handling multiple routes in a single class"},{"location":"v1/cookbook/using-routed-middleware-class-as-controller/#handling-multiple-routes-in-a-single-class","text":"Typically, in Expressive, we would define one middleware class per route. For a standard CRUD-style application, however, this leads to multiple related classes: AlbumPageIndex AlbumPageEdit AlbumPageAdd If you are familiar with frameworks that provide controllers capable of handling multiple \"actions\", such as those found in Zend Framework 1 and 2, Symfony, CodeIgniter, CakePHP, and other popular frameworks, you may want to apply a similar pattern when using Expressive. In other words, what if we want to use only one middleware class to facilitate all three of the above? In the following example, we'll use an action routing parameter which our middleware class will use in order to determine which internal method to invoke. Consider the following route configuration: return [ /* ... */ 'routes' => [ /* ... */ [ 'name' => 'album', 'path' => '/album[/{action:add|edit}[/{id}]]', 'middleware' => Album\\Action\\AlbumPage::class, 'allowed_methods' => ['GET'], ], /* ... */ ], ]; The above defines a route that will match any of the following: /album /album/add /album/edit/3 The action attribute can thus be one of add or edit , and we can optionally also receive an id attribute (in the latter example, it would be 3 ).","title":"Handling multiple routes in a single class"},{"location":"v1/cookbook/using-zend-form-view-helpers/","text":"How can I use zend-form view helpers? If you've selected zend-view as your preferred template renderer, you'll likely want to use the various view helpers available in other components, such as: zend-form zend-i18n zend-navigation By default, only the view helpers directly available in zend-view are available; how can you add the others? To add the zend-form view helpers create a file config/autoload/zend-form.global.php with the contents: <?php use Zend\\Form\\ConfigProvider; $provider = new ConfigProvider(); return $provider(); and that will essentially do everything needed. If you installed Expressive via the skeleton, the service Zend\\View\\HelperPluginManager is registered for you, and represents the helper plugin manager injected into the PhpRenderer instance. As such, you only need to configure this. The question is: where? You have three options: Replace the HelperPluginManager factory with your own; or Add a delegator factory to or extend the HelperPluginManager service to inject the additional helper configuration; or Add pipeline middleware that composes the HelperPluginManager and configures it. Replacing the HelperPluginManager factory The zend-view integration provides Zend\\Expressive\\ZendView\\HelperPluginManagerFactory , and the Expressive skeleton registers it be default. The simplest solution for adding other helpers is to replace it with your own. In your own factory, you will also configure the plugin manager with the configuration from the zend-form component (or whichever other components you wish to use). namespace Your\\Application; use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\Config; use Zend\\View\\HelperPluginManager; class HelperPluginManagerFactory { public function __invoke(ContainerInterface $container) { $manager = new HelperPluginManager($container); $config = $container->has('config') ? $container->get('config') : []; $config = isset($config['view_helpers']) ? $config['view_helpers'] : []; (new Config($config))->configureServiceManager($manager); return $manager; } } In your config/autoload/templates.global.php file, change the line that reads: Zend\\View\\HelperPluginManager::class => Zend\\Expressive\\ZendView\\HelperPluginManagerFactory::class, to instead read as: Zend\\View\\HelperPluginManager::class => Your\\Application\\HelperPluginManagerFactory::class, This approach will work for any of the various containers supported. Delegator factories/service extension Delegator factories and service extension operate on the same principle: they intercept after the original factory was called, and then operate on the generated instance, either modifying or replacing it. We'll demonstrate this for zend-servicemanager and Pimple; at the time of writing, we're unaware of a mechanism for doing so in Aura.Di. zend-servicemanager You'll first need to create a delegator factory: namespace Your\\Application; use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\Config; use Zend\\ServiceManager\\DelegatorFactoryInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; class FormHelpersDelegatorFactory { /** * zend-servicemanager v3 support */ public function __invoke( ContainerInterface $container, $name, callable $callback, array $options = null ) { $helpers = $callback(); $config = $container->has('config') ? $container->get('config') : []; $config = new Config($config['view_helpers']); $config->configureServiceManager($helpers); return $helpers; } /** * zend-servicemanager v2 support */ public function createDelegatorWithName( ServiceLocatorInterface $container, $name, $requestedName, $callback ) { return $this($container, $name, $callback); } } The above creates an instance of Zend\\ServiceManager\\Config , uses it to configure the already created Zend\\View\\HelperPluginManager instance, and then returns the plugin manager instance. From here, you'll add a delegators configuration key in your config/autoload/templates.global.php file: return [ 'dependencies' => [ 'delegators' => [ Zend\\View\\HelperPluginManager::class => [ Your\\Application\\FormHelpersDelegatorFactory::class, ], ], /* ... */ ], 'templates' => [ /* ... */ ], 'view_helpers' => [ /* ... */ ], ]; Note: delegator factories are keyed by the service they modify, and the value is an array of delegator factories, to allow multiple such factories to be in use. Pimple For Pimple, we don't currently support configuration of service extensions, so you'll need to edit the main container configuration file, config/container.php . Place the following anywhere after the factories and invokables are defined: // The following assumes you've added the following import statements to // the start of the file: // use Zend\\ServiceManager\\Config as ServiceConfig; // use Zend\\View\\HelperPluginManager; $container[HelperPluginManager::class] = $container->extend( HelperPluginManager::class, function ($helpers, $container) { $config = isset($container['config']) ? $container['config'] : []; $config = new ServiceConfig($config['view_helpers']); $config->configureServiceManager($helpers); return $helpers; } ); Pipeline middleware Another option is to use pipeline middleware. This approach will require that the middleware execute on every request, which introduces (very slight) performance overhead. However, it's a portable method that works regardless of the container implementation you choose. First, define the middleware: namespace Your\\Application use Zend\\Form\\View\\HelperConfig as FormHelperConfig; use Zend\\View\\HelperPluginManager; class FormHelpersMiddleware { private $helpers; public function __construct(HelperPluginManager $helpers) { $this->helpers = $helpers; } public function __invoke($request, $response, callable $next) { $config = new FormHelperConfig(); $config->configureServiceManager($this->helpers); return $next($request, $response); } } You'll also need a factory for the middleware, to ensure it receives the HelperPluginManager : namespace Your\\Application use Zend\\View\\HelperPluginManager; class FormHelpersMiddlewareFactory { public function __invoke($container) { return new FormHelpersMiddleware( $container->get(HelperPluginManager::class) ); } } Now, register these in the file config/autoload/middleware-pipeline.global.php : return [ 'dependencies' => [ 'factories' => [ Your\\Application\\FormHelpersMiddleware::class => Your\\Application\\FormHelpersMiddlewareFactory::class /* ... */ ], /* ... */ ], 'middleware_pipeline' => [ ['middleware' => Your\\Application\\FormHelpersMiddleware::class, 'priority' => 1000], /* ... */ 'routing' => [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Zend\\Expressive\\Helper\\UrlHelperMiddleware::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], /* ... */ ], ]; At that point, you're all set! Registering more helpers What if you need to register helpers from multiple components? You can do so using the same technique above. Better yet, do them all at once! If you chose to use delegator factories/service extension, do all helper configuration registrations for all components in the same factory. If you chose to use middleware, do all helper configuration registrations for all components in the same middleware.","title":"Using zend-form view helpers"},{"location":"v1/cookbook/using-zend-form-view-helpers/#how-can-i-use-zend-form-view-helpers","text":"If you've selected zend-view as your preferred template renderer, you'll likely want to use the various view helpers available in other components, such as: zend-form zend-i18n zend-navigation By default, only the view helpers directly available in zend-view are available; how can you add the others? To add the zend-form view helpers create a file config/autoload/zend-form.global.php with the contents: <?php use Zend\\Form\\ConfigProvider; $provider = new ConfigProvider(); return $provider(); and that will essentially do everything needed. If you installed Expressive via the skeleton, the service Zend\\View\\HelperPluginManager is registered for you, and represents the helper plugin manager injected into the PhpRenderer instance. As such, you only need to configure this. The question is: where? You have three options: Replace the HelperPluginManager factory with your own; or Add a delegator factory to or extend the HelperPluginManager service to inject the additional helper configuration; or Add pipeline middleware that composes the HelperPluginManager and configures it.","title":"How can I use zend-form view helpers?"},{"location":"v1/cookbook/using-zend-form-view-helpers/#replacing-the-helperpluginmanager-factory","text":"The zend-view integration provides Zend\\Expressive\\ZendView\\HelperPluginManagerFactory , and the Expressive skeleton registers it be default. The simplest solution for adding other helpers is to replace it with your own. In your own factory, you will also configure the plugin manager with the configuration from the zend-form component (or whichever other components you wish to use). namespace Your\\Application; use Interop\\Container\\ContainerInterface; use Zend\\ServiceManager\\Config; use Zend\\View\\HelperPluginManager; class HelperPluginManagerFactory { public function __invoke(ContainerInterface $container) { $manager = new HelperPluginManager($container); $config = $container->has('config') ? $container->get('config') : []; $config = isset($config['view_helpers']) ? $config['view_helpers'] : []; (new Config($config))->configureServiceManager($manager); return $manager; } } In your config/autoload/templates.global.php file, change the line that reads: Zend\\View\\HelperPluginManager::class => Zend\\Expressive\\ZendView\\HelperPluginManagerFactory::class, to instead read as: Zend\\View\\HelperPluginManager::class => Your\\Application\\HelperPluginManagerFactory::class, This approach will work for any of the various containers supported.","title":"Replacing the HelperPluginManager factory"},{"location":"v1/cookbook/using-zend-form-view-helpers/#delegator-factoriesservice-extension","text":"Delegator factories and service extension operate on the same principle: they intercept after the original factory was called, and then operate on the generated instance, either modifying or replacing it. We'll demonstrate this for zend-servicemanager and Pimple; at the time of writing, we're unaware of a mechanism for doing so in Aura.Di.","title":"Delegator factories/service extension"},{"location":"v1/cookbook/using-zend-form-view-helpers/#pipeline-middleware","text":"Another option is to use pipeline middleware. This approach will require that the middleware execute on every request, which introduces (very slight) performance overhead. However, it's a portable method that works regardless of the container implementation you choose. First, define the middleware: namespace Your\\Application use Zend\\Form\\View\\HelperConfig as FormHelperConfig; use Zend\\View\\HelperPluginManager; class FormHelpersMiddleware { private $helpers; public function __construct(HelperPluginManager $helpers) { $this->helpers = $helpers; } public function __invoke($request, $response, callable $next) { $config = new FormHelperConfig(); $config->configureServiceManager($this->helpers); return $next($request, $response); } } You'll also need a factory for the middleware, to ensure it receives the HelperPluginManager : namespace Your\\Application use Zend\\View\\HelperPluginManager; class FormHelpersMiddlewareFactory { public function __invoke($container) { return new FormHelpersMiddleware( $container->get(HelperPluginManager::class) ); } } Now, register these in the file config/autoload/middleware-pipeline.global.php : return [ 'dependencies' => [ 'factories' => [ Your\\Application\\FormHelpersMiddleware::class => Your\\Application\\FormHelpersMiddlewareFactory::class /* ... */ ], /* ... */ ], 'middleware_pipeline' => [ ['middleware' => Your\\Application\\FormHelpersMiddleware::class, 'priority' => 1000], /* ... */ 'routing' => [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Zend\\Expressive\\Helper\\UrlHelperMiddleware::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], /* ... */ ], ]; At that point, you're all set!","title":"Pipeline middleware"},{"location":"v1/cookbook/using-zend-form-view-helpers/#registering-more-helpers","text":"What if you need to register helpers from multiple components? You can do so using the same technique above. Better yet, do them all at once! If you chose to use delegator factories/service extension, do all helper configuration registrations for all components in the same factory. If you chose to use middleware, do all helper configuration registrations for all components in the same middleware.","title":"Registering more helpers"},{"location":"v1/features/application/","text":"Applications In zend-expressive, you define a Zend\\Expressive\\Application instance and execute it. The Application instance is itself middleware that composes: a router , for dynamically routing requests to middleware. a dependency injection container , for retrieving middleware to dispatch. a final handler , for handling error conditions raised by the application. an emitter , for emitting the response when application execution is complete. You can define the Application instance in several ways: Direct instantiation, which requires providing several dependencies. The AppFactory , which will use some common defaults, but allows injecting alternate container and/or router implementations. Via a dependency injection container; we provide a factory for setting up all aspects of the instance via configuration and other defined services. Regardless of how you setup the instance, there are several methods you will likely interact with at some point or another. Instantiation As noted at the start of this document, we provide several ways to create an Application instance. Constructor If you wish to manually instantiate the Application instance, it has the following constructor: /** * @param Zend\\Expressive\\Router\\RouterInterface $router * @param null|Interop\\Container\\ContainerInterface $container IoC container from which to pull services, if any. * @param null|callable $finalHandler Final handler to use when $out is not * provided on invocation. * @param null|Zend\\Diactoros\\Response\\EmitterInterface $emitter Emitter to use when `run()` is * invoked. */ public function __construct( Zend\\Expressive\\Router\\RouterInterface $router, Interop\\Container\\ContainerInterface $container = null, callable $finalHandler = null, Zend\\Diactoros\\Response\\EmitterInterface $emitter = null ); If no container is provided at instantiation, then all routed and piped middleware must be provided as callables. AppFactory Zend\\Expressive\\AppFactory provides a convenience layer for creating an Application instance; it makes the assumption that you will use defaults in most situations, and likely only change which container and/or router you wish to use. It has the following signature: AppFactory::create( Interop\\Container\\ContainerInterface $container = null, Zend\\Expressive\\Router\\RouterInterface $router = null ); When no container or router are provided, it defaults to: zend-servicemanager for the container. FastRoute for the router. Container factory We also provide a factory that can be consumed by a container-interop dependency injection container; see the container factories documentation for details. Adding routable middleware We discuss routing vs piping elsewhere ; routing is the act of dynamically matching an incoming request against criteria, and it is one of the primary features of zend-expressive. Regardless of which router implementation you use, you can use the following methods to provide routable middleware: route() route() has the following signature: public function route( $pathOrRoute, $middleware = null, array $methods = null, $name = null ) : Zend\\Expressive\\Router\\Route where: $pathOrRoute may be either a string path to match, or a Zend\\Expressive\\Router\\Route instance. $middleware must be present if $pathOrRoute is a string path, and must be: a callable; a service name that resolves to valid middleware in the container; a fully qualified class name of a constructor-less class; an array of any of the above; these will be composed in order into a Zend\\Stratigility\\MiddlewarePipe instance. $methods must be an array of HTTP methods valid for the given path and middleware. If null, it assumes any method is valid. $name is the optional name for the route, and is used when generating a URI from known routes. See the section on route naming for details. This method is typically only used if you want a single middleware to handle multiple HTTP request methods. get(), post(), put(), patch(), delete(), any() Each of the methods get() , post() , put() , patch() , delete() , and any() proxies to route() and has the signature: function ( $pathOrRoute, $middleware = null, $name = null ) : Zend\\Expressive\\Router\\Route Essentially, each calls route() and specifies an array consisting solely of the corresponding HTTP method for the $methods argument. Piping Because zend-expressive builds on zend-stratigility , and, more specifically, its MiddlewarePipe definition, you can also pipe (queue) middleware to the application. This is useful for adding middleware that should execute on each request, defining error handlers, and/or segregating applications by subpath. The signature of pipe() is: public function pipe($pathOrMiddleware, $middleware = null) where: $pathOrMiddleware is either a string URI path (for path segregation), a callable middleware, or the service name for a middleware to fetch from the composed container. $middleware is required if $pathOrMiddleware is a string URI path. It can be one of: a callable; a service name that resolves to valid middleware in the container; a fully qualified class name of a constructor-less class; an array of any of the above; these will be composed in order into a Zend\\Stratigility\\MiddlewarePipe instance. Unlike Zend\\Stratigility\\MiddlewarePipe , Application::pipe() allows fetching middleware by service name . This facility allows lazy-loading of middleware only when it is invoked. Internally, it wraps the call to fetch and dispatch the middleware inside a closure. Additionally, we define a new method, pipeErrorHandler() , with the following signature: public function pipeErrorHandler($pathOrMiddleware, $middleware = null) It acts just like pipe() except when the middleware specified is a service name; in that particular case, when it wraps the middleware in a closure, it uses the error handler signature: function ($error, ServerRequestInterface $request, ResponseInterface $response, callable $next); Read the section on piping vs routing for more information. Registering routing and dispatch middleware Routing is accomplished via a dedicated middleware method, Application::routeMiddleware() ; similarly, dispatching of routed middleware has a corresponding instance middleware method, Application::dispatchMiddleware() . Each can be piped/registered with other middleware platforms if desired. These methods MUST be piped to the application so that the application will route and dispatch routed middleware. This is done using the following methods: $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); See the section on piping to see how you can register non-routed middleware and create layered middleware applications. Retrieving dependencies As noted in the intro, the Application class has several dependencies. Some of these may allow further configuration, or may be useful on their own, and have methods for retrieving them. They include: getContainer() : returns the composed container-interop instance (used to retrieve routed middleware). getEmitter() : returns the composed emitter , typically a Zend\\Expressive\\Emitter\\EmitterStack instance. getFinalHandler(ResponseInterface $response = null) : retrieves the final handler instance. This is middleware with the signature function ($request, $response, $error = null) , and it is invoked when the middleware pipeline queue is depleted and no response has been returned. Executing the application: run() When the application is completely setup, you can execute it with the run() method. The method may be called with no arguments, but has the following signature: public function run( ServerRequestInterface $request = null, ResponseInterface $response = null );","title":"Applications"},{"location":"v1/features/application/#applications","text":"In zend-expressive, you define a Zend\\Expressive\\Application instance and execute it. The Application instance is itself middleware that composes: a router , for dynamically routing requests to middleware. a dependency injection container , for retrieving middleware to dispatch. a final handler , for handling error conditions raised by the application. an emitter , for emitting the response when application execution is complete. You can define the Application instance in several ways: Direct instantiation, which requires providing several dependencies. The AppFactory , which will use some common defaults, but allows injecting alternate container and/or router implementations. Via a dependency injection container; we provide a factory for setting up all aspects of the instance via configuration and other defined services. Regardless of how you setup the instance, there are several methods you will likely interact with at some point or another.","title":"Applications"},{"location":"v1/features/application/#instantiation","text":"As noted at the start of this document, we provide several ways to create an Application instance.","title":"Instantiation"},{"location":"v1/features/application/#adding-routable-middleware","text":"We discuss routing vs piping elsewhere ; routing is the act of dynamically matching an incoming request against criteria, and it is one of the primary features of zend-expressive. Regardless of which router implementation you use, you can use the following methods to provide routable middleware:","title":"Adding routable middleware"},{"location":"v1/features/application/#retrieving-dependencies","text":"As noted in the intro, the Application class has several dependencies. Some of these may allow further configuration, or may be useful on their own, and have methods for retrieving them. They include: getContainer() : returns the composed container-interop instance (used to retrieve routed middleware). getEmitter() : returns the composed emitter , typically a Zend\\Expressive\\Emitter\\EmitterStack instance. getFinalHandler(ResponseInterface $response = null) : retrieves the final handler instance. This is middleware with the signature function ($request, $response, $error = null) , and it is invoked when the middleware pipeline queue is depleted and no response has been returned.","title":"Retrieving dependencies"},{"location":"v1/features/application/#executing-the-application-run","text":"When the application is completely setup, you can execute it with the run() method. The method may be called with no arguments, but has the following signature: public function run( ServerRequestInterface $request = null, ResponseInterface $response = null );","title":"Executing the application: run()"},{"location":"v1/features/emitters/","text":"Emitters To simplify the usage of Expressive, we added the run() method, which handles the incoming request, and emits a response. The latter aspect, emitting the response, is the responsibility of an emitter . An emitter accepts a response instance, and then does something with it, usually sending the response back to a browser. Diactoros defines an EmitterInterface , and \u2014 as of the time we write this \u2014 a single emitter implementation, Zend\\Diactoros\\Response\\SapiEmitter , which sends headers and output using PHP's standard SAPI mechanisms (the header() method and the output buffer). We recognize that there are times when you may want to use alternate emitter implementations; for example, if you use React , the SAPI emitter will likely not work for you. To facilitate alternate emitters, we offer two facilities: First, Application composes an emitter, and you can specify an alternate emitter during instantiation, or via the Zend\\Diactoros\\Response\\EmitterInterface service when using the container factory. Second, we provide Zend\\Expressive\\Emitter\\EmitterStack , which allows you to compose multiple emitter strategies; the first to return a value other than boolean false will cause execution of the stack to short-circuit. Application composes an EmitterStack by default, with an SapiEmitter composed at the bottom of the stack. EmitterStack The EmitterStack is an SplStack extension that implements EmitterInterface . You can add emitters to the stack by pushing them on: $stack->push($emitterInstance); As a stack, execution is in LIFO (last in, first out) order; the first emitter on the stack will be evaluated last.","title":"Emitters"},{"location":"v1/features/emitters/#emitters","text":"To simplify the usage of Expressive, we added the run() method, which handles the incoming request, and emits a response. The latter aspect, emitting the response, is the responsibility of an emitter . An emitter accepts a response instance, and then does something with it, usually sending the response back to a browser. Diactoros defines an EmitterInterface , and \u2014 as of the time we write this \u2014 a single emitter implementation, Zend\\Diactoros\\Response\\SapiEmitter , which sends headers and output using PHP's standard SAPI mechanisms (the header() method and the output buffer). We recognize that there are times when you may want to use alternate emitter implementations; for example, if you use React , the SAPI emitter will likely not work for you. To facilitate alternate emitters, we offer two facilities: First, Application composes an emitter, and you can specify an alternate emitter during instantiation, or via the Zend\\Diactoros\\Response\\EmitterInterface service when using the container factory. Second, we provide Zend\\Expressive\\Emitter\\EmitterStack , which allows you to compose multiple emitter strategies; the first to return a value other than boolean false will cause execution of the stack to short-circuit. Application composes an EmitterStack by default, with an SapiEmitter composed at the bottom of the stack.","title":"Emitters"},{"location":"v1/features/emitters/#emitterstack","text":"The EmitterStack is an SplStack extension that implements EmitterInterface . You can add emitters to the stack by pushing them on: $stack->push($emitterInstance); As a stack, execution is in LIFO (last in, first out) order; the first emitter on the stack will be evaluated last.","title":"EmitterStack"},{"location":"v1/features/error-handling/","text":"Error Handling Expressive provides error handling out of the box, via zend-stratigility's FinalHandler implementation . This pseudo-middleware is executed in the following conditions: If the middleware stack is exhausted, and no middleware has returned a response. If an error has been passed via $next() , but not handled by any error middleware. The FinalHandler essentially tries to recover gracefully. In the case that no error was passed, it does the following: If the response passed to it differs from the response provided at initialization, it will return the response directly; the assumption is that some middleware along the way called $next() with a new response. If the response instances are identical, it checks to see if the body size has changed; if it has, the assumption is that a middleware at some point has written to the response body. At this point, it assumes no middleware was able to handle the request, and creates a 404 response, indicating \"Not Found.\" In the event that an error was passed, it does the following: If $error is not an exception, it will use the response status if it already indicates an error (ie., >= 400 status), or will use a 500 status, and return the response directly with the reason phrase. If $error is an exception, it will use the exception status if it already indicates an error (ie., >= 400 status), or will use a 500 status, and return the response directly with the reason phrase. If the FinalHandler was initialized with an option indicating that it is in development mode, it writes the exception stack trace to the response body. This workflow stays the same throughout zend-expressive. But sometimes, it's just not enough. Templated Errors You'll typically want to provide error messages in your site template. To do so, we provide Zend\\Expressive\\TemplatedErrorHandler . This class is similar to the FinalHandler , but accepts, optionally, a Zend\\Expressive\\Template\\TemplateRendererInterface instance, and template names to use for 404 and general error conditions. This makes it a good choice for use in production. First, of course, you'll need to select a templating system and ensure you have the appropriate dependencies installed; see the templating documentation for information on what we support and how to install supported systems. Once you have selected your templating system, you can setup the templated error handler. use Zend\\Expressive\\Application; use Zend\\Expressive\\Plates\\PlatesRenderer; use Zend\\Expressive\\TemplatedErrorHandler; $plates = new PlatesRenderer(); $plates->addPath(__DIR__ . '/templates/error', 'error'); $finalHandler = new TemplatedErrorHandler($plates, 'error::404', 'error::500'); $app = new Application($router, $container, $finalHandler); The above will use the templates error::404 and error::500 for 404 and general errors, respectively, rendering them using our Plates template adapter. You can also use the TemplatedErrorHandler as a substitute for the FinalHandler , without using templated capabilities, by omitting the TemplateRendererInterface instance when instantiating it. In this case, the response message bodies will be empty, though the response status will reflect the error. See the section titled \"Container Factories and Configuration\", below, for techniques on configuring the TemplatedErrorHandler as your final handler within a container-based application. Whoops whoops is a library for providing a more usable UI around exceptions and PHP errors. We provide integration with this library through Zend\\Express\\WhoopsErrorHandler . This error handler derives from the TemplatedErrorHandler , and uses its features for 404 status and non-exception errors. For exceptions, however, it will return the whoops output. As such, it is a good choice for use in development. To use it, you must first install whoops: $ composer require filp/whoops Then you will need to provide the error handler a whoops runtime instance, as well as a Whoops\\Handler\\PrettyPageHandler instance. You can also optionally provide a TemplateRendererInterface instance and template names, just as you would for a TemplatedErrorHandler . use Whoops\\Handler\\PrettyPageHandler; use Whoops\\Run as Whoops; use Zend\\Expressive\\Application; use Zend\\Expressive\\Plates\\PlatesRenderer; use Zend\\Expressive\\WhoopsErrorHandler; $handler = new PrettyPageHandler(); $whoops = new Whoops; $whoops->writeToOutput(false); $whoops->allowQuit(false); $whoops->pushHandler($handler); $plates = new PlatesRenderer(); $plates->addPath(__DIR__ . '/templates/error', 'error'); $finalHandler = new WhoopsErrorHandler( $whoops, $handler, $plates, 'error::404', 'error::500' ); $app = new Application($router, $container, $finalHandler); // Register Whoops just before running the application, as otherwise it can // swallow bootstrap errors. $whoops->register(); $app->run(); The calls to writeToOutput(false) , allowQuit(false) , and register() must be made to guarantee whoops will interoperate well with zend-expressive. You can add more handlers if desired. Internally, when an exception is discovered, zend-expressive adds some data to the whoops output, primarily around the request information (URI, HTTP request method, route match attributes, etc.). See the next section for techniques on configuring the WhoopsErrorHandler as your final handler within a container-based application. Container Factories and Configuration The above may feel like a bit much when creating your application. As such, we provide several factories that work with container-interop -compatible container implementations to simplify setup. In each case, you should register the selected error handler's factory as the service Zend\\Expressive\\FinalHandler . For the TemplatedErrorHandler , use Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory . For the WhoopsErrorHandler , use Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory .","title":"Error Handling"},{"location":"v1/features/error-handling/#error-handling","text":"Expressive provides error handling out of the box, via zend-stratigility's FinalHandler implementation . This pseudo-middleware is executed in the following conditions: If the middleware stack is exhausted, and no middleware has returned a response. If an error has been passed via $next() , but not handled by any error middleware. The FinalHandler essentially tries to recover gracefully. In the case that no error was passed, it does the following: If the response passed to it differs from the response provided at initialization, it will return the response directly; the assumption is that some middleware along the way called $next() with a new response. If the response instances are identical, it checks to see if the body size has changed; if it has, the assumption is that a middleware at some point has written to the response body. At this point, it assumes no middleware was able to handle the request, and creates a 404 response, indicating \"Not Found.\" In the event that an error was passed, it does the following: If $error is not an exception, it will use the response status if it already indicates an error (ie., >= 400 status), or will use a 500 status, and return the response directly with the reason phrase. If $error is an exception, it will use the exception status if it already indicates an error (ie., >= 400 status), or will use a 500 status, and return the response directly with the reason phrase. If the FinalHandler was initialized with an option indicating that it is in development mode, it writes the exception stack trace to the response body. This workflow stays the same throughout zend-expressive. But sometimes, it's just not enough.","title":"Error Handling"},{"location":"v1/features/error-handling/#templated-errors","text":"You'll typically want to provide error messages in your site template. To do so, we provide Zend\\Expressive\\TemplatedErrorHandler . This class is similar to the FinalHandler , but accepts, optionally, a Zend\\Expressive\\Template\\TemplateRendererInterface instance, and template names to use for 404 and general error conditions. This makes it a good choice for use in production. First, of course, you'll need to select a templating system and ensure you have the appropriate dependencies installed; see the templating documentation for information on what we support and how to install supported systems. Once you have selected your templating system, you can setup the templated error handler. use Zend\\Expressive\\Application; use Zend\\Expressive\\Plates\\PlatesRenderer; use Zend\\Expressive\\TemplatedErrorHandler; $plates = new PlatesRenderer(); $plates->addPath(__DIR__ . '/templates/error', 'error'); $finalHandler = new TemplatedErrorHandler($plates, 'error::404', 'error::500'); $app = new Application($router, $container, $finalHandler); The above will use the templates error::404 and error::500 for 404 and general errors, respectively, rendering them using our Plates template adapter. You can also use the TemplatedErrorHandler as a substitute for the FinalHandler , without using templated capabilities, by omitting the TemplateRendererInterface instance when instantiating it. In this case, the response message bodies will be empty, though the response status will reflect the error. See the section titled \"Container Factories and Configuration\", below, for techniques on configuring the TemplatedErrorHandler as your final handler within a container-based application.","title":"Templated Errors"},{"location":"v1/features/error-handling/#whoops","text":"whoops is a library for providing a more usable UI around exceptions and PHP errors. We provide integration with this library through Zend\\Express\\WhoopsErrorHandler . This error handler derives from the TemplatedErrorHandler , and uses its features for 404 status and non-exception errors. For exceptions, however, it will return the whoops output. As such, it is a good choice for use in development. To use it, you must first install whoops: $ composer require filp/whoops Then you will need to provide the error handler a whoops runtime instance, as well as a Whoops\\Handler\\PrettyPageHandler instance. You can also optionally provide a TemplateRendererInterface instance and template names, just as you would for a TemplatedErrorHandler . use Whoops\\Handler\\PrettyPageHandler; use Whoops\\Run as Whoops; use Zend\\Expressive\\Application; use Zend\\Expressive\\Plates\\PlatesRenderer; use Zend\\Expressive\\WhoopsErrorHandler; $handler = new PrettyPageHandler(); $whoops = new Whoops; $whoops->writeToOutput(false); $whoops->allowQuit(false); $whoops->pushHandler($handler); $plates = new PlatesRenderer(); $plates->addPath(__DIR__ . '/templates/error', 'error'); $finalHandler = new WhoopsErrorHandler( $whoops, $handler, $plates, 'error::404', 'error::500' ); $app = new Application($router, $container, $finalHandler); // Register Whoops just before running the application, as otherwise it can // swallow bootstrap errors. $whoops->register(); $app->run(); The calls to writeToOutput(false) , allowQuit(false) , and register() must be made to guarantee whoops will interoperate well with zend-expressive. You can add more handlers if desired. Internally, when an exception is discovered, zend-expressive adds some data to the whoops output, primarily around the request information (URI, HTTP request method, route match attributes, etc.). See the next section for techniques on configuring the WhoopsErrorHandler as your final handler within a container-based application.","title":"Whoops"},{"location":"v1/features/error-handling/#container-factories-and-configuration","text":"The above may feel like a bit much when creating your application. As such, we provide several factories that work with container-interop -compatible container implementations to simplify setup. In each case, you should register the selected error handler's factory as the service Zend\\Expressive\\FinalHandler . For the TemplatedErrorHandler , use Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory . For the WhoopsErrorHandler , use Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory .","title":"Container Factories and Configuration"},{"location":"v1/features/container/aura-di/","text":"Using Aura.Di Aura.Di provides a serializable dependency injection container with the following features: constructor and setter injection. inheritance of constructor parameter and setter method values from parent classes. inheritance of setter method values from interfaces and traits. lazy-loaded instances, services, includes/requires, and values. instance factories. optional auto-resolution of typehinted constructor parameter values. Installing Aura.Di Aura.Di only implements container-interop as of version 3 (in beta at the time of writing). $ composer require \"aura/di:3.0.*@beta\" Configuration Aura.Di can help you to organize your code better with ContainerConfig classes and two step configuration . In this example, we'll put that in config/services.php : <?php use Aura\\Di\\ContainerBuilder; $containerBuilder = new ContainerBuilder(); // Use the builder to create and configure a container using an array of // ContainerConfig classes. Make sure the classes can be autoloaded! return $containerBuilder->newConfiguredInstance([ 'Application\\Config\\Common', ]); The bare minimum ContainerConfig code needed to make zend-expressive work is: <?php // In src/Config/Common.php: namespace Application\\Config; use Aura\\Di\\Container; use Aura\\Di\\ContainerConfig; use Aura\\Router\\Generator; use Aura\\Router\\RouteCollection; use Aura\\Router\\RouteFactory; use Aura\\Router\\Router; use Zend\\Escaper\\Escaper; use Zend\\Expressive\\Application; use Zend\\Expressive\\Container; use Zend\\Expressive\\Plates\\PlatesRenderer; use Zend\\Expressive\\Router\\AuraRouter; use Zend\\Expressive\\Router\\Route; use Zend\\Expressive\\Router\\RouterInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class Common extends ContainerConfig { public function define(Container $di) { $di->params[RouteCollection::class] = array( 'route_factory' => $di->lazyNew(RouteFactory::class), ); $di->params[Router::class] = array( 'routes' => $di->lazyNew(RouteCollection::class), 'generator' => $di->lazyNew(Generator::class), ); $di->params[AuraRouter::class]['router'] = $di->lazyNew(Router::class); $di->set(RouterInterface::class, $di->lazyNew(AuraRouter::class)); $di->set(Container\\ApplicationFactory::class, $di->lazyNew(Container\\ApplicationFactory::class)); $di->set(Application::class, $di->lazyGetCall(Container\\ApplicationFactory::class, '__invoke', $di)); // Templating // In most cases, you can instantiate the template renderer you want to use // without using a factory: $di->set(TemplateRendererInterface::class, $di->lazyNew(PlatesRenderer::class)); // These next two can be added in any environment; they won't be used unless // you add the WhoopsErrorHandler as the FinalHandler implementation: $di->set(Container\\WhoopsFactory::class, $di->lazyNew(Container\\WhoopsFactory::class)); $di->set('Zend\\Expressive\\Whoops', $di->lazyGetCall(Container\\WhoopsFactory::class, '__invoke', $di)); $di->set(Container\\WhoopsPageHandlerFactory::class, $di->lazyNew(Container\\WhoopsPageHandlerFactory::class)); $di->set('Zend\\Expressive\\WhoopsPageHandler', $di->lazyGetCall(Container\\WhoopsPageHandlerFactory::class, '__invoke', $di)); // Error Handling // If in development: $di->set(Container\\WhoopsErrorHandlerFactory::class, $di->lazyNew(Container\\WhoopsErrorHandlerFactory::class)); $di->set('Zend\\Expressive\\FinalHandler', $di->lazyGetCall(Container\\WhoopsErrorHandlerFactory::class, '__invoke', $di)); // If in production: // $di->set('Zend\\Expressive\\FinalHandler', $di->lazyGetCall(Container\\TemplatedErrorHandlerFactory::class, '__invoke', $di)); } public function modify(Container $di) { /* $router = $di->get(RouterInterface::class); $router->addRoute(new Route('/hello/{name}', function ($request, $response, $next) { $escaper = new Escaper(); $name = $request->getAttribute('name', 'World'); $response->getBody()->write('Hello ' . $escaper->escapeHtml($name)); return $response; }, Route::HTTP_METHOD_ANY, 'hello')); */ } } Your bootstrap (typically public/index.php ) will then look like this: chdir(dirname(__DIR__)); require 'vendor/autoload.php'; $container = require 'config/services.php'; $app = $container->get('Zend\\Expressive\\Application'); $app->run();","title":"Using Aura.Di"},{"location":"v1/features/container/aura-di/#using-auradi","text":"Aura.Di provides a serializable dependency injection container with the following features: constructor and setter injection. inheritance of constructor parameter and setter method values from parent classes. inheritance of setter method values from interfaces and traits. lazy-loaded instances, services, includes/requires, and values. instance factories. optional auto-resolution of typehinted constructor parameter values.","title":"Using Aura.Di"},{"location":"v1/features/container/aura-di/#installing-auradi","text":"Aura.Di only implements container-interop as of version 3 (in beta at the time of writing). $ composer require \"aura/di:3.0.*@beta\"","title":"Installing Aura.Di"},{"location":"v1/features/container/aura-di/#configuration","text":"Aura.Di can help you to organize your code better with ContainerConfig classes and two step configuration . In this example, we'll put that in config/services.php : <?php use Aura\\Di\\ContainerBuilder; $containerBuilder = new ContainerBuilder(); // Use the builder to create and configure a container using an array of // ContainerConfig classes. Make sure the classes can be autoloaded! return $containerBuilder->newConfiguredInstance([ 'Application\\Config\\Common', ]); The bare minimum ContainerConfig code needed to make zend-expressive work is: <?php // In src/Config/Common.php: namespace Application\\Config; use Aura\\Di\\Container; use Aura\\Di\\ContainerConfig; use Aura\\Router\\Generator; use Aura\\Router\\RouteCollection; use Aura\\Router\\RouteFactory; use Aura\\Router\\Router; use Zend\\Escaper\\Escaper; use Zend\\Expressive\\Application; use Zend\\Expressive\\Container; use Zend\\Expressive\\Plates\\PlatesRenderer; use Zend\\Expressive\\Router\\AuraRouter; use Zend\\Expressive\\Router\\Route; use Zend\\Expressive\\Router\\RouterInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class Common extends ContainerConfig { public function define(Container $di) { $di->params[RouteCollection::class] = array( 'route_factory' => $di->lazyNew(RouteFactory::class), ); $di->params[Router::class] = array( 'routes' => $di->lazyNew(RouteCollection::class), 'generator' => $di->lazyNew(Generator::class), ); $di->params[AuraRouter::class]['router'] = $di->lazyNew(Router::class); $di->set(RouterInterface::class, $di->lazyNew(AuraRouter::class)); $di->set(Container\\ApplicationFactory::class, $di->lazyNew(Container\\ApplicationFactory::class)); $di->set(Application::class, $di->lazyGetCall(Container\\ApplicationFactory::class, '__invoke', $di)); // Templating // In most cases, you can instantiate the template renderer you want to use // without using a factory: $di->set(TemplateRendererInterface::class, $di->lazyNew(PlatesRenderer::class)); // These next two can be added in any environment; they won't be used unless // you add the WhoopsErrorHandler as the FinalHandler implementation: $di->set(Container\\WhoopsFactory::class, $di->lazyNew(Container\\WhoopsFactory::class)); $di->set('Zend\\Expressive\\Whoops', $di->lazyGetCall(Container\\WhoopsFactory::class, '__invoke', $di)); $di->set(Container\\WhoopsPageHandlerFactory::class, $di->lazyNew(Container\\WhoopsPageHandlerFactory::class)); $di->set('Zend\\Expressive\\WhoopsPageHandler', $di->lazyGetCall(Container\\WhoopsPageHandlerFactory::class, '__invoke', $di)); // Error Handling // If in development: $di->set(Container\\WhoopsErrorHandlerFactory::class, $di->lazyNew(Container\\WhoopsErrorHandlerFactory::class)); $di->set('Zend\\Expressive\\FinalHandler', $di->lazyGetCall(Container\\WhoopsErrorHandlerFactory::class, '__invoke', $di)); // If in production: // $di->set('Zend\\Expressive\\FinalHandler', $di->lazyGetCall(Container\\TemplatedErrorHandlerFactory::class, '__invoke', $di)); } public function modify(Container $di) { /* $router = $di->get(RouterInterface::class); $router->addRoute(new Route('/hello/{name}', function ($request, $response, $next) { $escaper = new Escaper(); $name = $request->getAttribute('name', 'World'); $response->getBody()->write('Hello ' . $escaper->escapeHtml($name)); return $response; }, Route::HTTP_METHOD_ANY, 'hello')); */ } } Your bootstrap (typically public/index.php ) will then look like this: chdir(dirname(__DIR__)); require 'vendor/autoload.php'; $container = require 'config/services.php'; $app = $container->get('Zend\\Expressive\\Application'); $app->run();","title":"Configuration"},{"location":"v1/features/container/factories/","text":"Provided Factories Expressive provides several factories compatible with container-interop to facilitate setting up common dependencies. The following is a list of provided containers, what they will create, the suggested service name, and any additional dependencies they may require. All factories, unless noted otherwise, are in the Zend\\Expressive\\Container namespace, and define an __invoke() method that accepts an Interop\\Container\\ContainerInterface instance as the sole argument. ApplicationFactory Provides : Zend\\Expressive\\Application Suggested Name : Zend\\Expressive\\Application Requires : no additional services are required. Optional : Zend\\Expressive\\Router\\RouterInterface . When provided, the service will be used to construct the Application instance; otherwise, an FastRoute router implementation will be used. Zend\\Expressive\\FinalHandler . This is a meta-service, as the only concrete type required is a callable that can be used as a final middleware in the case that the stack is exhausted before execution ends. By default, an instance of Zend\\Stratigility\\FinalHandler will be used. Zend\\Diactoros\\Response\\EmitterInterface . If none is provided, an instance of Zend\\Expressive\\Emitter\\EmitterStack composing a Zend\\Diactoros\\Response\\SapiEmitter instance will be used. config , an array or ArrayAccess instance. This will be used to seed the application instance with pre/post pipeline middleware and/or routed middleware (see more below). Additionally, the container instance itself is injected into the Application instance. When the config service is present, the factory can utilize several keys in order to seed the Application instance: middleware_pipeline can be used to seed the middleware pipeline: php 'middleware_pipeline' => [ // An array of middleware to register. [ /* ... */ ], Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, [ /* ... */ ], ], Each item of the array, other than the entries for routing and dispatch middleware, must be an array itself, with the following structure: php [ // required: 'middleware' => 'Name of middleware service, or a callable', // optional: 'path' => '/path/to/match', 'error' => true, 'priority' => 1, // Integer ], The middleware key itself is the middleware to execute, and must be a callable or the name of another defined service. If the path key is present, that key will be used to segregate the middleware to a specific matched path (in other words, it will not execute if the path is not matched). If the error key is present and boolean true , then the middleware will be registered as error middleware. (This is necessary due to the fact that the factory defines a callable wrapper around middleware to enable lazy-loading of middleware.) The priority defaults to 1, and follows the semantics of SplPriorityQueue : higher integer values indicate higher priority (will execute earlier), while lower/negative integer values indicate lower priority (will execute last). Default priority is 1; use granular priority values to specify the order in which middleware should be piped to the application. You can specify keys for each middleware specification. These will be ignored by the factory, but can be useful when merging several configurations into one for the application. routes is used to define routed middleware. The value must be an array, consisting of arrays defining each middleware: php 'routes' => [ [ 'path' => '/path/to/match', 'middleware' => 'Middleware Service Name or Callable', 'allowed_methods' => [ 'GET', 'POST', 'PATCH' ], 'options' => [ 'stuff' => 'to', 'pass' => 'to', 'the' => 'underlying router', ], ], // etc. ], Each route requires : - `path`: the path to match. Format will be based on the router you choose for your project. - `middleware`: a callable or a service name for the middleware to execute when the route matches. Optionally, the route definition may provide: - `allowed_methods`: an array of allowed HTTP methods. If not provided, the application assumes any method is allowed. - `name`: if not provided, the path will be used as the route name (and, if specific HTTP methods are allowed, a list of those). - `options`: a key/value set of additional options to pass to the underlying router implementation for the given route. (Typical use cases include passing constraints or default values.) TemplatedErrorHandlerFactory Provides : Zend\\Expressive\\TemplatedErrorHandler Suggested Name : Zend\\Expressive\\FinalHandler Requires : no additional services are required. Optional : Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the error handler will not use templated responses. config , an array or ArrayAccess instance. This will be used to seed the TemplatedErrorHandler instance with template names to use for errors (see more below). When the config service is present, the factory can utilize the zend-expressive top-level key, with the error_handler second-level key, to seed the Templated instance: 'zend-expressive' => [ 'error_handler' => [ 'template_404' => 'name of 404 template', 'template_error' => 'name of error template', ], ], WhoopsErrorHandlerFactory Provides : Zend\\Expressive\\TemplatedErrorHandler Suggested Name : Zend\\Expressive\\FinalHandler Requires : Zend\\Expressive\\Whoops , which should provide a Whoops\\Run instance. Zend\\Expressive\\WhoopsPageHandler , which should provide a Whoops\\Handler\\PrettyPageHandler instance. Optional : Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the error handler will not use templated responses. config , an array or ArrayAccess instance. This will be used to seed the instance with template names to use for errors (see more below). This factory uses config in the same way as the TemplatedErrorHandlerFactory . WhoopsFactory Provides : Whoops\\Run Suggested Name : Zend\\Expressive\\Whoops Requires : Zend\\Expressive\\WhoopsPageHandler Optional : config , an array or ArrayAccess instance. This will be used to seed additional page handlers, specifically the JsonResponseHandler (see more below). This factory creates and configures a Whoops\\Run instance so that it will work properly with Zend\\Expressive\\Application ; this includes disabling immediate write-to-output, disabling immediate quit, etc. The PrettyPageHandler returned for the Zend\\Expressive\\WhoopsPageHandler service will be injected. It consumes the following config structure: 'whoops' => [ 'json_exceptions' => [ 'display' => true, 'show_trace' => true, 'ajax_only' => true, ], ], If no whoops top-level key is present in the configuration, a default instance with no JsonResponseHandler composed will be created. WhoopsPageHandlerFactory Provides : Whoops\\Handler\\PrettyPageHandler Suggested Name : Zend\\Expressive\\WhoopsPageHandler Optional : config , an array or ArrayAccess instance. This will be used to further configure the PrettyPageHandler instance, specifically with editor configuration (for linking files such that they open in the configured editor). It consumes the following config structure: 'whoops' => [ 'editor' => 'editor name, editor service name, or callable', ], The editor value must be a known editor name (see the Whoops documentation for pre-configured editor types), a callable, or a service name to use. PlatesRendererFactory Provides : Zend\\Expressive\\Plates\\PlatesRenderer FactoryName : Zend\\Expressive\\Plates\\PlatesRendererFactory Suggested Name : Zend\\Expressive\\Template\\TemplateRendererInterface Requires : no additional services are required. Optional : config , an array or ArrayAccess instance. This will be used to further configure the Plates instance, specifically with the filename extension to use, and paths to inject. It consumes the following config structure: 'templates' => [ 'extension' => 'file extension used by templates; defaults to html', 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ] One note: Due to a limitation in the Plates engine, you can only map one path per namespace when using Plates. TwigRendererFactory Provides : Zend\\Expressive\\Twig\\TwigRenderer FactoryName : Zend\\Expressive\\Twig\\TwigRendererFactory Suggested Name : Zend\\Expressive\\Template\\TemplateRendererInterface Requires : no additional services are required. Optional : Zend\\Expressive\\Router\\RouterInterface ; if found, it will be used to seed a Zend\\Expressive\\Twig\\TwigExtension instance for purposes of rendering application URLs. config , an array or ArrayAccess instance. This will be used to further configure the Twig instance, specifically with the filename extension, paths to assets (and default asset version to use), and template paths to inject. It consumes the following config structure: 'debug' => boolean, 'templates' => [ 'cache_dir' => 'path to cached templates', 'assets_url' => 'base URL for assets', 'assets_version' => 'base version for assets', 'extension' => 'file extension used by templates; defaults to html.twig', 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ] When debug is true, it disables caching, enables debug mode, enables strict variables, and enables auto reloading. The assets_* values are used to seed the TwigExtension instance (assuming the router was found). ZendViewRendererFactory Provides : Zend\\Expressive\\ZendView\\ZendViewRenderer FactoryName : Zend\\Expressive\\ZendView\\ZendViewRendererFactory Suggested Name : Zend\\Expressive\\Template\\TemplateRendererInterface Requires : no additional services are required. Zend\\Expressive\\Router\\RouterInterface , in order to inject the custom url helper implementation. Optional : config , an array or ArrayAccess instance. This will be used to further configure the ZendView instance, specifically with the layout template name, entries for a TemplateMapResolver , and and template paths to inject. Zend\\View\\HelperPluginManager ; if present, will be used to inject the PhpRenderer instance. It consumes the following config structure: 'templates' => [ 'layout' => 'name of layout view to use, if any', 'map' => [ // template => filename pairs ], 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ] When creating the PhpRenderer instance, it will inject it with a Zend\\View\\HelperPluginManager instance (either pulled from the container, or instantiated directly). It injects the helper plugin manager with custom url and serverurl helpers, Zend\\Expressive\\ZendView\\UrlHelper and Zend\\Expressive\\ZendView\\ServerUrlHelper , respetively.","title":"Container Factories"},{"location":"v1/features/container/factories/#provided-factories","text":"Expressive provides several factories compatible with container-interop to facilitate setting up common dependencies. The following is a list of provided containers, what they will create, the suggested service name, and any additional dependencies they may require. All factories, unless noted otherwise, are in the Zend\\Expressive\\Container namespace, and define an __invoke() method that accepts an Interop\\Container\\ContainerInterface instance as the sole argument.","title":"Provided Factories"},{"location":"v1/features/container/factories/#applicationfactory","text":"Provides : Zend\\Expressive\\Application Suggested Name : Zend\\Expressive\\Application Requires : no additional services are required. Optional : Zend\\Expressive\\Router\\RouterInterface . When provided, the service will be used to construct the Application instance; otherwise, an FastRoute router implementation will be used. Zend\\Expressive\\FinalHandler . This is a meta-service, as the only concrete type required is a callable that can be used as a final middleware in the case that the stack is exhausted before execution ends. By default, an instance of Zend\\Stratigility\\FinalHandler will be used. Zend\\Diactoros\\Response\\EmitterInterface . If none is provided, an instance of Zend\\Expressive\\Emitter\\EmitterStack composing a Zend\\Diactoros\\Response\\SapiEmitter instance will be used. config , an array or ArrayAccess instance. This will be used to seed the application instance with pre/post pipeline middleware and/or routed middleware (see more below). Additionally, the container instance itself is injected into the Application instance. When the config service is present, the factory can utilize several keys in order to seed the Application instance: middleware_pipeline can be used to seed the middleware pipeline: php 'middleware_pipeline' => [ // An array of middleware to register. [ /* ... */ ], Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, [ /* ... */ ], ], Each item of the array, other than the entries for routing and dispatch middleware, must be an array itself, with the following structure: php [ // required: 'middleware' => 'Name of middleware service, or a callable', // optional: 'path' => '/path/to/match', 'error' => true, 'priority' => 1, // Integer ], The middleware key itself is the middleware to execute, and must be a callable or the name of another defined service. If the path key is present, that key will be used to segregate the middleware to a specific matched path (in other words, it will not execute if the path is not matched). If the error key is present and boolean true , then the middleware will be registered as error middleware. (This is necessary due to the fact that the factory defines a callable wrapper around middleware to enable lazy-loading of middleware.) The priority defaults to 1, and follows the semantics of SplPriorityQueue : higher integer values indicate higher priority (will execute earlier), while lower/negative integer values indicate lower priority (will execute last). Default priority is 1; use granular priority values to specify the order in which middleware should be piped to the application. You can specify keys for each middleware specification. These will be ignored by the factory, but can be useful when merging several configurations into one for the application. routes is used to define routed middleware. The value must be an array, consisting of arrays defining each middleware: php 'routes' => [ [ 'path' => '/path/to/match', 'middleware' => 'Middleware Service Name or Callable', 'allowed_methods' => [ 'GET', 'POST', 'PATCH' ], 'options' => [ 'stuff' => 'to', 'pass' => 'to', 'the' => 'underlying router', ], ], // etc. ], Each route requires : - `path`: the path to match. Format will be based on the router you choose for your project. - `middleware`: a callable or a service name for the middleware to execute when the route matches. Optionally, the route definition may provide: - `allowed_methods`: an array of allowed HTTP methods. If not provided, the application assumes any method is allowed. - `name`: if not provided, the path will be used as the route name (and, if specific HTTP methods are allowed, a list of those). - `options`: a key/value set of additional options to pass to the underlying router implementation for the given route. (Typical use cases include passing constraints or default values.)","title":"ApplicationFactory"},{"location":"v1/features/container/factories/#templatederrorhandlerfactory","text":"Provides : Zend\\Expressive\\TemplatedErrorHandler Suggested Name : Zend\\Expressive\\FinalHandler Requires : no additional services are required. Optional : Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the error handler will not use templated responses. config , an array or ArrayAccess instance. This will be used to seed the TemplatedErrorHandler instance with template names to use for errors (see more below). When the config service is present, the factory can utilize the zend-expressive top-level key, with the error_handler second-level key, to seed the Templated instance: 'zend-expressive' => [ 'error_handler' => [ 'template_404' => 'name of 404 template', 'template_error' => 'name of error template', ], ],","title":"TemplatedErrorHandlerFactory"},{"location":"v1/features/container/factories/#whoopserrorhandlerfactory","text":"Provides : Zend\\Expressive\\TemplatedErrorHandler Suggested Name : Zend\\Expressive\\FinalHandler Requires : Zend\\Expressive\\Whoops , which should provide a Whoops\\Run instance. Zend\\Expressive\\WhoopsPageHandler , which should provide a Whoops\\Handler\\PrettyPageHandler instance. Optional : Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the error handler will not use templated responses. config , an array or ArrayAccess instance. This will be used to seed the instance with template names to use for errors (see more below). This factory uses config in the same way as the TemplatedErrorHandlerFactory .","title":"WhoopsErrorHandlerFactory"},{"location":"v1/features/container/factories/#whoopsfactory","text":"Provides : Whoops\\Run Suggested Name : Zend\\Expressive\\Whoops Requires : Zend\\Expressive\\WhoopsPageHandler Optional : config , an array or ArrayAccess instance. This will be used to seed additional page handlers, specifically the JsonResponseHandler (see more below). This factory creates and configures a Whoops\\Run instance so that it will work properly with Zend\\Expressive\\Application ; this includes disabling immediate write-to-output, disabling immediate quit, etc. The PrettyPageHandler returned for the Zend\\Expressive\\WhoopsPageHandler service will be injected. It consumes the following config structure: 'whoops' => [ 'json_exceptions' => [ 'display' => true, 'show_trace' => true, 'ajax_only' => true, ], ], If no whoops top-level key is present in the configuration, a default instance with no JsonResponseHandler composed will be created.","title":"WhoopsFactory"},{"location":"v1/features/container/factories/#whoopspagehandlerfactory","text":"Provides : Whoops\\Handler\\PrettyPageHandler Suggested Name : Zend\\Expressive\\WhoopsPageHandler Optional : config , an array or ArrayAccess instance. This will be used to further configure the PrettyPageHandler instance, specifically with editor configuration (for linking files such that they open in the configured editor). It consumes the following config structure: 'whoops' => [ 'editor' => 'editor name, editor service name, or callable', ], The editor value must be a known editor name (see the Whoops documentation for pre-configured editor types), a callable, or a service name to use.","title":"WhoopsPageHandlerFactory"},{"location":"v1/features/container/factories/#platesrendererfactory","text":"Provides : Zend\\Expressive\\Plates\\PlatesRenderer FactoryName : Zend\\Expressive\\Plates\\PlatesRendererFactory Suggested Name : Zend\\Expressive\\Template\\TemplateRendererInterface Requires : no additional services are required. Optional : config , an array or ArrayAccess instance. This will be used to further configure the Plates instance, specifically with the filename extension to use, and paths to inject. It consumes the following config structure: 'templates' => [ 'extension' => 'file extension used by templates; defaults to html', 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ] One note: Due to a limitation in the Plates engine, you can only map one path per namespace when using Plates.","title":"PlatesRendererFactory"},{"location":"v1/features/container/factories/#twigrendererfactory","text":"Provides : Zend\\Expressive\\Twig\\TwigRenderer FactoryName : Zend\\Expressive\\Twig\\TwigRendererFactory Suggested Name : Zend\\Expressive\\Template\\TemplateRendererInterface Requires : no additional services are required. Optional : Zend\\Expressive\\Router\\RouterInterface ; if found, it will be used to seed a Zend\\Expressive\\Twig\\TwigExtension instance for purposes of rendering application URLs. config , an array or ArrayAccess instance. This will be used to further configure the Twig instance, specifically with the filename extension, paths to assets (and default asset version to use), and template paths to inject. It consumes the following config structure: 'debug' => boolean, 'templates' => [ 'cache_dir' => 'path to cached templates', 'assets_url' => 'base URL for assets', 'assets_version' => 'base version for assets', 'extension' => 'file extension used by templates; defaults to html.twig', 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ] When debug is true, it disables caching, enables debug mode, enables strict variables, and enables auto reloading. The assets_* values are used to seed the TwigExtension instance (assuming the router was found).","title":"TwigRendererFactory"},{"location":"v1/features/container/factories/#zendviewrendererfactory","text":"Provides : Zend\\Expressive\\ZendView\\ZendViewRenderer FactoryName : Zend\\Expressive\\ZendView\\ZendViewRendererFactory Suggested Name : Zend\\Expressive\\Template\\TemplateRendererInterface Requires : no additional services are required. Zend\\Expressive\\Router\\RouterInterface , in order to inject the custom url helper implementation. Optional : config , an array or ArrayAccess instance. This will be used to further configure the ZendView instance, specifically with the layout template name, entries for a TemplateMapResolver , and and template paths to inject. Zend\\View\\HelperPluginManager ; if present, will be used to inject the PhpRenderer instance. It consumes the following config structure: 'templates' => [ 'layout' => 'name of layout view to use, if any', 'map' => [ // template => filename pairs ], 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ] When creating the PhpRenderer instance, it will inject it with a Zend\\View\\HelperPluginManager instance (either pulled from the container, or instantiated directly). It injects the helper plugin manager with custom url and serverurl helpers, Zend\\Expressive\\ZendView\\UrlHelper and Zend\\Expressive\\ZendView\\ServerUrlHelper , respetively.","title":"ZendViewRendererFactory"},{"location":"v1/features/container/intro/","text":"Containers Expressive promotes and advocates the usage of Dependency Injection / Inversion of Control (also referred to as DI \u2014 or DIC \u2014 and IoC, respectively) containers when writing your applications. These should be used for the following: Defining application dependencies: routers, template engines, error handlers, even the Application instance itself. Defining middleware and related dependencies. The Application instance itself stores a container, from which it fetches middleware when ready to dispatch it; this encourages the idea of defining middleware-specific dependencies, and factories for ensuring they are injected. To facilitate this and allow you as a developer to choose the container you prefer, zend-expressive typehints against container-interop , and throughout this manual, we attempt to show using a variety of containers in examples. At this time, we document support for the following specific containers: zend-servicemanager pimple-interop aura.di Service Names We recommend using fully-qualified class names whenever possible as service names, with one exception: in cases where a service provides an implementation of an interface used for typehints, use the interface name. Following these practices encourages the following: Consumers have a reasonable idea of what the service should return. Using interface names as service names promotes re-use and substitution. In a few cases, we define \"meta\" names. These are cases where there is no clear typehint to follow (e.g., most middleware only uses callable as a typehint, or where we want to imply specific configuration is necessary (e.g., Whoops requires specific configuration to work correctly with Expressive, and thus we do not want a generic service name for it). We try to keep these to a minimum, however.","title":"Introduction"},{"location":"v1/features/container/intro/#containers","text":"Expressive promotes and advocates the usage of Dependency Injection / Inversion of Control (also referred to as DI \u2014 or DIC \u2014 and IoC, respectively) containers when writing your applications. These should be used for the following: Defining application dependencies: routers, template engines, error handlers, even the Application instance itself. Defining middleware and related dependencies. The Application instance itself stores a container, from which it fetches middleware when ready to dispatch it; this encourages the idea of defining middleware-specific dependencies, and factories for ensuring they are injected. To facilitate this and allow you as a developer to choose the container you prefer, zend-expressive typehints against container-interop , and throughout this manual, we attempt to show using a variety of containers in examples. At this time, we document support for the following specific containers: zend-servicemanager pimple-interop aura.di","title":"Containers"},{"location":"v1/features/container/pimple/","text":"Using Pimple Pimple is a widely used code-driven dependency injection container provided as a standalone component by SensioLabs. It features: combined parameter and service storage. ability to define factories for specific classes. lazy-loading via factories. Pimple only supports programmatic creation at this time. Installing Pimple Pimple does not currently (as of v3) implement container-interop ; as such, you need to install the xtreamwayz/pimple-container-interop project, which provides a container-interop wrapper around Pimple v3: $ composer require xtreamwayz/pimple-container-interop Configuring Pimple To configure Pimple, instantiate it, and then add the factories desired. We recommend doing this in a dedicated script that returns the Pimple instance; in this example, we'll have that in config/services.php . use Xtreamwayz\\Pimple\\Container as Pimple; use Zend\\Expressive\\Container; use Zend\\Expressive\\Plates\\PlatesRenderer; use Zend\\Expressive\\Router; use Zend\\Expressive\\Template\\TemplateRendererInterface; $container = new Pimple(); // Application and configuration $container['config'] = include 'config/config.php'; $container['Zend\\Expressive\\Application'] = new Container\\ApplicationFactory; // Routing // In most cases, you can instantiate the router you want to use without using a // factory: $container['Zend\\Expressive\\Router\\RouterInterface'] = function ($container) { return new Router\\Aura(); }; // Templating // In most cases, you can instantiate the template renderer you want to use // without using a factory: $container[TemplateRendererInterface::class] = function ($container) { return new PlatesRenderer(); }; // These next two can be added in any environment; they won't be used unless // you add the WhoopsErrorHandler as the FinalHandler implementation: $container['Zend\\Expressive\\Whoops'] = new Container\\WhoopsFactory(); $container['Zend\\Expressive\\WhoopsPageHandler'] = new Container\\WhoopsPageHandlerFactory(); // Error Handling // If in development: $container['Zend\\Expressive\\FinalHandler'] = new Container\\WhoopsErrorHandlerFactory(); // If in production: $container['Zend\\Expressive\\FinalHandler'] = new Container\\TemplatedErrorHandlerFactory(); return $container; Your bootstrap (typically public/index.php ) will then look like this: chdir(dirname(__DIR__)); $container = require 'config/services.php'; $app = $container->get('Zend\\Expressive\\Application'); $app->run(); Environments In the example above, we provide two alternate definitions for the service Zend\\Expressive\\FinalHandler , one for development and one for production. You will need to add logic to your file to determine which definition to provide; this could be accomplished via an environment variable.","title":"Using Pimple"},{"location":"v1/features/container/pimple/#using-pimple","text":"Pimple is a widely used code-driven dependency injection container provided as a standalone component by SensioLabs. It features: combined parameter and service storage. ability to define factories for specific classes. lazy-loading via factories. Pimple only supports programmatic creation at this time.","title":"Using Pimple"},{"location":"v1/features/container/pimple/#installing-pimple","text":"Pimple does not currently (as of v3) implement container-interop ; as such, you need to install the xtreamwayz/pimple-container-interop project, which provides a container-interop wrapper around Pimple v3: $ composer require xtreamwayz/pimple-container-interop","title":"Installing Pimple"},{"location":"v1/features/container/pimple/#configuring-pimple","text":"To configure Pimple, instantiate it, and then add the factories desired. We recommend doing this in a dedicated script that returns the Pimple instance; in this example, we'll have that in config/services.php . use Xtreamwayz\\Pimple\\Container as Pimple; use Zend\\Expressive\\Container; use Zend\\Expressive\\Plates\\PlatesRenderer; use Zend\\Expressive\\Router; use Zend\\Expressive\\Template\\TemplateRendererInterface; $container = new Pimple(); // Application and configuration $container['config'] = include 'config/config.php'; $container['Zend\\Expressive\\Application'] = new Container\\ApplicationFactory; // Routing // In most cases, you can instantiate the router you want to use without using a // factory: $container['Zend\\Expressive\\Router\\RouterInterface'] = function ($container) { return new Router\\Aura(); }; // Templating // In most cases, you can instantiate the template renderer you want to use // without using a factory: $container[TemplateRendererInterface::class] = function ($container) { return new PlatesRenderer(); }; // These next two can be added in any environment; they won't be used unless // you add the WhoopsErrorHandler as the FinalHandler implementation: $container['Zend\\Expressive\\Whoops'] = new Container\\WhoopsFactory(); $container['Zend\\Expressive\\WhoopsPageHandler'] = new Container\\WhoopsPageHandlerFactory(); // Error Handling // If in development: $container['Zend\\Expressive\\FinalHandler'] = new Container\\WhoopsErrorHandlerFactory(); // If in production: $container['Zend\\Expressive\\FinalHandler'] = new Container\\TemplatedErrorHandlerFactory(); return $container; Your bootstrap (typically public/index.php ) will then look like this: chdir(dirname(__DIR__)); $container = require 'config/services.php'; $app = $container->get('Zend\\Expressive\\Application'); $app->run();","title":"Configuring Pimple"},{"location":"v1/features/container/zend-servicemanager/","text":"Using zend-servicemanager zend-servicemanager is a code-driven dependency injection container provided as a standalone component by Zend Framework. It features: lazy-loading of invokable (constructor-less) classes. ability to define factories for specific classes. ability to define generalized factories for classes with identical construction patterns (aka abstract factories ). ability to create lazy-loading proxies. ability to intercept before or after instantiation to alter the construction workflow (aka delegator factories ). interface injection (via initializers ). zend-servicemanager may either be created and populated programmatically, or via configuration. Configuration uses the following structure: [ 'services' => [ 'service name' => $serviceInstance, ], 'invokables' => [ 'service name' => 'class to instantiate', ], 'factories' => [ 'service name' => 'callable, Zend\\ServiceManager\\FactoryInterface instance, or name of factory class returning the service', ], 'abstract_factories' => [ 'class name of Zend\\ServiceManager\\AbstractFactoryInterface implementation', ], 'delegators' => [ 'service name' => [ 'class name of Zend\\ServiceManager\\DelegatorFactoryInterface implementation', ], ], 'lazy_services' => [ 'class_map' => [ 'service name' => 'Class\\Name\\Of\\Service', ], ], 'initializers' => [ 'callable, Zend\\ServiceManager\\InitializerInterface implementation, or name of initializer class', ], ] Read more about zend-servicemanager in its documentation . Installing zend-servicemanager To use zend-servicemanager with zend-expressive, you can install it via composer: $ composer require zendframework/zend-servicemanager Configuring zend-servicemanager You can configure zend-servicemanager either programmatically or via configuration. We'll show you both methods. Programmatically To use zend-servicemanager programatically, you'll need to create a Zend\\ServiceManager\\ServiceManager instance, and then start populating it. For this example, we'll assume your application configuration (used by several factories to configure instances) is in config/config.php , and that that file returns an array. We'll create a config/services.php file that creates and returns a Zend\\ServiceManager\\ServiceManager instance as follows: use Zend\\ServiceManager\\ServiceManager; $container = new ServiceManager(); // Application and configuration $container->setService('config', include 'config/config.php'); $container->setFactory( 'Zend\\Expressive\\Application', 'Zend\\Expressive\\Container\\ApplicationFactory' ); // Routing // In most cases, you can instantiate the router you want to use without using a // factory: $container->setInvokableClass( 'Zend\\Expressive\\Router\\RouterInterface', 'Zend\\Expressive\\Router\\AuraRouter' ); // Templating // In most cases, you can instantiate the template renderer you want to use // without using a factory: $container->setInvokableClass( 'Zend\\Expressive\\Template\\TemplateRendererInterface', 'Zend\\Expressive\\Plates\\PlatesRenderer' ); // These next two can be added in any environment; they won't be used unless // you add the WhoopsErrorHandler as the FinalHandler implementation: $container->setFactory( 'Zend\\Expressive\\Whoops', 'Zend\\Expressive\\Container\\WhoopsFactory' ); $container->setFactory( 'Zend\\Expressive\\WhoopsPageHandler', 'Zend\\Expressive\\Container\\WhoopsPageHandlerFactory' ); // Error Handling // If in development: $container->setFactory( 'Zend\\Expressive\\FinalHandler', 'Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory' ); // If in production: $container->setFactory( 'Zend\\Expressive\\FinalHandler', 'Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory' ); return $container; Your bootstrap (typically public/index.php ) will then look like this: chdir(dirname(__DIR__)); require 'vendor/autoload.php'; $container = require 'config/services.php'; $app = $container->get('Zend\\Expressive\\Application'); $app->run(); Configuration-Driven Container Alternately, you can use a configuration file to define the container. As before, we'll define our configuration in config/config.php , and our config/services.php file will still return our service manager instance; we'll define the service configuration in config/dependencies.php : return [ 'services' => [ 'config' => include __DIR__ . '/config.php', ], 'invokables' => [ 'Zend\\Expressive\\Router\\RouterInterface' => 'Zend\\Expressive\\Router\\AuraRouter', 'Zend\\Expressive\\Template\\TemplateRendererInterface' => 'Zend\\Expressive\\Plates\\PlatesRenderer' ], 'factories' => [ 'Zend\\Expressive\\Application' => 'Zend\\Expressive\\Container\\ApplicationFactory', 'Zend\\Expressive\\Whoops' => 'Zend\\Expressive\\Container\\WhoopsFactory', 'Zend\\Expressive\\WhoopsPageHandler' => 'Zend\\Expressive\\Container\\WhoopsPageHandlerFactory', ], ]; config/services.php becomes: use Zend\\ServiceManager\\Config; use Zend\\ServiceManager\\ServiceManager; return new ServiceManager(new Config(include 'config/dependencies.php')); There is one problem, however: which final handler should you configure? You have two choices on how to approach this: Selectively inject the factory in the bootstrap. Define the final handler service in an environment specific file and use file globbing to merge files. In the first case, you would change the config/services.php example to look like this: use Zend\\ServiceManager\\Config; use Zend\\ServiceManager\\ServiceManager; $container = new ServiceManager(new Config(include 'config/services.php')); switch ($variableOrConstantIndicatingEnvironment) { case 'development': $container->setFactory( 'Zend\\Expressive\\FinalHandler', 'Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory' ); break; case 'production': default: $container->setFactory( 'Zend\\Expressive\\FinalHandler', 'Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory' ); } return $container; In the second case, you will need to install zend-config: $ composer require zendframework/zend-config Then, create the directory config/autoload/ , and create two files, dependencies.global.php and dependencies.local.php . In your .gitignore , add an entry for config/autoload/*local.php to ensure \"local\" (environment-specific) files are excluded from the repository. config/dependencies.php will look like this: use Zend\\Config\\Factory as ConfigFactory; return ConfigFactory::fromFiles( glob('config/autoload/dependencies.{global,local}.php', GLOB_BRACE) ); config/autoload/dependencies.global.php will look like this: return [ 'services' => [ 'config' => include __DIR__ . '/config.php', ], 'invokables' => [ 'Zend\\Expressive\\Router\\RouterInterface' => 'Zend\\Expressive\\Router\\AuraRouter', 'Zend\\Expressive\\Template\\TemplateRendererInterface' => 'Zend\\Expressive\\Plates\\PlatesRenderer' ], 'factories' => [ 'Zend\\Expressive\\Application' => 'Zend\\Expressive\\Container\\ApplicationFactory', 'Zend\\Expressive\\FinalHandler' => 'Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory', ], ]; config/autoload/dependencies.local.php on your development machine can look like this: return [ 'factories' => [ 'Zend\\Expressive\\FinalHandler' => 'Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory', 'Zend\\Expressive\\Whoops' => 'Zend\\Expressive\\Container\\WhoopsFactory', 'Zend\\Expressive\\WhoopsPageHandler' => 'Zend\\Expressive\\Container\\WhoopsPageHandlerFactory', ], ]; Using the above approach allows you to keep the bootstrap file minimal and agnostic of environment. (Note: you can take a similar approach with the application configuration.)","title":"Using zend-servicemanager"},{"location":"v1/features/container/zend-servicemanager/#using-zend-servicemanager","text":"zend-servicemanager is a code-driven dependency injection container provided as a standalone component by Zend Framework. It features: lazy-loading of invokable (constructor-less) classes. ability to define factories for specific classes. ability to define generalized factories for classes with identical construction patterns (aka abstract factories ). ability to create lazy-loading proxies. ability to intercept before or after instantiation to alter the construction workflow (aka delegator factories ). interface injection (via initializers ). zend-servicemanager may either be created and populated programmatically, or via configuration. Configuration uses the following structure: [ 'services' => [ 'service name' => $serviceInstance, ], 'invokables' => [ 'service name' => 'class to instantiate', ], 'factories' => [ 'service name' => 'callable, Zend\\ServiceManager\\FactoryInterface instance, or name of factory class returning the service', ], 'abstract_factories' => [ 'class name of Zend\\ServiceManager\\AbstractFactoryInterface implementation', ], 'delegators' => [ 'service name' => [ 'class name of Zend\\ServiceManager\\DelegatorFactoryInterface implementation', ], ], 'lazy_services' => [ 'class_map' => [ 'service name' => 'Class\\Name\\Of\\Service', ], ], 'initializers' => [ 'callable, Zend\\ServiceManager\\InitializerInterface implementation, or name of initializer class', ], ] Read more about zend-servicemanager in its documentation .","title":"Using zend-servicemanager"},{"location":"v1/features/container/zend-servicemanager/#installing-zend-servicemanager","text":"To use zend-servicemanager with zend-expressive, you can install it via composer: $ composer require zendframework/zend-servicemanager","title":"Installing zend-servicemanager"},{"location":"v1/features/container/zend-servicemanager/#configuring-zend-servicemanager","text":"You can configure zend-servicemanager either programmatically or via configuration. We'll show you both methods.","title":"Configuring zend-servicemanager"},{"location":"v1/features/helpers/body-parse/","text":"Body Parsing Middleware Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware provides generic PSR-7 middleware for parsing the request body into parameters, and returning a new request instance that composes them. The subcomponent provides a strategy pattern around matching the request Content-Type , and then parsing it, giving you a flexible approach that can grow with your accepted content types. By default, this middleware will detect the following content types: application/x-www-form-urlencoded (standard web-based forms, without file uploads) application/json , application/*+json (JSON payloads) Registering the middleware You can register it manually: use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware; $app->pipe(BodyParamsMiddleware::class); // register other middleware // register routing middleware $app->run(); or as pipeline middleware: // config/autoload/middleware-pipeline.global.php use Zend\\Expressive\\Helper; return [ 'dependencies' => [ 'invokables' => [ Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class, /* ... */ ], 'factories' => [ /* ... */ ], ], 'middleware_pipeline' => [ [ 'middleware' => Helper\\BodyParams\\BodyParamsMiddleware::class, 'priority' => 100], /* ... */ 'routing' => [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Helper\\UrlHelperMiddleware::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], /* ... */ ], ]; Another option is to incorporate it in route-specific middleware queues: // config/autoload/routes.global.php use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware; return [ 'dependencies' => [ 'invokables' => [ Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class, /* ... */ ], 'factories' => [ /* ... */ ], ], 'routes' => [ [ 'name' => 'contact:process', 'path' => '/contact/process', 'middleware' => [ BodyParamsMiddleware::class, Contact\\Process::class, ], 'allowed_methods' => ['POST'], ] ], ]; This latter approach has a slight advantage: the middleware will only execute for routes that require the processing. While the middleware has some checks to ensure it only triggers for HTTP methods that accept bodies, those checks are still overhead that you might want to avoid; the above strategy of using the middleware only with specific routes can accomplish that. Strategies If you want to intercept and parse other payload types, you can add strategies to the middleware. Strategies implement Zend\\Expressive\\Helper\\BodyParams\\StrategyInterface : namespace Zend\\Expressive\\Helper\\BodyParams; use Psr\\Http\\Message\\ServerRequestInterface; interface StrategyInterface { /** * Match the content type to the strategy criteria. * * @param string $contentType * @return bool Whether or not the strategy matches. */ public function match($contentType); /** * Parse the body content and return a new response. * * @param ServerRequestInterface $request * @return ServerRequestInterface */ public function parse(ServerRequestInterface $request); } You then register them with the middleware using the addStrategy() method: $bodyParams->addStrategy(new MyCustomBodyParamsStrategy()); To automate the registration, we recommend writing a factory for the BodyParamsMiddleware , and replacing the invokables registration with a registration in the factories section of the middleware-pipeline.config.php file: use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware; class MyCustomBodyParamsStrategyFactory { public function __invoke($container) { $bodyParams = new BodyParamsMiddleware(); $bodyParams->addStrategy(new MyCustomBodyParamsStrategy()); return $bodyParams; } } // In config/autoload/middleware-pipeline.config.php: use Zend\\Expressive\\Helper; return [ 'dependencies' => [ 'invokables' => [ // Remove this line: Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class, /* ... */ ], 'factories' => [ // Add this line: Helper\\BodyParams\\BodyParamsMiddleware::class => MyCustomBodyParamsStrategyFactory::class, /* ... */ ], ], ]; Removing the default strategies By default, BodyParamsMiddleware composes the following strategies: Zend\\Expressive\\Helper\\BodyParams\\FormUrlEncodedStrategy Zend\\Expressive\\Helper\\BodyParams\\JsonStrategy These provide the most basic approaches to parsing the request body. They operate in the order they do to ensure the most common content type \u2014 application/x-www-form-urlencoded \u2014 matches first, as the middleware delegates parsing to the first match. If you do not want to use these default strategies, you can clear them from the middleware using clearStrategies() : $bodyParamsMiddleware->clearStrategies(); Note: if you do this, all strategies will be removed! As such, we recommend doing this only immediately before registering any custom strategies you might be using.","title":"Body Parsing Middleware"},{"location":"v1/features/helpers/body-parse/#body-parsing-middleware","text":"Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware provides generic PSR-7 middleware for parsing the request body into parameters, and returning a new request instance that composes them. The subcomponent provides a strategy pattern around matching the request Content-Type , and then parsing it, giving you a flexible approach that can grow with your accepted content types. By default, this middleware will detect the following content types: application/x-www-form-urlencoded (standard web-based forms, without file uploads) application/json , application/*+json (JSON payloads)","title":"Body Parsing Middleware"},{"location":"v1/features/helpers/body-parse/#registering-the-middleware","text":"You can register it manually: use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware; $app->pipe(BodyParamsMiddleware::class); // register other middleware // register routing middleware $app->run(); or as pipeline middleware: // config/autoload/middleware-pipeline.global.php use Zend\\Expressive\\Helper; return [ 'dependencies' => [ 'invokables' => [ Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class, /* ... */ ], 'factories' => [ /* ... */ ], ], 'middleware_pipeline' => [ [ 'middleware' => Helper\\BodyParams\\BodyParamsMiddleware::class, 'priority' => 100], /* ... */ 'routing' => [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Helper\\UrlHelperMiddleware::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], /* ... */ ], ]; Another option is to incorporate it in route-specific middleware queues: // config/autoload/routes.global.php use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware; return [ 'dependencies' => [ 'invokables' => [ Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class, /* ... */ ], 'factories' => [ /* ... */ ], ], 'routes' => [ [ 'name' => 'contact:process', 'path' => '/contact/process', 'middleware' => [ BodyParamsMiddleware::class, Contact\\Process::class, ], 'allowed_methods' => ['POST'], ] ], ]; This latter approach has a slight advantage: the middleware will only execute for routes that require the processing. While the middleware has some checks to ensure it only triggers for HTTP methods that accept bodies, those checks are still overhead that you might want to avoid; the above strategy of using the middleware only with specific routes can accomplish that.","title":"Registering the middleware"},{"location":"v1/features/helpers/body-parse/#strategies","text":"If you want to intercept and parse other payload types, you can add strategies to the middleware. Strategies implement Zend\\Expressive\\Helper\\BodyParams\\StrategyInterface : namespace Zend\\Expressive\\Helper\\BodyParams; use Psr\\Http\\Message\\ServerRequestInterface; interface StrategyInterface { /** * Match the content type to the strategy criteria. * * @param string $contentType * @return bool Whether or not the strategy matches. */ public function match($contentType); /** * Parse the body content and return a new response. * * @param ServerRequestInterface $request * @return ServerRequestInterface */ public function parse(ServerRequestInterface $request); } You then register them with the middleware using the addStrategy() method: $bodyParams->addStrategy(new MyCustomBodyParamsStrategy()); To automate the registration, we recommend writing a factory for the BodyParamsMiddleware , and replacing the invokables registration with a registration in the factories section of the middleware-pipeline.config.php file: use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware; class MyCustomBodyParamsStrategyFactory { public function __invoke($container) { $bodyParams = new BodyParamsMiddleware(); $bodyParams->addStrategy(new MyCustomBodyParamsStrategy()); return $bodyParams; } } // In config/autoload/middleware-pipeline.config.php: use Zend\\Expressive\\Helper; return [ 'dependencies' => [ 'invokables' => [ // Remove this line: Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class, /* ... */ ], 'factories' => [ // Add this line: Helper\\BodyParams\\BodyParamsMiddleware::class => MyCustomBodyParamsStrategyFactory::class, /* ... */ ], ], ];","title":"Strategies"},{"location":"v1/features/helpers/body-parse/#removing-the-default-strategies","text":"By default, BodyParamsMiddleware composes the following strategies: Zend\\Expressive\\Helper\\BodyParams\\FormUrlEncodedStrategy Zend\\Expressive\\Helper\\BodyParams\\JsonStrategy These provide the most basic approaches to parsing the request body. They operate in the order they do to ensure the most common content type \u2014 application/x-www-form-urlencoded \u2014 matches first, as the middleware delegates parsing to the first match. If you do not want to use these default strategies, you can clear them from the middleware using clearStrategies() : $bodyParamsMiddleware->clearStrategies(); Note: if you do this, all strategies will be removed! As such, we recommend doing this only immediately before registering any custom strategies you might be using.","title":"Removing the default strategies"},{"location":"v1/features/helpers/intro/","text":"Helpers Some tasks and features will be common to many if not all applications. For those, Expressive provides helpers . These are typically utility classes that may integrate features or simply provide standalone benefits. Currently, these include: UrlHelper ServerUrlHelper Installation If you started your project using the Expressive skeleton package, the helpers are already installed. If not, you can install them as follows: $ composer require zendframework/zend-expressive-helpers","title":"Introduction"},{"location":"v1/features/helpers/intro/#helpers","text":"Some tasks and features will be common to many if not all applications. For those, Expressive provides helpers . These are typically utility classes that may integrate features or simply provide standalone benefits. Currently, these include: UrlHelper ServerUrlHelper","title":"Helpers"},{"location":"v1/features/helpers/intro/#installation","text":"If you started your project using the Expressive skeleton package, the helpers are already installed. If not, you can install them as follows: $ composer require zendframework/zend-expressive-helpers","title":"Installation"},{"location":"v1/features/helpers/server-url-helper/","text":"ServerUrlHelper Zend\\Expressive\\Helper\\ServerUrlHelper provides the ability to generate a full URI by passing only the path to the helper; it will then use that path with the current Psr\\Http\\Message\\UriInterface instance provided to it in order to generate a fully qualified URI. Usage When you have an instance, use either its generate() method, or call the instance as an invokable: // Using the generate() method: $url = $helper->generate('/foo'); // is equivalent to invocation: $url = $helper('/foo'); The helper is particularly useful when used in conjunction with the UrlHelper , as you can then create fully qualified URIs for use with headers, API hypermedia links, etc.: $url = $serverUrl($url('resource', ['id' => 'sha1'])); The signature for the ServerUrlHelper generate() and __invoke() methods is: function ($path = null) : string Where: $path , when provided, can be a string path to use to generate a URI. Creating an instance In order to use the helper, you will need to inject it with the current UriInterface from the request instance. To automate this, we provide Zend\\Expressive\\Helper\\ServerUrlMiddleware , which composes a ServerUrl instance, and, when invoked, injects it with the URI instance. As such, you will need to: Register the ServerUrlHelper as a service in your container. Register the ServerUrlMiddleware as a service in your container. Register the ServerUrlMiddleware as pipeline middleware, anytime before the routing middleware. The following examples demonstrate registering the services. use Zend\\Expressive\\Helper\\ServerUrlHelper; use Zend\\Expressive\\Helper\\ServerUrlMiddleware; use Zend\\Expressive\\Helper\\ServerUrlMiddlewareFactory; // zend-servicemanager: $services->setInvokableClass(ServerUrlHelper::class, ServerUrlHelper::class); $services->setFactory(ServerUrlMiddleware::class, ServerUrlMiddlewareFactory::class); // Pimple: $pimple[ServerUrlHelper::class] = function ($container) { return new ServerUrlHelper(); }; $pimple[ServerUrlMiddleware::class] = function ($container) { $factory = new ServerUrlMiddlewareFactory(); return $factory($container); }; // Aura.Di: $container->set(ServerUrlHelper::class, $container->lazyNew(ServerUrlHelper::class)); $container->set(ServerUrlMiddlewareFactory::class, $container->lazyNew(ServerUrlMiddlewareFactory::class)); $container->set( ServerUrlMiddleware::class, $container->lazyGetCall(ServerUrlMiddlewareFactory::class, '__invoke', $container) ); To register the ServerUrlMiddleware as pipeline middleware anytime before the routing middleware: use Zend\\Expressive\\Helper\\ServerUrlMiddleware; // Programmatically: $app->pipe(ServerUrlMiddleware::class); $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); // Or use configuration: // [ // 'middleware_pipeline' => [ // ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX], // /* ... */ // ], // ] The following dependency configuration will work for all three when using the Expressive skeleton: return [ 'dependencies' => [ 'invokables' => [ ServerUrlHelper::class => ServerUrlHelper::class, ], 'factories' => [ ServerUrlMiddleware::class => ServerUrlMiddlewareFactory::class, ], ], 'middleware_pipeline' => [ ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX], /* ... */ ], ]; Skeleton configures helpers If you started your project using the Expressive skeleton package, the ServerUrlHelper and ServerUrlMiddleware factories are already registered for you, as is the ServerUrlMiddleware pipeline middleware. Using the helper in middleware Compose the helper in your middleware (or elsewhere), and then use it to generate URI paths: use Zend\\Expressive\\Helper\\ServerUrlHelper; class FooMiddleware { private $helper; public function __construct(ServerUrlHelper $helper) { $this->helper = $helper; } public function __invoke($request, $response, callable $next) { $response = $response->withHeader( 'Link', $this->helper->generate() . '; rel=\"self\"' ); return $next($request, $response); } }","title":"ServerUrlHelper"},{"location":"v1/features/helpers/server-url-helper/#serverurlhelper","text":"Zend\\Expressive\\Helper\\ServerUrlHelper provides the ability to generate a full URI by passing only the path to the helper; it will then use that path with the current Psr\\Http\\Message\\UriInterface instance provided to it in order to generate a fully qualified URI.","title":"ServerUrlHelper"},{"location":"v1/features/helpers/server-url-helper/#usage","text":"When you have an instance, use either its generate() method, or call the instance as an invokable: // Using the generate() method: $url = $helper->generate('/foo'); // is equivalent to invocation: $url = $helper('/foo'); The helper is particularly useful when used in conjunction with the UrlHelper , as you can then create fully qualified URIs for use with headers, API hypermedia links, etc.: $url = $serverUrl($url('resource', ['id' => 'sha1'])); The signature for the ServerUrlHelper generate() and __invoke() methods is: function ($path = null) : string Where: $path , when provided, can be a string path to use to generate a URI.","title":"Usage"},{"location":"v1/features/helpers/server-url-helper/#creating-an-instance","text":"In order to use the helper, you will need to inject it with the current UriInterface from the request instance. To automate this, we provide Zend\\Expressive\\Helper\\ServerUrlMiddleware , which composes a ServerUrl instance, and, when invoked, injects it with the URI instance. As such, you will need to: Register the ServerUrlHelper as a service in your container. Register the ServerUrlMiddleware as a service in your container. Register the ServerUrlMiddleware as pipeline middleware, anytime before the routing middleware. The following examples demonstrate registering the services. use Zend\\Expressive\\Helper\\ServerUrlHelper; use Zend\\Expressive\\Helper\\ServerUrlMiddleware; use Zend\\Expressive\\Helper\\ServerUrlMiddlewareFactory; // zend-servicemanager: $services->setInvokableClass(ServerUrlHelper::class, ServerUrlHelper::class); $services->setFactory(ServerUrlMiddleware::class, ServerUrlMiddlewareFactory::class); // Pimple: $pimple[ServerUrlHelper::class] = function ($container) { return new ServerUrlHelper(); }; $pimple[ServerUrlMiddleware::class] = function ($container) { $factory = new ServerUrlMiddlewareFactory(); return $factory($container); }; // Aura.Di: $container->set(ServerUrlHelper::class, $container->lazyNew(ServerUrlHelper::class)); $container->set(ServerUrlMiddlewareFactory::class, $container->lazyNew(ServerUrlMiddlewareFactory::class)); $container->set( ServerUrlMiddleware::class, $container->lazyGetCall(ServerUrlMiddlewareFactory::class, '__invoke', $container) ); To register the ServerUrlMiddleware as pipeline middleware anytime before the routing middleware: use Zend\\Expressive\\Helper\\ServerUrlMiddleware; // Programmatically: $app->pipe(ServerUrlMiddleware::class); $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); // Or use configuration: // [ // 'middleware_pipeline' => [ // ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX], // /* ... */ // ], // ] The following dependency configuration will work for all three when using the Expressive skeleton: return [ 'dependencies' => [ 'invokables' => [ ServerUrlHelper::class => ServerUrlHelper::class, ], 'factories' => [ ServerUrlMiddleware::class => ServerUrlMiddlewareFactory::class, ], ], 'middleware_pipeline' => [ ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX], /* ... */ ], ];","title":"Creating an instance"},{"location":"v1/features/helpers/server-url-helper/#using-the-helper-in-middleware","text":"Compose the helper in your middleware (or elsewhere), and then use it to generate URI paths: use Zend\\Expressive\\Helper\\ServerUrlHelper; class FooMiddleware { private $helper; public function __construct(ServerUrlHelper $helper) { $this->helper = $helper; } public function __invoke($request, $response, callable $next) { $response = $response->withHeader( 'Link', $this->helper->generate() . '; rel=\"self\"' ); return $next($request, $response); } }","title":"Using the helper in middleware"},{"location":"v1/features/helpers/url-helper/","text":"UrlHelper Zend\\Expressive\\Helper\\UrlHelper provides the ability to generate a URI path based on a given route defined in the Zend\\Expressive\\Router\\RouterInterface . If injected with a route result, and the route being used was also the one matched during routing, you can provide a subset of routing parameters, and any not provided will be pulled from those matched. Usage When you have an instance, use either its generate() method, or call the instance as an invokable: // Using the generate() method: $url = $helper->generate('resource', ['id' => 'sha1']); // is equivalent to invocation: $url = $helper('resource', ['id' => 'sha1']); The signature for both is: function ($routeName, array $params = []) : string Where: $routeName is the name of a route defined in the composed router. You may omit this argument if you want to generate the path for the currently matched request. $params is an array of substitutions to use for the provided route, with the following behavior: If a RouteResult is composed in the helper, and the $routeName matches it, the provided $params will be merged with any matched parameters, with those provided taking precedence. If a RouteResult is not composed, or if the composed result does not match the provided $routeName , then only the $params provided will be used for substitutions. If no $params are provided, and the $routeName matches the currently matched route, then any matched parameters found will be used. parameters found will be used. If no $params are provided, and the $routeName does not match the currently matched route, or if no route result is present, then no substitutions will be made. Each method will raise an exception if: No $routeName is provided, and no RouteResult is composed. No $routeName is provided, a RouteResult is composed, but that result represents a matching failure. The given $routeName is not defined in the router. Creating an instance In order to use the helper, you will need to instantiate it with the current RouterInterface . The factory Zend\\Expressive\\Helper\\UrlHelperFactory has been provided for this purpose, and can be used trivially with most dependency injection containers implementing container-interop. Additionally, it is most useful when injected with the current results of routing, which requires registering middleware with the application that can inject the route result. The following steps should be followed to register and configure the helper: Register the UrlHelper as a service in your container, using the provided factory. Register the UrlHelperMiddleware as a service in your container, using the provided factory. Register the UrlHelperMiddleware as pipeline middleware, immediately following the routing middleware. Registering the helper service The following examples demonstrate programmatic registration of the UrlHelper service in your selected dependency injection container. use Zend\\Expressive\\Helper\\UrlHelper; use Zend\\Expressive\\Helper\\UrlHelperFactory; // zend-servicemanager: $services->setFactory(UrlHelper::class, UrlHelperFactory::class); // Pimple: $pimple[UrlHelper::class] = function ($container) { $factory = new UrlHelperFactory(); return $factory($container); }; // Aura.Di: $container->set(UrlHelperFactory::class, $container->lazyNew(UrlHelperFactory::class)); $container->set( UrlHelper::class, $container->lazyGetCall(UrlHelperFactory::class, '__invoke', $container) ); The following dependency configuration will work for all three when using the Expressive skeleton: return ['dependencies' => [ 'factories' => [ UrlHelper::class => UrlHelperFactory::class, ], ]] UrlHelperFactory requires RouterInterface The factory requires that a service named Zend\\Expressive\\Router\\RouterInterface is present, and will raise an exception if the service is not found. Registering the pipeline middleware To register the UrlHelperMiddleware as pipeline middleware following the routing middleware: use Zend\\Expressive\\Helper\\UrlHelperMiddleware; // Programmatically: $app->pipeRoutingMiddleware(); $app->pipe(UrlHelperMiddleware::class); $app->pipeDispatchMiddleware(); // Or use configuration: // [ // 'middleware_pipeline' => [ // /* ... */ // Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, // ['middleware' => UrlHelperMiddleware::class], // Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, // /* ... */ // ], // ] // // Alternately, create a nested middleware pipeline for the routing, UrlHelper, // and dispatch middleware: // [ // 'middleware_pipeline' => [ // /* ... */ // 'routing' => [ // 'middleware' => [ // Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, // UrlHelperMiddleware::class // Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, // ], // 'priority' => 1, // ], // /* ... */ // ], // ] The following dependency configuration will work for all three when using the Expressive skeleton: return [ 'dependencies' => [ 'factories' => [ UrlHelper::class => UrlHelperFactory::class, UrlHelperMiddleware::class => UrlHelperMiddlewareFactory::class, ], ], 'middleware_pipeline' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, ['middleware' => UrlHelperMiddleware::class], Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], ]; // OR: return [ 'dependencies' => [ 'factories' => [ UrlHelper::class => UrlHelperFactory::class, UrlHelperMiddleware::class => UrlHelperMiddlewareFactory::class, ], ], 'middleware_pipeline' => [ 'routing' => [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, UrlHelperMiddleware::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], ], ]; Skeleton configures helpers If you started your project using the Expressive skeleton package, the UrlHelper and UrlHelperMiddleware factories are already registered for you, as is the UrlHelperMiddleware pipeline middleware. Using the helper in middleware Compose the helper in your middleware (or elsewhere), and then use it to generate URI paths: use Zend\\Expressive\\Helper\\UrlHelper; class FooMiddleware { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } public function __invoke($request, $response, callable $next) { $response = $response->withHeader( 'Link', $this->helper->generate('resource', ['id' => 'sha1']) ); return $next($request, $response); } } Base Path support If your application is running under a subdirectory, or if you are running pipeline middleware that is intercepting on a subpath, the paths generated by the router may not reflect the base path , and thus be invalid. To accommodate this, the UrlHelper supports injection of the base path; when present, it will be prepended to the path generated by the router. As an example, perhaps you have middleware running to intercept a language prefix in the URL; this middleware could then inject the UrlHelper with the detected language, before stripping it off the request URI instance to pass on to the router: use Locale; use Zend\\Expressive\\Helper\\UrlHelper; class LocaleMiddleware { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } public function __invoke($request, $response, $next) { $uri = $request->getUri(); $path = $uri->getPath(); if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) { return $next($request, $response); } $locale = $matches['locale']; Locale::setDefault(Locale::canonicalize($locale)); $this->helper->setBasePath($locale); return $next( $request->withUri( $uri->withPath(substr($path, (strlen($locale) + 1))) ), $response ); } } (Note: if the base path injected is not prefixed with / , the helper will add the slash.) Paths generated by the UriHelper from this point forward will have the detected language prefix.","title":"UrlHelper"},{"location":"v1/features/helpers/url-helper/#urlhelper","text":"Zend\\Expressive\\Helper\\UrlHelper provides the ability to generate a URI path based on a given route defined in the Zend\\Expressive\\Router\\RouterInterface . If injected with a route result, and the route being used was also the one matched during routing, you can provide a subset of routing parameters, and any not provided will be pulled from those matched.","title":"UrlHelper"},{"location":"v1/features/helpers/url-helper/#usage","text":"When you have an instance, use either its generate() method, or call the instance as an invokable: // Using the generate() method: $url = $helper->generate('resource', ['id' => 'sha1']); // is equivalent to invocation: $url = $helper('resource', ['id' => 'sha1']); The signature for both is: function ($routeName, array $params = []) : string Where: $routeName is the name of a route defined in the composed router. You may omit this argument if you want to generate the path for the currently matched request. $params is an array of substitutions to use for the provided route, with the following behavior: If a RouteResult is composed in the helper, and the $routeName matches it, the provided $params will be merged with any matched parameters, with those provided taking precedence. If a RouteResult is not composed, or if the composed result does not match the provided $routeName , then only the $params provided will be used for substitutions. If no $params are provided, and the $routeName matches the currently matched route, then any matched parameters found will be used. parameters found will be used. If no $params are provided, and the $routeName does not match the currently matched route, or if no route result is present, then no substitutions will be made. Each method will raise an exception if: No $routeName is provided, and no RouteResult is composed. No $routeName is provided, a RouteResult is composed, but that result represents a matching failure. The given $routeName is not defined in the router.","title":"Usage"},{"location":"v1/features/helpers/url-helper/#creating-an-instance","text":"In order to use the helper, you will need to instantiate it with the current RouterInterface . The factory Zend\\Expressive\\Helper\\UrlHelperFactory has been provided for this purpose, and can be used trivially with most dependency injection containers implementing container-interop. Additionally, it is most useful when injected with the current results of routing, which requires registering middleware with the application that can inject the route result. The following steps should be followed to register and configure the helper: Register the UrlHelper as a service in your container, using the provided factory. Register the UrlHelperMiddleware as a service in your container, using the provided factory. Register the UrlHelperMiddleware as pipeline middleware, immediately following the routing middleware.","title":"Creating an instance"},{"location":"v1/features/helpers/url-helper/#using-the-helper-in-middleware","text":"Compose the helper in your middleware (or elsewhere), and then use it to generate URI paths: use Zend\\Expressive\\Helper\\UrlHelper; class FooMiddleware { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } public function __invoke($request, $response, callable $next) { $response = $response->withHeader( 'Link', $this->helper->generate('resource', ['id' => 'sha1']) ); return $next($request, $response); } }","title":"Using the helper in middleware"},{"location":"v1/features/helpers/url-helper/#base-path-support","text":"If your application is running under a subdirectory, or if you are running pipeline middleware that is intercepting on a subpath, the paths generated by the router may not reflect the base path , and thus be invalid. To accommodate this, the UrlHelper supports injection of the base path; when present, it will be prepended to the path generated by the router. As an example, perhaps you have middleware running to intercept a language prefix in the URL; this middleware could then inject the UrlHelper with the detected language, before stripping it off the request URI instance to pass on to the router: use Locale; use Zend\\Expressive\\Helper\\UrlHelper; class LocaleMiddleware { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } public function __invoke($request, $response, $next) { $uri = $request->getUri(); $path = $uri->getPath(); if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) { return $next($request, $response); } $locale = $matches['locale']; Locale::setDefault(Locale::canonicalize($locale)); $this->helper->setBasePath($locale); return $next( $request->withUri( $uri->withPath(substr($path, (strlen($locale) + 1))) ), $response ); } } (Note: if the base path injected is not prefixed with / , the helper will add the slash.) Paths generated by the UriHelper from this point forward will have the detected language prefix.","title":"Base Path support"},{"location":"v1/features/router/aura/","text":"Using Aura.Router Aura.Router provides a plethora of methods for further configuring the router instance. One of the more useful configuration is to provide default specifications: A regular expression that applies the same for a given routing match: php // Parameters named \"id\" will only match digits by default: $router->addTokens([ 'id' => '\\d+', ]); A default parameter and/or its default value to always provide: php // mediatype defaults to \"application/xhtml+xml\" and will be available in all // requests: $router->addValues([ 'mediatype' => 'application/xhtml+xml', ]); Only match if secure (i.e., under HTTPS): php $router->setSecure(true); In order to specify these, you need access to the underlying Aura.Router instance, however, and the RouterInterface does not provide an accessor! The answer, then, is to use dependency injection. This can be done in two ways: programmatically, or via a factory to use in conjunction with your container instance. Installing Aura.Router To use Aura.Router, you will first need to install the Aura.Router integration: $ composer require zendframework/zend-expressive-aurarouter Quick Start At its simplest, you can instantiate a Zend\\Expressive\\Router\\AuraRouter instance with no arguments; it will create the underlying Aura.Router objects required and compose them for you: use Zend\\Expressive\\Router\\AuraRouter; $router = new AuraRouter(); Programmatic Creation If you need greater control over the Aura.Router setup and configuration, you can create the instances necessary and inject them into Zend\\Expressive\\Router\\AuraRouter during instantiation. <?php use Aura\\Router\\RouterFactory; use Zend\\Expressive\\AppFactory; use Zend\\Expressive\\Router\\AuraRouter as AuraBridge; $auraRouter = (new RouterFactory())->newInstance(); $auraRouter->setSecure(true); $auraRouter->addValues([ 'mediatype' => 'application/xhtml+xml', ]); $router = new AuraBridge($auraRouter); // First argument is the container to use, if not using the default; // second is the router. $app = AppFactory::create(null, $router); Piping the route middleware As a reminder, you will need to ensure that middleware is piped in the order in which it needs to be executed; please see the section on \"Controlling middleware execution order\" in the piping documentation . This is particularly salient when defining routes before injecting the router in the application instance! Factory-Driven Creation We recommend using an Inversion of Control container for your applications; as such, in this section we will demonstrate two strategies for creating your Aura.Router implementation. Basic Router If you don't need to provide any setup or configuration, you can simply instantiate and return an instance of Zend\\Expressive\\Router\\AuraRouter for the service name Zend\\Expressive\\Router\\RouterInterface . A factory would look like this: // in src/Application/Container/RouterFactory.php namespace Application\\Container; use Interop\\Container\\ContainerInterface; use Zend\\Expressive\\Router\\AuraRouter; class RouterFactory { /** * @param ContainerInterface $container * @return AuraRouter */ public function __invoke(ContainerInterface $container) { return new AuraRouter(); } } You would register this with zend-servicemanager using: $container->setFactory( 'Zend\\Expressive\\Router\\RouterInterface', 'Application\\Container\\RouterFactory' ); And in Pimple: $pimple['Zend\\Expressive\\Router\\RouterInterface'] = new Application\\Container\\RouterFactory(); For zend-servicemanager, you can omit the factory entirely, and register the class as an invokable: $container->setInvokableClass( 'Zend\\Expressive\\Router\\RouterInterface', 'Zend\\Expressive\\Router\\AuraRouter' ); Advanced Configuration If you want to provide custom setup or configuration, you can do so. In this example, we will be defining two factories: A factory to register as and generate an Aura\\Router\\Router instance. A factory registered as Zend\\Expressive\\Router\\RouterInterface , which creates and returns a Zend\\Expressive\\Router\\AuraRouter instance composing the Aura\\Router\\Router instance. Sound difficult? It's not; we've essentially done it above already! // in src/Application/Container/AuraRouterFactory.php: namespace Application\\Container; use Aura\\Router\\RouterFactory; use Interop\\Container\\ContainerInterface; class AuraRouterFactory { /** * @param ContainerInterface $container * @return \\Aura\\Router\\Router */ public function __invoke(ContainerInterface $container) { $router = (new RouterFactory())->newInstance(); $router->setSecure(true); $router->addValues([ 'mediatype' => 'application/xhtml+xml', ]); return $router; } } // in src/Application/Container/RouterFactory.php namespace Application\\Container; use Interop\\Container\\ContainerInterface; use Zend\\Expressive\\Router\\AuraRouter as AuraBridge; class RouterFactory { /** * @param ContainerInterface $container * @return AuraBridge */ public function __invoke(ContainerInterface $container) { return new AuraBridge($container->get('Aura\\Router\\Router')); } } From here, you will need to register your factories with your IoC container. If you are using zend-servicemanager, this will look like: // Programmatically: use Zend\\ServiceManager\\ServiceManager; $container = new ServiceManager(); $container->addFactory( 'Aura\\Router\\Router', 'Application\\Container\\AuraRouterFactory' ); $container->addFactory( 'Zend\\Expressive\\Router\\RouterInterface', 'Application\\Container\\RouterFactory' ); // Alternately, via configuration: return [ 'factories' => [ 'Aura\\Router\\Router' => 'Application\\Container\\AuraRouterFactory', 'Zend\\Expressive\\Router\\RouterInterface' => 'Application\\Container\\RouterFactory', ], ]; For Pimple, configuration looks like: use Application\\Container\\AuraRouterFactory; use Application\\Container\\RouterFactory; use Interop\\Container\\Pimple\\PimpleInterop as Pimple; $container = new Pimple(); $container['Aura\\Router\\Router'] = new AuraRouterFactory(); $container['Zend\\Expressive\\Router\\RouterInterface'] = new RouterFactory();","title":"Using Aura"},{"location":"v1/features/router/aura/#using-aurarouter","text":"Aura.Router provides a plethora of methods for further configuring the router instance. One of the more useful configuration is to provide default specifications: A regular expression that applies the same for a given routing match: php // Parameters named \"id\" will only match digits by default: $router->addTokens([ 'id' => '\\d+', ]); A default parameter and/or its default value to always provide: php // mediatype defaults to \"application/xhtml+xml\" and will be available in all // requests: $router->addValues([ 'mediatype' => 'application/xhtml+xml', ]); Only match if secure (i.e., under HTTPS): php $router->setSecure(true); In order to specify these, you need access to the underlying Aura.Router instance, however, and the RouterInterface does not provide an accessor! The answer, then, is to use dependency injection. This can be done in two ways: programmatically, or via a factory to use in conjunction with your container instance.","title":"Using Aura.Router"},{"location":"v1/features/router/aura/#installing-aurarouter","text":"To use Aura.Router, you will first need to install the Aura.Router integration: $ composer require zendframework/zend-expressive-aurarouter","title":"Installing Aura.Router"},{"location":"v1/features/router/aura/#quick-start","text":"At its simplest, you can instantiate a Zend\\Expressive\\Router\\AuraRouter instance with no arguments; it will create the underlying Aura.Router objects required and compose them for you: use Zend\\Expressive\\Router\\AuraRouter; $router = new AuraRouter();","title":"Quick Start"},{"location":"v1/features/router/aura/#programmatic-creation","text":"If you need greater control over the Aura.Router setup and configuration, you can create the instances necessary and inject them into Zend\\Expressive\\Router\\AuraRouter during instantiation. <?php use Aura\\Router\\RouterFactory; use Zend\\Expressive\\AppFactory; use Zend\\Expressive\\Router\\AuraRouter as AuraBridge; $auraRouter = (new RouterFactory())->newInstance(); $auraRouter->setSecure(true); $auraRouter->addValues([ 'mediatype' => 'application/xhtml+xml', ]); $router = new AuraBridge($auraRouter); // First argument is the container to use, if not using the default; // second is the router. $app = AppFactory::create(null, $router);","title":"Programmatic Creation"},{"location":"v1/features/router/aura/#factory-driven-creation","text":"We recommend using an Inversion of Control container for your applications; as such, in this section we will demonstrate two strategies for creating your Aura.Router implementation.","title":"Factory-Driven Creation"},{"location":"v1/features/router/fast-route/","text":"Using FastRoute FastRoute provides a number of different combinations for how to both parse routes and match incoming requests against them. Internally, we use the standard route parser ( FastRoute\\RouterParser\\Std ) to parse routes, a RouteCollector to collect them, and the \"Group Count Based\" dispatcher to match incoming requests against routes. If you wish to use a different combination \u2014 e.g., to use the Group Position Based route matcher \u2014 you will need to create your own instances and inject them into the Zend\\Expressive\\Router\\FastRouteRouter class, at instantiation. The FastRouteRouter bridge class accepts two arguments at instantiation: A FastRoute\\RouteCollector instance A callable that will return a FastRoute\\Dispatcher\\RegexBasedAbstract instance. Injection can be done either programmatically or via a factory to use in conjunction with your container instance. Installing FastRoute To use FastRoute, you will first need to install the FastRoute integration: $ composer require zendframework/zend-expressive-fastroute Quick Start At its simplest, you can instantiate a Zend\\Expressive\\Router\\FastRouteRouter instance with no arguments; it will create the underlying FastRoute objects required and compose them for you: use Zend\\Expressive\\Router\\FastRouteRouter; $router = new FastRouteRouter(); Programmatic Creation If you need greater control over the FastRoute setup and configuration, you can create the instances necessary and inject them into Zend\\Expressive\\Router\\FastRouteRouter during instantiation. To do so, you will need to setup your RouteCollector instance and/or optionally callable to return your RegexBasedAbstract instance manually, inject them in your Zend\\Expressive\\Router\\FastRouteRouter instance, and inject use that when creating your Application instance. <?php use FastRoute; use FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher; use FastRoute\\RouteCollector; use FastRoute\\RouteGenerator; use FastRoute\\RouteParser\\Std as RouteParser; use Zend\\Expressive\\AppFactory; use Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge; $fastRoute = new RouteCollector( new RouteParser(), new RouteGenerator() ); $getDispatcher = function ($data) { return new FastRouteDispatcher($data); }; $router = new FastRouteBridge($fastRoute, $getDispatcher); // First argument is the container to use, if not using the default; // second is the router. $app = AppFactory::create(null, $router); Piping the route middleware As a reminder, you will need to ensure that middleware is piped in the order in which it needs to be executed; please see the section on \"Controlling middleware execution order\" in the piping documentation . This is particularly salient when defining routes before injecting the router in the application instance! Factory-Driven Creation We recommend using an Inversion of Control container for your applications; as such, in this section we will demonstrate two strategies for creating your FastRoute implementation. Basic Router If you don't need to provide any setup or configuration, you can simply instantiate and return an instance of Zend\\Expressive\\Router\\FastRouteRouter for the service name Zend\\Expressive\\Router\\RouterInterface . A factory would look like this: // in src/Application/Container/RouterFactory.php namespace Application\\Container; use Interop\\Container\\ContainerInterface; use Zend\\Expressive\\Router\\FastRouteRouter; class RouterFactory { /** * @param ContainerInterface $container * @return FastRouteRouter */ public function __invoke(ContainerInterface $container) { return new FastRouteRouter(); } } You would register this with zend-servicemanager using: $container->setFactory( 'Zend\\Expressive\\Router\\RouterInterface', 'Application\\Container\\RouterFactory' ); And in Pimple: $pimple['Zend\\Expressive\\Router\\RouterInterface'] = new Application\\Container\\RouterFactory(); For zend-servicemanager, you can omit the factory entirely, and register the class as an invokable: $container->setInvokableClass( 'Zend\\Expressive\\Router\\RouterInterface', 'Zend\\Expressive\\Router\\FastRouteRouter' ); Advanced Configuration If you want to provide custom setup or configuration, you can do so. In this example, we will be defining three factories: A factory to register as and generate a FastRoute\\RouteCollector instance. A factory to register as FastRoute\\DispatcherFactory and return a callable factory that returns a RegexBasedAbstract instance. A factory registered as Zend\\Expressive\\Router\\RouterInterface , which creates and returns a Zend\\Expressive\\Router\\FastRouteRouter instance composing the two services. Sound difficult? It's not; we've essentially done it above already! <?php // in src/Application/Container/FastRouteCollectorFactory.php: namespace Application\\Container; use FastRoute\\RouteCollector; use FastRoute\\RouteGenerator; use FastRoute\\RouteParser\\Std as RouteParser; use Interop\\Container\\ContainerInterface; class FastRouteCollectorFactory { /** * @param ContainerInterface $container * @return RouteCollector */ public function __invoke(ContainerInterface $container) { return new RouteCollector( new RouteParser(), new RouteGenerator() ); } } // in src/Application/Container/FastRouteDispatcherFactory: namespace Application\\Container; use FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher; use Interop\\Container\\ContainerInterface; class FastRouteDispatcherFactory { /** * @param ContainerInterface $container * @return callable */ public function __invoke(ContainerInterface $container) { return function ($data) { return new FastRouteDispatcher($data); }; } } // in src/Application/Container/RouterFactory.php namespace Application\\Container; use Interop\\Container\\ContainerInterface; use Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge; class RouterFactory { /** * @param ContainerInterface $container * @return FastRouteBridge */ public function __invoke(ContainerInterface $container) { return new FastRouteBridge( $container->get('FastRoute\\RouteCollector'), $container->get('FastRoute\\DispatcherFactory'), ); } } From here, you will need to register your factories with your IoC container. If you are using zend-servicemanager, this will look like: // Programmatically: use Zend\\ServiceManager\\ServiceManager; $container = new ServiceManager(); $container->addFactory( 'FastRoute\\RouteCollector', 'Application\\Container\\FastRouteCollectorFactory' ); $container->addFactory( 'FastRoute\\DispatcherFactory', 'Application\\Container\\FastRouteDispatcherFactory' ); $container->addFactory( 'Zend\\Expressive\\Router\\RouterInterface', 'Application\\Container\\RouterFactory' ); // Alternately, via configuration: return [ 'factories' => [ 'FastRoute\\RouteCollector' => 'Application\\Container\\FastRouteCollectorFactory', 'FastRoute\\DispatcherFactory' => 'Application\\Container\\FastRouteDispatcherFactory', 'Zend\\Expressive\\Router\\RouterInterface' => 'Application\\Container\\RouterFactory', ], ]; For Pimple, configuration looks like: use Application\\Container\\FastRouteCollectorFactory; use Application\\Container\\FastRouteDispatcherFactory; use Application\\Container\\RouterFactory; use Interop\\Container\\Pimple\\PimpleInterop as Pimple; $container = new Pimple(); $container['FastRoute\\RouteCollector'] = new FastRouteCollectorFactory(); $container['FastRoute\\RouteDispatcher'] = new FastRouteDispatcherFactory(); $container['Zend\\Expressive\\Router\\RouterInterface'] = new RouterFactory(); FastRoute caching support Since zend-expressive-fastroute 1.3.0. Starting from version 1.3.0, zend-expressive-fastroute comes with support for FastRoute native dispatch data caching. Enabling this feature requires changes to your configuration. Typically, router configuration occurs in config/autoload/routes.global.php ; as such, we will reference that file when indicating configuration changes. The changes required are: You will need to delegate creation of the router instance to a new factory. You will need to add a new configuration entry, $config['router']['fastroute'] . The options in this entry will be used by the factory to build the router instance in order to toggle caching support and to specify a custom cache file. As an example: // File config/autoload/routes.global.php return [ 'dependencies' => [ //.. 'invokables' => [ /* ... */ // Comment out or remove the following line: // Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouter::class, /* ... */ ], 'factories' => [ /* ... */ // Add this line; the specified factory now creates the router instance: Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouterFactory::class, /* ... */ ], ], // Add the following to enable caching support: 'router' => [ 'fastroute' => [ // Enable caching support: 'cache_enabled' => true, // Optional (but recommended) cache file path: 'cache_file' => 'data/cache/fastroute.php.cache', ], ], 'routes' => [ /* ... */ ], ] The FastRoute-specific caching options are as follows: cache_enabled (bool) is used to toggle caching support. It's advisable to enable caching in a production environment and leave it disabled for the development environment. Commenting or omitting this option is equivalent to having it set to false . We recommend enabling it in config/autoload/routes.global.php , and, in development, disabling it within config/autoload/routes.local.php or config/autoload/local.php . cache_file (string) is an optional parameter that represents the path of the dispatch data cache file. It can be provided as an absolute file path or as a path relative to the zend-expressive working directory. It defaults to data/cache/fastroute.php.cache , where data/cache/ is the cache directory defined within the zend-expressive skeleton application. An explicit absolute file path is recommended since the php include construct will skip searching the include_path and the current directory. If you choose a custom path, make sure that the directory exists and is writable by the owner of the PHP process. As with any other zend-expressive cached configuration, you will need to purge this file in order to enable any newly added route when FastRoute caching is enabled.","title":"Using FastRoute"},{"location":"v1/features/router/fast-route/#using-fastroute","text":"FastRoute provides a number of different combinations for how to both parse routes and match incoming requests against them. Internally, we use the standard route parser ( FastRoute\\RouterParser\\Std ) to parse routes, a RouteCollector to collect them, and the \"Group Count Based\" dispatcher to match incoming requests against routes. If you wish to use a different combination \u2014 e.g., to use the Group Position Based route matcher \u2014 you will need to create your own instances and inject them into the Zend\\Expressive\\Router\\FastRouteRouter class, at instantiation. The FastRouteRouter bridge class accepts two arguments at instantiation: A FastRoute\\RouteCollector instance A callable that will return a FastRoute\\Dispatcher\\RegexBasedAbstract instance. Injection can be done either programmatically or via a factory to use in conjunction with your container instance.","title":"Using FastRoute"},{"location":"v1/features/router/fast-route/#installing-fastroute","text":"To use FastRoute, you will first need to install the FastRoute integration: $ composer require zendframework/zend-expressive-fastroute","title":"Installing FastRoute"},{"location":"v1/features/router/fast-route/#quick-start","text":"At its simplest, you can instantiate a Zend\\Expressive\\Router\\FastRouteRouter instance with no arguments; it will create the underlying FastRoute objects required and compose them for you: use Zend\\Expressive\\Router\\FastRouteRouter; $router = new FastRouteRouter();","title":"Quick Start"},{"location":"v1/features/router/fast-route/#programmatic-creation","text":"If you need greater control over the FastRoute setup and configuration, you can create the instances necessary and inject them into Zend\\Expressive\\Router\\FastRouteRouter during instantiation. To do so, you will need to setup your RouteCollector instance and/or optionally callable to return your RegexBasedAbstract instance manually, inject them in your Zend\\Expressive\\Router\\FastRouteRouter instance, and inject use that when creating your Application instance. <?php use FastRoute; use FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher; use FastRoute\\RouteCollector; use FastRoute\\RouteGenerator; use FastRoute\\RouteParser\\Std as RouteParser; use Zend\\Expressive\\AppFactory; use Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge; $fastRoute = new RouteCollector( new RouteParser(), new RouteGenerator() ); $getDispatcher = function ($data) { return new FastRouteDispatcher($data); }; $router = new FastRouteBridge($fastRoute, $getDispatcher); // First argument is the container to use, if not using the default; // second is the router. $app = AppFactory::create(null, $router);","title":"Programmatic Creation"},{"location":"v1/features/router/fast-route/#factory-driven-creation","text":"We recommend using an Inversion of Control container for your applications; as such, in this section we will demonstrate two strategies for creating your FastRoute implementation.","title":"Factory-Driven Creation"},{"location":"v1/features/router/interface/","text":"Routing Interface Expressive defines Zend\\Expressive\\Router\\RouterInterface , which can be injected into and consumed by Zend\\Expressive\\Application in order to provide dynamic routing capabilities to middleware. The interface serves as an abstraction to allow routers with varying capabilities to be used with an application. The interface is defined as follows: namespace Zend\\Expressive\\Router; use Psr\\Http\\Message\\ServerRequestInterface as Request; interface RouterInterface { /** * Add a route. * * This method adds a route against which the underlying implementation may * match. Implementations MUST aggregate route instances, but MUST NOT use * the details to inject the underlying router until `match()` and/or * `generateUri()` is called. This is required to allow consumers to * modify route instances before matching (e.g., to provide route options, * inject a name, etc.). * * The method MUST raise Exception\\RuntimeException if called after either `match()` * or `generateUri()` have already been called, to ensure integrity of the * router between invocations of either of those methods. * * @param Route $route * @throws Exception\\RuntimeException when called after match() or * generateUri() have been called. */ public function addRoute(Route $route); /** * Match a request against the known routes. * * Implementations will aggregate required information from the provided * request instance, and pass them to the underlying router implementation; * when done, they will then marshal a `RouteResult` instance indicating * the results of the matching operation and return it to the caller. * * @param Request $request * @return RouteResult */ public function match(Request $request); /** * Generate a URI from the named route. * * Takes the named route and any substitutions, and attempts to generate a * URI from it. * * @see https://github.com/auraphp/Aura.Router#generating-a-route-path * @see http://framework.zend.com/manual/current/en/modules/zend.mvc.routing.html * @param string $name * @param array $substitutions * @return string * @throws Exception\\RuntimeException if unable to generate the given URI. */ public function generateUri($name, array $substitutions = []); } Developers may create and use their own implementations. We recommend registering your implementation as the service Zend\\Expressive\\Router\\RouterInterface in your container to ensure other factories provided by zend-expressive will receive your custom service. Implementors should also read the following sections detailing the Route and RouteResult classes, to ensure that their implementations interoperate correctly. Routes Routes are defined via Zend\\Expressive\\Router\\Route , and aggregate the following information: Path to match. Middleware to use when the route is matched. This may be a callable or a service name resolving to middleware. HTTP methods allowed for the route; if none are provided, all are assumed. Optionally, a name by which to reference the route. The Route class has the following signature: namespace Zend\\Expressive\\Router; class Route { const HTTP_METHOD_ANY = 0xff; const HTTP_METHOD_SEPARATOR = ':'; /** * @param string $path Path to match. * @param string|callable $middleware Middleware to use when this route is matched. * @param int|array Allowed HTTP methods; defaults to HTTP_METHOD_ANY. * @param string|null $name the route name * @throws Exception\\InvalidArgumentException for invalid path type. * @throws Exception\\InvalidArgumentException for invalid middleware type. * @throws Exception\\InvalidArgumentException for any invalid HTTP method names. */ public function __construct($path, $middleware, $methods = self::HTTP_METHOD_ANY, $name = null); /** * @return string */ public function getPath(); /** * Set the route name. * * @param string $name */ public function setName($name); /** * @return string */ public function getName(); /** * @return string|callable */ public function getMiddleware(); /** * @return int|string[] Returns HTTP_METHOD_ANY or array of allowed methods. */ public function getAllowedMethods(); /** * Indicate whether the specified method is allowed by the route. * * @param string $method HTTP method to test. * @return bool */ public function allowsMethod($method); /** * @param array $options */ public function setOptions(array $options); /** * @return array */ public function getOptions(); } Typically, developers will use Zend\\Expressive\\Application::route() (or one of the HTTP-specific routing methods) to create routes, and will not need to interact with Route instances. However, that method can also accept Route instances, allowing more flexibility in defining and configuring them. Matching and RouteResults Internally, Zend\\Expressive\\Application calls on RouterInterface::match() , passing it the current request instance. This allows implementations to pull what they may need from the request in order to perform their routing logic; for example, they may need the request method, the URI path, the value of the HTTPS server variable, etc. Implementations are expected to return a Zend\\Expressive\\Router\\RouteResult instance, which the routing middleware then uses to determine if routing succeeded. In the event of success, it will pull any matched parameters from the result and inject them as request attributes, and then pull the matched middleware and execute it. In the case of failure, it will determine if the failure was due to inability to match, or usage of a disallowed HTTP method; in the former case, it proceeds to the next middleware in the stack, and in the latter, returns a 405 response. The RouteResult signature is as follows: namespace Zend\\Expressive\\Router; class RouteResult { /** * Create an instance representing a route success. * * @param string $name Name of matched route. * @param callable|string $middleware Middleware associated with the * matched route. * @param array $params Parameters associated with the matched route. * @return static */ public static function fromRouteMatch($name, $middleware, array $params); /** * Create an instance representing a route failure. * * @param null|int|array $methods HTTP methods allowed for the current URI, if any * @return static */ public static function fromRouteFailure($methods = null); /** * Does the result represent successful routing? * * @return bool */ public function isSuccess(); /** * Retrieve the matched route name, if possible. * * If this result represents a failure, return false; otherwise, return the * matched route name. * * @return string */ public function getMatchedRouteName(); /** * Retrieve the matched middleware, if possible. * * @return false|callable|string Returns false if the result represents a * failure; otherwise, a callable or a string service name. */ public function getMatchedMiddleware(); /** * Returns the matched params. * * Guaranteed to return an array, even if it is simply empty. * * @return array */ public function getMatchedParams(); /** * Is this a routing failure result? * * @return bool */ public function isFailure(); /** * Does the result represent failure to route due to HTTP method? * * @return bool */ public function isMethodFailure(); /** * Retrieve the allowed methods for the route failure. * * @return string[] HTTP methods allowed */ public function getAllowedMethods(); } Typically, only those implementing routers will interact with this class.","title":"Routing Interface"},{"location":"v1/features/router/interface/#routing-interface","text":"Expressive defines Zend\\Expressive\\Router\\RouterInterface , which can be injected into and consumed by Zend\\Expressive\\Application in order to provide dynamic routing capabilities to middleware. The interface serves as an abstraction to allow routers with varying capabilities to be used with an application. The interface is defined as follows: namespace Zend\\Expressive\\Router; use Psr\\Http\\Message\\ServerRequestInterface as Request; interface RouterInterface { /** * Add a route. * * This method adds a route against which the underlying implementation may * match. Implementations MUST aggregate route instances, but MUST NOT use * the details to inject the underlying router until `match()` and/or * `generateUri()` is called. This is required to allow consumers to * modify route instances before matching (e.g., to provide route options, * inject a name, etc.). * * The method MUST raise Exception\\RuntimeException if called after either `match()` * or `generateUri()` have already been called, to ensure integrity of the * router between invocations of either of those methods. * * @param Route $route * @throws Exception\\RuntimeException when called after match() or * generateUri() have been called. */ public function addRoute(Route $route); /** * Match a request against the known routes. * * Implementations will aggregate required information from the provided * request instance, and pass them to the underlying router implementation; * when done, they will then marshal a `RouteResult` instance indicating * the results of the matching operation and return it to the caller. * * @param Request $request * @return RouteResult */ public function match(Request $request); /** * Generate a URI from the named route. * * Takes the named route and any substitutions, and attempts to generate a * URI from it. * * @see https://github.com/auraphp/Aura.Router#generating-a-route-path * @see http://framework.zend.com/manual/current/en/modules/zend.mvc.routing.html * @param string $name * @param array $substitutions * @return string * @throws Exception\\RuntimeException if unable to generate the given URI. */ public function generateUri($name, array $substitutions = []); } Developers may create and use their own implementations. We recommend registering your implementation as the service Zend\\Expressive\\Router\\RouterInterface in your container to ensure other factories provided by zend-expressive will receive your custom service. Implementors should also read the following sections detailing the Route and RouteResult classes, to ensure that their implementations interoperate correctly.","title":"Routing Interface"},{"location":"v1/features/router/interface/#routes","text":"Routes are defined via Zend\\Expressive\\Router\\Route , and aggregate the following information: Path to match. Middleware to use when the route is matched. This may be a callable or a service name resolving to middleware. HTTP methods allowed for the route; if none are provided, all are assumed. Optionally, a name by which to reference the route. The Route class has the following signature: namespace Zend\\Expressive\\Router; class Route { const HTTP_METHOD_ANY = 0xff; const HTTP_METHOD_SEPARATOR = ':'; /** * @param string $path Path to match. * @param string|callable $middleware Middleware to use when this route is matched. * @param int|array Allowed HTTP methods; defaults to HTTP_METHOD_ANY. * @param string|null $name the route name * @throws Exception\\InvalidArgumentException for invalid path type. * @throws Exception\\InvalidArgumentException for invalid middleware type. * @throws Exception\\InvalidArgumentException for any invalid HTTP method names. */ public function __construct($path, $middleware, $methods = self::HTTP_METHOD_ANY, $name = null); /** * @return string */ public function getPath(); /** * Set the route name. * * @param string $name */ public function setName($name); /** * @return string */ public function getName(); /** * @return string|callable */ public function getMiddleware(); /** * @return int|string[] Returns HTTP_METHOD_ANY or array of allowed methods. */ public function getAllowedMethods(); /** * Indicate whether the specified method is allowed by the route. * * @param string $method HTTP method to test. * @return bool */ public function allowsMethod($method); /** * @param array $options */ public function setOptions(array $options); /** * @return array */ public function getOptions(); } Typically, developers will use Zend\\Expressive\\Application::route() (or one of the HTTP-specific routing methods) to create routes, and will not need to interact with Route instances. However, that method can also accept Route instances, allowing more flexibility in defining and configuring them.","title":"Routes"},{"location":"v1/features/router/interface/#matching-and-routeresults","text":"Internally, Zend\\Expressive\\Application calls on RouterInterface::match() , passing it the current request instance. This allows implementations to pull what they may need from the request in order to perform their routing logic; for example, they may need the request method, the URI path, the value of the HTTPS server variable, etc. Implementations are expected to return a Zend\\Expressive\\Router\\RouteResult instance, which the routing middleware then uses to determine if routing succeeded. In the event of success, it will pull any matched parameters from the result and inject them as request attributes, and then pull the matched middleware and execute it. In the case of failure, it will determine if the failure was due to inability to match, or usage of a disallowed HTTP method; in the former case, it proceeds to the next middleware in the stack, and in the latter, returns a 405 response. The RouteResult signature is as follows: namespace Zend\\Expressive\\Router; class RouteResult { /** * Create an instance representing a route success. * * @param string $name Name of matched route. * @param callable|string $middleware Middleware associated with the * matched route. * @param array $params Parameters associated with the matched route. * @return static */ public static function fromRouteMatch($name, $middleware, array $params); /** * Create an instance representing a route failure. * * @param null|int|array $methods HTTP methods allowed for the current URI, if any * @return static */ public static function fromRouteFailure($methods = null); /** * Does the result represent successful routing? * * @return bool */ public function isSuccess(); /** * Retrieve the matched route name, if possible. * * If this result represents a failure, return false; otherwise, return the * matched route name. * * @return string */ public function getMatchedRouteName(); /** * Retrieve the matched middleware, if possible. * * @return false|callable|string Returns false if the result represents a * failure; otherwise, a callable or a string service name. */ public function getMatchedMiddleware(); /** * Returns the matched params. * * Guaranteed to return an array, even if it is simply empty. * * @return array */ public function getMatchedParams(); /** * Is this a routing failure result? * * @return bool */ public function isFailure(); /** * Does the result represent failure to route due to HTTP method? * * @return bool */ public function isMethodFailure(); /** * Retrieve the allowed methods for the route failure. * * @return string[] HTTP methods allowed */ public function getAllowedMethods(); } Typically, only those implementing routers will interact with this class.","title":"Matching and RouteResults"},{"location":"v1/features/router/intro/","text":"Routing One fundamental feature of zend-expressive is that it provides mechanisms for implementing dynamic routing, a feature required in most modern web applications. As an example, you may want to allow matching both a resource, as well as individual items of that resource: /books might return a collection of books /books/zend-expressive might return the individual book identified by \"zend-expressive\". Expressive does not provide routing on its own; you must choose a routing adapter that implements Zend\\Expressive\\Router\\RouterInterface and provide it to the Application instance. This allows you to choose the router with the capabilities that best match your own needs, while still providing a common abstraction for defining and aggregating routes and their related middleware. Retrieving matched parameters Routing enables the ability to match dynamic path segments (or other criteria). Typically, you will want access to the values matched. The routing middleware injects any matched parameters as returned by the underlying router into the request as attributes . In the example above, let's assume the route was defined as /books/:id , where id is the name of the dynamic segment. This means that in the middleware invoked for this route, you can fetch the id attribute to discover what was matched: $id = $request->getAttribute('id'); Retrieving the matched route When routing is successful, the routing middleware injects a Zend\\Expressive\\Router\\RouteResult instance as a request attribute, using that class name as the attribute name. The RouteResult instance provides you access to the following: The matched route name, via $result->getMatchedRouteName() . The matched middleware, via $result->getMatchedMiddleware() . Matched parameters, via $result->getMatchedParams() (as noted above, these are also each injected as discrete request attributes). Allowed HTTP methods, via $result->getAllowedMethods() . As an example, you could use middleware similar to the following to return a 403 response if routing was successful, but no Authorization header is present: use Zend\\Diactoros\\Response\\EmptyResponse; use Zend\\Expressive\\Router\\RouteResult; function ($request, $response, $next) use ($routesRequiringAuthorization, $validator) { if (! ($result = $request->getAttribute(RouteResult::class, false))) { // No route matched; delegate to next middleware return $next($request, $response); } if (! in_array($result->getMatchedRouteName(), $routesRequiringAuthorization, true)) { // Not a route requiring authorization return $next($request, $response); } $header = $request->getHeaderLine('Authorization'); if (! $validator($header)) { return new EmptyResponse(403); } return $next($request, $response); } Note that the first step is to determine if we have a RouteResult ; if we do not have one, we should either delegate to the next middleware, or return some sort of response (generally a 404). In the case of Expressive, a later middleware will generate the 404 response for us, so we can safely delegate. URI generation Because routers have knowledge of the various paths they can match, they are also typically used within applications to generate URIs to other application resources. Expressive provides this capability in the RouterInterface , either delegating to the underlying router implementations or providing a compatible implementation of its own. At it's most basic level, you call the generateUri() method with a route name and any substitutions you want to make: $uri = $router->generateUri('book', ['id' => 'zend-expressive']); Supported implementations Expressive currently ships with adapters for the following routers: Aura.Router FastRoute zend-mvc Router","title":"Introduction"},{"location":"v1/features/router/intro/#routing","text":"One fundamental feature of zend-expressive is that it provides mechanisms for implementing dynamic routing, a feature required in most modern web applications. As an example, you may want to allow matching both a resource, as well as individual items of that resource: /books might return a collection of books /books/zend-expressive might return the individual book identified by \"zend-expressive\". Expressive does not provide routing on its own; you must choose a routing adapter that implements Zend\\Expressive\\Router\\RouterInterface and provide it to the Application instance. This allows you to choose the router with the capabilities that best match your own needs, while still providing a common abstraction for defining and aggregating routes and their related middleware.","title":"Routing"},{"location":"v1/features/router/intro/#retrieving-matched-parameters","text":"Routing enables the ability to match dynamic path segments (or other criteria). Typically, you will want access to the values matched. The routing middleware injects any matched parameters as returned by the underlying router into the request as attributes . In the example above, let's assume the route was defined as /books/:id , where id is the name of the dynamic segment. This means that in the middleware invoked for this route, you can fetch the id attribute to discover what was matched: $id = $request->getAttribute('id');","title":"Retrieving matched parameters"},{"location":"v1/features/router/intro/#retrieving-the-matched-route","text":"When routing is successful, the routing middleware injects a Zend\\Expressive\\Router\\RouteResult instance as a request attribute, using that class name as the attribute name. The RouteResult instance provides you access to the following: The matched route name, via $result->getMatchedRouteName() . The matched middleware, via $result->getMatchedMiddleware() . Matched parameters, via $result->getMatchedParams() (as noted above, these are also each injected as discrete request attributes). Allowed HTTP methods, via $result->getAllowedMethods() . As an example, you could use middleware similar to the following to return a 403 response if routing was successful, but no Authorization header is present: use Zend\\Diactoros\\Response\\EmptyResponse; use Zend\\Expressive\\Router\\RouteResult; function ($request, $response, $next) use ($routesRequiringAuthorization, $validator) { if (! ($result = $request->getAttribute(RouteResult::class, false))) { // No route matched; delegate to next middleware return $next($request, $response); } if (! in_array($result->getMatchedRouteName(), $routesRequiringAuthorization, true)) { // Not a route requiring authorization return $next($request, $response); } $header = $request->getHeaderLine('Authorization'); if (! $validator($header)) { return new EmptyResponse(403); } return $next($request, $response); } Note that the first step is to determine if we have a RouteResult ; if we do not have one, we should either delegate to the next middleware, or return some sort of response (generally a 404). In the case of Expressive, a later middleware will generate the 404 response for us, so we can safely delegate.","title":"Retrieving the matched route"},{"location":"v1/features/router/intro/#uri-generation","text":"Because routers have knowledge of the various paths they can match, they are also typically used within applications to generate URIs to other application resources. Expressive provides this capability in the RouterInterface , either delegating to the underlying router implementations or providing a compatible implementation of its own. At it's most basic level, you call the generateUri() method with a route name and any substitutions you want to make: $uri = $router->generateUri('book', ['id' => 'zend-expressive']);","title":"URI generation"},{"location":"v1/features/router/intro/#supported-implementations","text":"Expressive currently ships with adapters for the following routers: Aura.Router FastRoute zend-mvc Router","title":"Supported implementations"},{"location":"v1/features/router/piping/","text":"Routing vs Piping Expressive provides two mechanisms for adding middleware to your application: piping, which is a foundation feature of the underlying zend-stratigility implementation. routing, which is an additional feature provided by zend-expressive. Piping zend-stratigility provides a mechanism termed piping for composing middleware in an application. When you pipe middleware to the application, it is added to a queue, and dequeued in order until a middleware returns a response instance. If none ever returns a response instance, execution is delegated to a \"final handler\", which determines whether or not to return an error, and, if so, what kind of error to return. Stratigility also allows you to segregate piped middleware to specific paths. As an example: $app->pipe('/api', $apiMiddleware); will execute $apiMiddleware only if the path matches /api ; otherwise, it will skip over that middleware. This path segregation, however, is limited: it will only match literal paths. This is done purposefully, to provide excellent baseline performance, and to prevent feature creep in the library. Expressive uses and exposes piping to users, with one addition: middleware may be specified by service name, and zend-expressive will lazy-load the service only when the middleware is invoked . In order to accomplish the lazy-loading, zend-expressive wraps the calls to fetch the middleware from the container and to dispatch that middleware inside a closure. This poses a problem for error handling middleware, however, as zend-stratigility identifies error handling middleware by its arity (number of function arguments); as such, zend-expressive defines an additional method for piping service-driven error handling middleware, pipeErrorHandler() . The method has the same signature as pipe() : // Without a path: $app->pipeErrorHandler('error handler service name'); // Specific to a path: $app->pipeErrorHandler('/api', 'error handler service name'); This method will return a closure using the error middleware signature. Routing Routing is the process of discovering values from the incoming request based on defined criteria. That criteria might look like: /book/:id (ZF2) /book/{id} (Aura.Router) /book/{id:\\d+} (FastRoute) In each of the above, if the router determines that the request matches the criteria, it will indicate: the route that matched the id parameter was matched, and the value matched Most routers allow you to define arbitrarily complex rules, and many even allow you to define: default values for unmatched parameters criteria for evaluating a match (such as a regular expression) additional criteria to meet (such as SSL usage, allowed query string variables, etc.) As such, routing is more powerful than the literal path matching used when piping, but it is also more costly (though routers such as FastRoute largely make such performance issues moot). When to Pipe In Expressive, we recommend that you pipe middleware in the following circumstances: It should (potentially) run on every execution. Examples for such usage include: Logging requests Performing content negotiation Handling cookies Error handling. Typically these should be piped after any normal middleware. Application segregation. You can write re-usable middleware, potentially even based off of Expressive, that contains its own routing logic, and compose it such that it only executes if it matches a sub-path. When to Route Use routing when: Your middleware is reacting to a given path. You want to use dynamic routing. You want to restrict usage of middleware to specific HTTP methods. You want to be able to generate URIs to your middleware. The above cover most use cases; in other words, most middleware should be added to the application as routed middleware . Controlling middleware execution order As noted in the earlier section on piping, piped middleware is queued , meaning it has a FIFO (\"first in, first out\") execution order. Additionally, zend-expressive's routing capabilities are themselves implemented as piped middleware. As such, if you programmatically configure the router and add routes without using Application::route() , you may run into issues with the order in which piped middleware (middleware added to the application via the pipe() method) is executed. To ensure that everything executes in the correct order, you can call Application::pipeRouteMiddleware() at any time to pipe it to the application. As an example, after you have created your application instance: $app->pipe($middlewareToExecuteFirst); $app->pipeRouteMiddleware(); $app->pipe($errorMiddleware); If you fail to add any routes via Application::route() or to call Application::pipeRouteMiddleware() , the routing middleware will be called when executing the application. This means that it will be last in the middleware pipeline, which means that if you registered any error middleware, it can never be invoked. To sum: Pipe middleware to execute on every request before routing any middleware and/or before calling Application::pipeRouteMiddleware() . Pipe error handling middleware after defining routes and/or after calling Application::pipeRouteMiddleware() . If you use the provided Zend\\Expressive\\Container\\ApplicationFactory for retrieving your Application instance, you can do this by defining pre- and post-pipeline middleware, and the factory will ensure everything is registered correctly.","title":"Routing vs Piping"},{"location":"v1/features/router/piping/#routing-vs-piping","text":"Expressive provides two mechanisms for adding middleware to your application: piping, which is a foundation feature of the underlying zend-stratigility implementation. routing, which is an additional feature provided by zend-expressive.","title":"Routing vs Piping"},{"location":"v1/features/router/piping/#piping","text":"zend-stratigility provides a mechanism termed piping for composing middleware in an application. When you pipe middleware to the application, it is added to a queue, and dequeued in order until a middleware returns a response instance. If none ever returns a response instance, execution is delegated to a \"final handler\", which determines whether or not to return an error, and, if so, what kind of error to return. Stratigility also allows you to segregate piped middleware to specific paths. As an example: $app->pipe('/api', $apiMiddleware); will execute $apiMiddleware only if the path matches /api ; otherwise, it will skip over that middleware. This path segregation, however, is limited: it will only match literal paths. This is done purposefully, to provide excellent baseline performance, and to prevent feature creep in the library. Expressive uses and exposes piping to users, with one addition: middleware may be specified by service name, and zend-expressive will lazy-load the service only when the middleware is invoked . In order to accomplish the lazy-loading, zend-expressive wraps the calls to fetch the middleware from the container and to dispatch that middleware inside a closure. This poses a problem for error handling middleware, however, as zend-stratigility identifies error handling middleware by its arity (number of function arguments); as such, zend-expressive defines an additional method for piping service-driven error handling middleware, pipeErrorHandler() . The method has the same signature as pipe() : // Without a path: $app->pipeErrorHandler('error handler service name'); // Specific to a path: $app->pipeErrorHandler('/api', 'error handler service name'); This method will return a closure using the error middleware signature.","title":"Piping"},{"location":"v1/features/router/piping/#routing","text":"Routing is the process of discovering values from the incoming request based on defined criteria. That criteria might look like: /book/:id (ZF2) /book/{id} (Aura.Router) /book/{id:\\d+} (FastRoute) In each of the above, if the router determines that the request matches the criteria, it will indicate: the route that matched the id parameter was matched, and the value matched Most routers allow you to define arbitrarily complex rules, and many even allow you to define: default values for unmatched parameters criteria for evaluating a match (such as a regular expression) additional criteria to meet (such as SSL usage, allowed query string variables, etc.) As such, routing is more powerful than the literal path matching used when piping, but it is also more costly (though routers such as FastRoute largely make such performance issues moot).","title":"Routing"},{"location":"v1/features/router/piping/#when-to-pipe","text":"In Expressive, we recommend that you pipe middleware in the following circumstances: It should (potentially) run on every execution. Examples for such usage include: Logging requests Performing content negotiation Handling cookies Error handling. Typically these should be piped after any normal middleware. Application segregation. You can write re-usable middleware, potentially even based off of Expressive, that contains its own routing logic, and compose it such that it only executes if it matches a sub-path.","title":"When to Pipe"},{"location":"v1/features/router/piping/#when-to-route","text":"Use routing when: Your middleware is reacting to a given path. You want to use dynamic routing. You want to restrict usage of middleware to specific HTTP methods. You want to be able to generate URIs to your middleware. The above cover most use cases; in other words, most middleware should be added to the application as routed middleware .","title":"When to Route"},{"location":"v1/features/router/piping/#controlling-middleware-execution-order","text":"As noted in the earlier section on piping, piped middleware is queued , meaning it has a FIFO (\"first in, first out\") execution order. Additionally, zend-expressive's routing capabilities are themselves implemented as piped middleware. As such, if you programmatically configure the router and add routes without using Application::route() , you may run into issues with the order in which piped middleware (middleware added to the application via the pipe() method) is executed. To ensure that everything executes in the correct order, you can call Application::pipeRouteMiddleware() at any time to pipe it to the application. As an example, after you have created your application instance: $app->pipe($middlewareToExecuteFirst); $app->pipeRouteMiddleware(); $app->pipe($errorMiddleware); If you fail to add any routes via Application::route() or to call Application::pipeRouteMiddleware() , the routing middleware will be called when executing the application. This means that it will be last in the middleware pipeline, which means that if you registered any error middleware, it can never be invoked. To sum: Pipe middleware to execute on every request before routing any middleware and/or before calling Application::pipeRouteMiddleware() . Pipe error handling middleware after defining routes and/or after calling Application::pipeRouteMiddleware() . If you use the provided Zend\\Expressive\\Container\\ApplicationFactory for retrieving your Application instance, you can do this by defining pre- and post-pipeline middleware, and the factory will ensure everything is registered correctly.","title":"Controlling middleware execution order"},{"location":"v1/features/router/uri-generation/","text":"URI Generation One aspect of the Zend\\Expressive\\Router\\RouterInterface is that it provides a generateUri() method. This method accepts a route name, and optionally an associative array of substitutions to use in the generated URI (e.g., if the URI has any named placeholders). Naming routes By default, routes use a combination of the path and HTTP methods supported as the name: If you call route() with no HTTP methods, the name is the literal path with no changes. php $app->route('/foo', $middleware); // \"foo\" If you call get() , post() , put() , patch() , or delete() , the name will be the literal path, followed by a caret ( ^ ), followed by the uppercase HTTP method name: php $app->get('/foo', $middleware); // \"foo^GET\" Alternately, these methods return a Route instance, and you can set the name on it: php $app->get('/foo', $middleware)->setName('foo'); // \"foo\" If you call route() and specify a list of HTTP methods accepted, the name will be the literal path, followed by a caret ( ^ ), followed by a colon ( : )-separated list of the uppercase HTTP method names, in the order in which they were added. php $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\" Like the HTTP-specific methods, route() also returns a Route instance, and you can set the name on it: php $route = $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\" $route->setName('foo'); // \"foo\" Clearly, this can become difficult to remember. As such, Expressive offers the ability to specify a custom string for the route name as an additional, optional argument to any of the above: $app->route('/foo', $middleware, 'foo'); // 'foo' $app->get('/foo/:id', $middleware, 'foo-item'); // 'foo-item' $app->route('/foo', $middleware, ['GET', 'POST'], 'foo-collection'); // 'foo-collection' As noted above, these methods also return Route instances, allowing you to set the name after-the-fact; this is particularly useful with the route() method, where you may want to omit the HTTP methods if any HTTP method is allowed: $app->route('/foo', $middleware)->setName('foo'); // 'foo' We recommend that if you plan on generating URIs for given routes, you provide a custom name. Generating URIs Once you know the name of a URI you wish to generate, you can do so from the router instance: $uri = $router->generateUri('foo-item', ['id' => 'bar']); // \"/foo/bar\" You can omit the second argument if no substitutions are necessary. Compose the router For this to work, you'll need to compose the router instance in any class that requires the URI generation facility. Inject the Zend\\Expressive\\Router\\RouterInterface service in these situations.","title":"URI Generation"},{"location":"v1/features/router/uri-generation/#uri-generation","text":"One aspect of the Zend\\Expressive\\Router\\RouterInterface is that it provides a generateUri() method. This method accepts a route name, and optionally an associative array of substitutions to use in the generated URI (e.g., if the URI has any named placeholders).","title":"URI Generation"},{"location":"v1/features/router/uri-generation/#naming-routes","text":"By default, routes use a combination of the path and HTTP methods supported as the name: If you call route() with no HTTP methods, the name is the literal path with no changes. php $app->route('/foo', $middleware); // \"foo\" If you call get() , post() , put() , patch() , or delete() , the name will be the literal path, followed by a caret ( ^ ), followed by the uppercase HTTP method name: php $app->get('/foo', $middleware); // \"foo^GET\" Alternately, these methods return a Route instance, and you can set the name on it: php $app->get('/foo', $middleware)->setName('foo'); // \"foo\" If you call route() and specify a list of HTTP methods accepted, the name will be the literal path, followed by a caret ( ^ ), followed by a colon ( : )-separated list of the uppercase HTTP method names, in the order in which they were added. php $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\" Like the HTTP-specific methods, route() also returns a Route instance, and you can set the name on it: php $route = $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\" $route->setName('foo'); // \"foo\" Clearly, this can become difficult to remember. As such, Expressive offers the ability to specify a custom string for the route name as an additional, optional argument to any of the above: $app->route('/foo', $middleware, 'foo'); // 'foo' $app->get('/foo/:id', $middleware, 'foo-item'); // 'foo-item' $app->route('/foo', $middleware, ['GET', 'POST'], 'foo-collection'); // 'foo-collection' As noted above, these methods also return Route instances, allowing you to set the name after-the-fact; this is particularly useful with the route() method, where you may want to omit the HTTP methods if any HTTP method is allowed: $app->route('/foo', $middleware)->setName('foo'); // 'foo' We recommend that if you plan on generating URIs for given routes, you provide a custom name.","title":"Naming routes"},{"location":"v1/features/router/uri-generation/#generating-uris","text":"Once you know the name of a URI you wish to generate, you can do so from the router instance: $uri = $router->generateUri('foo-item', ['id' => 'bar']); // \"/foo/bar\" You can omit the second argument if no substitutions are necessary.","title":"Generating URIs"},{"location":"v1/features/router/zf2/","text":"Using the ZF2 Router zend-mvc provides a router implementation; for HTTP applications, the default used in ZF2 applications is Zend\\Mvc\\Router\\Http\\TreeRouteStack , which can compose a number of different routes of differing types in order to perform routing. The ZF2 bridge we provide, Zend\\Expressive\\Router\\ZendRouter , uses the TreeRouteStack , and injects Segment routes to it; these are in turn injected with Method routes, and a special \"method not allowed\" route at negative priority to enable us to distinguish between failure to match the path and failure to match the HTTP method. If you instantiate it with no arguments, it will create an empty TreeRouteStack . Thus, the simplest way to start with this router is: use Zend\\Expressive\\AppFactory; use Zend\\Expressive\\Router\\ZendRouter; $app = AppFactory::create(null, new ZendRouter()); The TreeRouteStack offers some unique features: Route \"prototypes\". These are essentially like child routes that must also match in order for a given route to match. These are useful for implementing functionality such as ensuring the request comes in over HTTPS, or over a specific subdomain. Base URL functionality. If a base URL is injected, comparisons will be relative to that URL. This is mostly unnecessary with Stratigility-based middleware, but could solve some edge cases. To specify these, you need access to the underlying TreeRouteStack instance, however, and the RouterInterface does not provide an accessor! The answer, then, is to use dependency injection. This can be done in two ways: programmatically, or via a factory to use in conjunction with your container instance. Installing the ZF2 Router To use the ZF2 router, you will need to install the zend-mvc router integration: $ composer require zendframework/zend-expressive-zendrouter Quick Start At its simplest, you can instantiate a Zend\\Expressive\\Router\\ZendRouter instance with no arguments; it will create the underlying zend-mvc routing objects required and compose them for you: use Zend\\Expressive\\Router\\ZendRouter; $router = new ZendRouter(); Programmatic Creation If you need greater control over the zend-mvc router setup and configuration, you can create the instances necessary and inject them into Zend\\Expressive\\Router\\ZendRouter during instantiation. use Zend\\Expressive\\AppFactory; use Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge; use Zend\\Mvc\\Router\\Http\\TreeRouteStack; $zendRouter = new TreeRouteStack(); $zendRouter->addPrototypes(/* ... */); $zendRouter->setBaseUrl(/* ... */); $router = new Zf2Bridge($zendRouter); // First argument is the container to use, if not using the default; // second is the router. $app = AppFactory::create(null, $router); Piping the route middleware As a reminder, you will need to ensure that middleware is piped in the order in which it needs to be executed; please see the section on \"Controlling middleware execution order\" in the piping documentation . This is particularly salient when defining routes before injecting the router in the application instance! Factory-Driven Creation We recommend using an Inversion of Control container for your applications; as such, in this section we will demonstrate two strategies for creating your zend-mvc router implementation. Basic Router If you don't need to provide any setup or configuration, you can simply instantiate and return an instance of Zend\\Expressive\\Router\\ZendRouter for the service name Zend\\Expressive\\Router\\RouterInterface . A factory would look like this: // in src/Application/Container/RouterFactory.php namespace Application\\Container; use Interop\\Container\\ContainerInterface; use Zend\\Expressive\\Router\\ZendRouter; class RouterFactory { /** * @param ContainerInterface $container * @return ZendRouter */ public function __invoke(ContainerInterface $container) { return new ZendRouter(); } } You would register this with zend-servicemanager using: $container->setFactory( 'Zend\\Expressive\\Router\\RouterInterface', 'Application\\Container\\RouterFactory' ); And in Pimple: $pimple['Zend\\Expressive\\Router\\RouterInterface'] = new Application\\Container\\RouterFactory(); For zend-servicemanager, you can omit the factory entirely, and register the class as an invokable: $container->setInvokableClass( 'Zend\\Expressive\\Router\\RouterInterface', 'Zend\\Expressive\\Router\\ZendRouter' ); Advanced Configuration If you want to provide custom setup or configuration, you can do so. In this example, we will be defining two factories: A factory to register as and generate an Zend\\Mvc\\Router\\Http\\TreeRouteStack instance. A factory registered as Zend\\Expressive\\Router\\RouterInterface , which creates and returns a Zend\\Expressive\\Router\\ZendRouter instance composing the Zend\\Mvc\\Router\\Http\\TreeRouteStack instance. Sound difficult? It's not; we've essentially done it above already! // in src/Application/Container/TreeRouteStackFactory.php: namespace Application\\Container; use Interop\\Container\\ContainerInterface; use Zend\\Http\\Mvc\\Router\\TreeRouteStack; class TreeRouteStackFactory { /** * @param ContainerInterface $container * @return TreeRouteStack */ public function __invoke(ContainerInterface $container) { $router = new TreeRouteStack(); $router->addPrototypes(/* ... */); $router->setBaseUrl(/* ... */); return $router; } } // in src/Application/Container/RouterFactory.php namespace Application\\Container; use Interop\\Container\\ContainerInterface; use Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge; class RouterFactory { /** * @param ContainerInterface $container * @return Zf2Bridge */ public function __invoke(ContainerInterface $container) { return new Zf2Bridge($container->get('Zend\\Mvc\\Router\\Http\\TreeRouteStack')); } } From here, you will need to register your factories with your IoC container. If you are using zend-servicemanager, this will look like: // Programmatically: use Zend\\ServiceManager\\ServiceManager; $container = new ServiceManager(); $container->addFactory( 'Zend\\Mvc\\Router\\Http\\TreeRouteStack', 'Application\\Container\\TreeRouteStackFactory' ); $container->addFactory( 'Zend\\Expressive\\Router\\RouterInterface', 'Application\\Container\\RouterFactory' ); // Alternately, via configuration: return [ 'factories' => [ 'Zend\\Mvc\\Router\\Http\\TreeRouteStack' => 'Application\\Container\\TreeRouteStackFactory', 'Zend\\Expressive\\Router\\RouterInterface' => 'Application\\Container\\RouterFactory', ], ]; For Pimple, configuration looks like: use Application\\Container\\TreeRouteStackFactory; use Application\\Container\\ZfRouterFactory; use Interop\\Container\\Pimple\\PimpleInterop; $container = new PimpleInterop(); $container['Zend\\Mvc\\Router\\Http\\TreeRouteStackFactory'] = new TreeRouteStackFactory(); $container['Zend\\Expressive\\Router\\RouterInterface'] = new RouterFactory();","title":"Using the ZF2 Router"},{"location":"v1/features/router/zf2/#using-the-zf2-router","text":"zend-mvc provides a router implementation; for HTTP applications, the default used in ZF2 applications is Zend\\Mvc\\Router\\Http\\TreeRouteStack , which can compose a number of different routes of differing types in order to perform routing. The ZF2 bridge we provide, Zend\\Expressive\\Router\\ZendRouter , uses the TreeRouteStack , and injects Segment routes to it; these are in turn injected with Method routes, and a special \"method not allowed\" route at negative priority to enable us to distinguish between failure to match the path and failure to match the HTTP method. If you instantiate it with no arguments, it will create an empty TreeRouteStack . Thus, the simplest way to start with this router is: use Zend\\Expressive\\AppFactory; use Zend\\Expressive\\Router\\ZendRouter; $app = AppFactory::create(null, new ZendRouter()); The TreeRouteStack offers some unique features: Route \"prototypes\". These are essentially like child routes that must also match in order for a given route to match. These are useful for implementing functionality such as ensuring the request comes in over HTTPS, or over a specific subdomain. Base URL functionality. If a base URL is injected, comparisons will be relative to that URL. This is mostly unnecessary with Stratigility-based middleware, but could solve some edge cases. To specify these, you need access to the underlying TreeRouteStack instance, however, and the RouterInterface does not provide an accessor! The answer, then, is to use dependency injection. This can be done in two ways: programmatically, or via a factory to use in conjunction with your container instance.","title":"Using the ZF2 Router"},{"location":"v1/features/router/zf2/#installing-the-zf2-router","text":"To use the ZF2 router, you will need to install the zend-mvc router integration: $ composer require zendframework/zend-expressive-zendrouter","title":"Installing the ZF2 Router"},{"location":"v1/features/router/zf2/#quick-start","text":"At its simplest, you can instantiate a Zend\\Expressive\\Router\\ZendRouter instance with no arguments; it will create the underlying zend-mvc routing objects required and compose them for you: use Zend\\Expressive\\Router\\ZendRouter; $router = new ZendRouter();","title":"Quick Start"},{"location":"v1/features/router/zf2/#programmatic-creation","text":"If you need greater control over the zend-mvc router setup and configuration, you can create the instances necessary and inject them into Zend\\Expressive\\Router\\ZendRouter during instantiation. use Zend\\Expressive\\AppFactory; use Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge; use Zend\\Mvc\\Router\\Http\\TreeRouteStack; $zendRouter = new TreeRouteStack(); $zendRouter->addPrototypes(/* ... */); $zendRouter->setBaseUrl(/* ... */); $router = new Zf2Bridge($zendRouter); // First argument is the container to use, if not using the default; // second is the router. $app = AppFactory::create(null, $router);","title":"Programmatic Creation"},{"location":"v1/features/router/zf2/#factory-driven-creation","text":"We recommend using an Inversion of Control container for your applications; as such, in this section we will demonstrate two strategies for creating your zend-mvc router implementation.","title":"Factory-Driven Creation"},{"location":"v1/features/template/interface/","text":"The Template Renderer Interface Expressive defines Zend\\Expressive\\Template\\TemplateRendererInterface , which can be injected into middleware in order to create templated response bodies. The interface is defined as follows: namespace Zend\\Expressive\\Template; interface TemplateRendererInterface { /** * Render a template, optionally with parameters. * * Implementations MUST support the `namespace::template` naming convention, * and allow omitting the filename extension. * * @param string $name * @param array|object $params * @return string */ public function render($name, $params = []); /** * Add a template path to the engine. * * Adds a template path, with optional namespace the templates in that path * provide. * * @param string $path * @param string $namespace */ public function addPath($path, $namespace = null); /** * Retrieve configured paths from the engine. * * @return TemplatePath[] */ public function getPaths(); /** * Add a default parameter to use with a template. * * Use this method to provide a default parameter to use when a template is * rendered. The parameter may be overridden by providing it when calling * `render()`, or by calling this method again with a null value. * * The parameter will be specific to the template name provided. To make * the parameter available to any template, pass the TEMPLATE_ALL constant * for the template name. * * If the default parameter existed previously, subsequent invocations with * the same template name and parameter name will overwrite. * * @param string $templateName Name of template to which the param applies; * use TEMPLATE_ALL to apply to all templates. * @param string $param Param name. * @param mixed $value */ public function addDefaultParam($templateName, $param, $value); } Namespaces Unfortunately, namespace syntax varies between different template engine implementations. As an example: Plates uses the syntax namespace::template . Twig uses the syntax @namespace/template . zend-view does not natively support namespaces, though custom resolvers can provide the functionality. To make different engines compatible, we require implementations to support the syntax namespace::template (where namespace:: is optional) when rendering. Additionally, we require that engines allow omitting the filename suffix. When using a TemplateRendererInterface implementation, feel free to use namespaced templates, and to omit the filename suffix; this will make your code portable and allow it to use alternate template engines. Paths Most template engines and implementations will require that you specify one or more paths to templates; these are then used when resolving a template name to the actual template. You may use the addPath() method to do so: $renderer->addPath('templates'); Template engines adapted for zend-expressive are also required to allow namespacing templates; when adding a path, you specify the template namespace that it fulfills, and the engine will only return a template from that path if the namespace provided matches the namespace for the path. // Resolves to a path registered with the namespace \"error\"; // this example is specific to the Plates engine. $content = $renderer->render('error::404'); You can provide a namespace when registering a path via an optional second argument: // Registers the \"error\" namespace to the path \"templates/error/\" $renderer->addPath('templates/error/', 'error'); Rendering To render a template, call the render() method. This method requires the name of a template as the first argument: $content = $renderer->render('foo'); You can specify a namespaced template using the syntax namespace::template ; the template segment of the template name may use additional directory separators when necessary. One key reason to use templates is to dynamically provide data to inject in the template. You may do so by passing either an associative array or an object as the second argument to render() : $content = $renderer->render('message', [ 'greeting' => 'Hello', 'recipient' => 'World', ]); It is up to the underlying template engine to determine how to perform the injections. Default params The TemplateRendererInterface defines the method addDefaultParam() . This method can be used to specify default parameters to use when rendering a template. The signature is: public function addDefaultParam($templateName, $param, $value) If you want a parameter to be used for every template, you can specify the constant TemplateRendererInterface::TEMPLATE_ALL for the $templateName parameter. When rendering, parameters are considered in the following order, with later items having precedence over earlier ones: Default parameters specified for all templates. Default parameters specified for the template specified at rendering. Parameters specified when rendering. As an example, if we did the following: $renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'foo', 'bar'); $renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'bar', 'baz'); $renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'baz', 'bat'); $renderer->addDefaultParam('example', 'foo', 'template default foo'); $renderer->addDefaultParam('example', 'bar', 'template default bar'); $content = $renderer->render('example', [ 'foo' => 'override', ]); Then we can expect the following substitutions will occur when rendering: References to the \"foo\" variable will contain \"override\". References to the \"bar\" variable will contain \"template default bar\". References to the \"baz\" variable will contain \"bat\". Support for default params The support for default params will often be renderer-specific. The reason is because the render() signature does not specify a type for $params , in order to allow passing alternative arguments such as view models. In such cases, the implementation will indicate its behavior when default parameters are specified, but a given $params argument does not support it. At the time of writing, each of the Plates, Twig, and zend-view implementations support the feature.","title":"Template Renderer Interface"},{"location":"v1/features/template/interface/#the-template-renderer-interface","text":"Expressive defines Zend\\Expressive\\Template\\TemplateRendererInterface , which can be injected into middleware in order to create templated response bodies. The interface is defined as follows: namespace Zend\\Expressive\\Template; interface TemplateRendererInterface { /** * Render a template, optionally with parameters. * * Implementations MUST support the `namespace::template` naming convention, * and allow omitting the filename extension. * * @param string $name * @param array|object $params * @return string */ public function render($name, $params = []); /** * Add a template path to the engine. * * Adds a template path, with optional namespace the templates in that path * provide. * * @param string $path * @param string $namespace */ public function addPath($path, $namespace = null); /** * Retrieve configured paths from the engine. * * @return TemplatePath[] */ public function getPaths(); /** * Add a default parameter to use with a template. * * Use this method to provide a default parameter to use when a template is * rendered. The parameter may be overridden by providing it when calling * `render()`, or by calling this method again with a null value. * * The parameter will be specific to the template name provided. To make * the parameter available to any template, pass the TEMPLATE_ALL constant * for the template name. * * If the default parameter existed previously, subsequent invocations with * the same template name and parameter name will overwrite. * * @param string $templateName Name of template to which the param applies; * use TEMPLATE_ALL to apply to all templates. * @param string $param Param name. * @param mixed $value */ public function addDefaultParam($templateName, $param, $value); }","title":"The Template Renderer Interface"},{"location":"v1/features/template/interface/#paths","text":"Most template engines and implementations will require that you specify one or more paths to templates; these are then used when resolving a template name to the actual template. You may use the addPath() method to do so: $renderer->addPath('templates'); Template engines adapted for zend-expressive are also required to allow namespacing templates; when adding a path, you specify the template namespace that it fulfills, and the engine will only return a template from that path if the namespace provided matches the namespace for the path. // Resolves to a path registered with the namespace \"error\"; // this example is specific to the Plates engine. $content = $renderer->render('error::404'); You can provide a namespace when registering a path via an optional second argument: // Registers the \"error\" namespace to the path \"templates/error/\" $renderer->addPath('templates/error/', 'error');","title":"Paths"},{"location":"v1/features/template/interface/#rendering","text":"To render a template, call the render() method. This method requires the name of a template as the first argument: $content = $renderer->render('foo'); You can specify a namespaced template using the syntax namespace::template ; the template segment of the template name may use additional directory separators when necessary. One key reason to use templates is to dynamically provide data to inject in the template. You may do so by passing either an associative array or an object as the second argument to render() : $content = $renderer->render('message', [ 'greeting' => 'Hello', 'recipient' => 'World', ]); It is up to the underlying template engine to determine how to perform the injections.","title":"Rendering"},{"location":"v1/features/template/intro/","text":"Templating By default, no middleware in Expressive is templated. We do not even provide a default templating engine, as the choice of templating engine is often very specific to the project and/or organization. We do, however, provide abstraction for templating via the interface Zend\\Expressive\\Template\\TemplateRendererInterface , which allows you to write middleware that is engine-agnostic. For Expressive, this means: All adapters MUST support template namespacing. Namespaces MUST be referenced using the notation namespace::template when rendering. Adapters MUST allow rendering templates that omit the extension; they will, of course, resolve to whatever default extension they require (or as configured). Adapters SHOULD allow passing an extension in the template name, but how that is handled is left up to the adapter. Adapters SHOULD abstract layout capabilities. Many templating systems provide this out of the box, or similar, compatible features such as template inheritance. This should be transparent to end-users; they should be able to simply render a template and assume it has the full content to return. In this documentation, we'll detail the features of this interface, the various implementations we provide, and how you can configure, inject, and consume templating in your middleware. We currently support: Plates Twig zend-view Each has an associated container factory; details are found in the factories documentation .","title":"Introduction"},{"location":"v1/features/template/intro/#templating","text":"By default, no middleware in Expressive is templated. We do not even provide a default templating engine, as the choice of templating engine is often very specific to the project and/or organization. We do, however, provide abstraction for templating via the interface Zend\\Expressive\\Template\\TemplateRendererInterface , which allows you to write middleware that is engine-agnostic. For Expressive, this means: All adapters MUST support template namespacing. Namespaces MUST be referenced using the notation namespace::template when rendering. Adapters MUST allow rendering templates that omit the extension; they will, of course, resolve to whatever default extension they require (or as configured). Adapters SHOULD allow passing an extension in the template name, but how that is handled is left up to the adapter. Adapters SHOULD abstract layout capabilities. Many templating systems provide this out of the box, or similar, compatible features such as template inheritance. This should be transparent to end-users; they should be able to simply render a template and assume it has the full content to return. In this documentation, we'll detail the features of this interface, the various implementations we provide, and how you can configure, inject, and consume templating in your middleware. We currently support: Plates Twig zend-view Each has an associated container factory; details are found in the factories documentation .","title":"Templating"},{"location":"v1/features/template/middleware/","text":"Templated Middleware The primary use case for templating is within middleware, to provide templated responses. To do this, you will: Inject an instance of Zend\\Expressive\\Template\\TemplateRendererInterface into your middleware. Potentially add paths to the templating instance. Render a template. Add the results of rendering to your response. Injecting a TemplateRendererInterface We encourage the use of dependency injection. As such, we recommend writing your middleware to accept the TemplateRendererInterface via either the constructor or a setter. As an example: namespace Acme\\Blog; use Zend\\Expressive\\Template\\TemplateRendererInterface; class EntryMiddleware { private $templateRenderer; public function __construct(TemplateRendererInterface $renderer) { $this->templateRenderer = $renderer; } public function __invoke($request, $response, $next) { // ... } } This will necessitate having a factory for your middleware: namespace Acme\\Blog\\Container; use Acme\\Blog\\EntryMiddleware; use Interop\\Container\\ContainerInterface; class EntryMiddlewareFactory { public function __invoke(ContainerInterface $container) { return new EntryMiddleware( $container->get('Zend\\Expressive\\Template\\TemplateRendererInterface') ); } } And, of course, you'll need to tell your container to use the factory; see the container documentation for more information on how you might accomplish that. Consuming templates Now that we have the templating engine injected into our middleware, we can consume it. Most often, we will want to render a template, optionally with substitutions to pass to it. This will typically look like the following: <?php namespace Acme\\Blog; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Template\\TemplateRendererInterface; class EntryMiddleware { private $templateRenderer; public function __construct(TemplateRendererInterface $renderer) { $this->templateRenderer = $renderer; } public function __invoke($request, $response, $next) { // do some work... return new HtmlResponse( $this->templateRenderer->render('blog::entry', [ 'entry' => $entry, ]) ); } } Alternately, you can write to the composed response: $response->getBody()->write($this->templateRenderer->render('blog::entry', [ 'entry' => $entry, ])); return $response;","title":"Templated Middleware"},{"location":"v1/features/template/middleware/#templated-middleware","text":"The primary use case for templating is within middleware, to provide templated responses. To do this, you will: Inject an instance of Zend\\Expressive\\Template\\TemplateRendererInterface into your middleware. Potentially add paths to the templating instance. Render a template. Add the results of rendering to your response.","title":"Templated Middleware"},{"location":"v1/features/template/middleware/#injecting-a-templaterendererinterface","text":"We encourage the use of dependency injection. As such, we recommend writing your middleware to accept the TemplateRendererInterface via either the constructor or a setter. As an example: namespace Acme\\Blog; use Zend\\Expressive\\Template\\TemplateRendererInterface; class EntryMiddleware { private $templateRenderer; public function __construct(TemplateRendererInterface $renderer) { $this->templateRenderer = $renderer; } public function __invoke($request, $response, $next) { // ... } } This will necessitate having a factory for your middleware: namespace Acme\\Blog\\Container; use Acme\\Blog\\EntryMiddleware; use Interop\\Container\\ContainerInterface; class EntryMiddlewareFactory { public function __invoke(ContainerInterface $container) { return new EntryMiddleware( $container->get('Zend\\Expressive\\Template\\TemplateRendererInterface') ); } } And, of course, you'll need to tell your container to use the factory; see the container documentation for more information on how you might accomplish that.","title":"Injecting a TemplateRendererInterface"},{"location":"v1/features/template/middleware/#consuming-templates","text":"Now that we have the templating engine injected into our middleware, we can consume it. Most often, we will want to render a template, optionally with substitutions to pass to it. This will typically look like the following: <?php namespace Acme\\Blog; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Template\\TemplateRendererInterface; class EntryMiddleware { private $templateRenderer; public function __construct(TemplateRendererInterface $renderer) { $this->templateRenderer = $renderer; } public function __invoke($request, $response, $next) { // do some work... return new HtmlResponse( $this->templateRenderer->render('blog::entry', [ 'entry' => $entry, ]) ); } } Alternately, you can write to the composed response: $response->getBody()->write($this->templateRenderer->render('blog::entry', [ 'entry' => $entry, ])); return $response;","title":"Consuming templates"},{"location":"v1/features/template/plates/","text":"Using Plates Plates is a native PHP template system maintained by The League of Extraordinary Packages . it provides: Layout facilities. Template inheritance. Helpers for escaping, and the ability to provide custom helper extensions. We provide a TemplateRendererInterface wrapper for Plates via Zend\\Expressive\\Plates\\PlatesRenderer . Installing Plates To use the Plates wrapper, you must install the Plates integration: $ composer require zendframework/zend-expressive-platesrenderer Using the wrapper If instantiated without arguments, Zend\\Expressive\\Plates\\PlatesRenderer will create an instance of the Plates engine, which it will then proxy to. use Zend\\Expressive\\Plates\\PlatesRenderer; $renderer = new PlatesRenderer(); Alternately, you can instantiate and configure the engine yourself, and pass it to the Zend\\Expressive\\Plates\\PlatesRenderer constructor: use League\\Plates\\Engine as PlatesEngine; use Zend\\Expressive\\Plates\\PlatesRenderer; // Create the engine instance: $plates = new PlatesEngine(); // Configure it: $plates->addFolder('error', 'templates/error/'); $plates->loadExtension(new CustomExtension()); // Inject: $renderer = new PlatesRenderer($plates);","title":"Using Plates"},{"location":"v1/features/template/plates/#using-plates","text":"Plates is a native PHP template system maintained by The League of Extraordinary Packages . it provides: Layout facilities. Template inheritance. Helpers for escaping, and the ability to provide custom helper extensions. We provide a TemplateRendererInterface wrapper for Plates via Zend\\Expressive\\Plates\\PlatesRenderer .","title":"Using Plates"},{"location":"v1/features/template/plates/#installing-plates","text":"To use the Plates wrapper, you must install the Plates integration: $ composer require zendframework/zend-expressive-platesrenderer","title":"Installing Plates"},{"location":"v1/features/template/plates/#using-the-wrapper","text":"If instantiated without arguments, Zend\\Expressive\\Plates\\PlatesRenderer will create an instance of the Plates engine, which it will then proxy to. use Zend\\Expressive\\Plates\\PlatesRenderer; $renderer = new PlatesRenderer(); Alternately, you can instantiate and configure the engine yourself, and pass it to the Zend\\Expressive\\Plates\\PlatesRenderer constructor: use League\\Plates\\Engine as PlatesEngine; use Zend\\Expressive\\Plates\\PlatesRenderer; // Create the engine instance: $plates = new PlatesEngine(); // Configure it: $plates->addFolder('error', 'templates/error/'); $plates->loadExtension(new CustomExtension()); // Inject: $renderer = new PlatesRenderer($plates);","title":"Using the wrapper"},{"location":"v1/features/template/twig/","text":"Using Twig Twig is a template language and engine provided as a standalone component by SensioLabs. It provides: Layout facilities. Template inheritance. Helpers for escaping, and the ability to provide custom helper extensions. We provide a TemplateRendererInterface wrapper for Twig via Zend\\Expressive\\Twig\\TwigRenderer . Installing Twig To use the Twig wrapper, you must first install the Twig integration: $ composer require zendframework/zend-expressive-twigrenderer Using the wrapper If instantiated without arguments, Zend\\Expressive\\Twig\\TwigRenderer will create an instance of the Twig engine, which it will then proxy to. use Zend\\Expressive\\Twig\\TwigRenderer; $renderer = new TwigRenderer(); Alternately, you can instantiate and configure the engine yourself, and pass it to the Zend\\Expressive\\Twig\\TwigRenderer constructor: use Twig_Environment; use Twig_Loader_Array; use Zend\\Expressive\\Twig\\TwigRenderer; // Create the engine instance: $loader = new Twig_Loader_Array(include 'config/templates.php'); $twig = new Twig_Environment($loader); // Configure it: $twig->addExtension(new CustomExtension()); $twig->loadExtension(new CustomExtension(); // Inject: $renderer = new TwigRenderer($twig); Included extensions and functions The included Twig extension adds support for url generation. The extension is automatically activated if the UrlHelper and ServerUrlHelper are registered with the container. The following template functions are exposed: path : Render the relative path for a given route and parameters. If there is no route, it returns the current path. twig {{ path('article_show', {'id': '3'}) }} Generates: /article/3 url : Render the absolute url for a given route and parameters. If there is no route, it returns the current url. twig {{ url('article_show', {'slug': 'article.slug'}) }} Generates: http://example.com/article/article.slug absolute_url : Render the absolute url from a given path. If the path is empty, it returns the current url. twig {{ absolute_url('path/to/something') }} Generates: http://example.com/path/to/something asset Render an (optionally versioned) asset url. twig {{ asset('path/to/asset/name.ext', version=3) }} Generates: path/to/asset/name.ext?v=3 To get the absolute url for an asset: twig {{ absolute_url(asset('path/to/asset/name.ext', version=3)) }} Generates: http://example.com/path/to/asset/name.ext?v=3 Configuration The following details configuration specific to Twig, as consumed by the TwigRendererFactory : return [ 'templates' => [ 'extension' => 'file extension used by templates; defaults to html.twig', 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ], 'twig' => [ 'cache_dir' => 'path to cached templates', 'assets_url' => 'base URL for assets', 'assets_version' => 'base version for assets', 'extensions' => [ // extension service names or instances ], 'globals' => [ // Global variables passed to twig templates 'ga_tracking' => 'UA-XXXXX-X' ], ], ];","title":"Using Twig"},{"location":"v1/features/template/twig/#using-twig","text":"Twig is a template language and engine provided as a standalone component by SensioLabs. It provides: Layout facilities. Template inheritance. Helpers for escaping, and the ability to provide custom helper extensions. We provide a TemplateRendererInterface wrapper for Twig via Zend\\Expressive\\Twig\\TwigRenderer .","title":"Using Twig"},{"location":"v1/features/template/twig/#installing-twig","text":"To use the Twig wrapper, you must first install the Twig integration: $ composer require zendframework/zend-expressive-twigrenderer","title":"Installing Twig"},{"location":"v1/features/template/twig/#using-the-wrapper","text":"If instantiated without arguments, Zend\\Expressive\\Twig\\TwigRenderer will create an instance of the Twig engine, which it will then proxy to. use Zend\\Expressive\\Twig\\TwigRenderer; $renderer = new TwigRenderer(); Alternately, you can instantiate and configure the engine yourself, and pass it to the Zend\\Expressive\\Twig\\TwigRenderer constructor: use Twig_Environment; use Twig_Loader_Array; use Zend\\Expressive\\Twig\\TwigRenderer; // Create the engine instance: $loader = new Twig_Loader_Array(include 'config/templates.php'); $twig = new Twig_Environment($loader); // Configure it: $twig->addExtension(new CustomExtension()); $twig->loadExtension(new CustomExtension(); // Inject: $renderer = new TwigRenderer($twig);","title":"Using the wrapper"},{"location":"v1/features/template/twig/#included-extensions-and-functions","text":"The included Twig extension adds support for url generation. The extension is automatically activated if the UrlHelper and ServerUrlHelper are registered with the container. The following template functions are exposed: path : Render the relative path for a given route and parameters. If there is no route, it returns the current path. twig {{ path('article_show', {'id': '3'}) }} Generates: /article/3 url : Render the absolute url for a given route and parameters. If there is no route, it returns the current url. twig {{ url('article_show', {'slug': 'article.slug'}) }} Generates: http://example.com/article/article.slug absolute_url : Render the absolute url from a given path. If the path is empty, it returns the current url. twig {{ absolute_url('path/to/something') }} Generates: http://example.com/path/to/something asset Render an (optionally versioned) asset url. twig {{ asset('path/to/asset/name.ext', version=3) }} Generates: path/to/asset/name.ext?v=3 To get the absolute url for an asset: twig {{ absolute_url(asset('path/to/asset/name.ext', version=3)) }} Generates: http://example.com/path/to/asset/name.ext?v=3","title":"Included extensions and functions"},{"location":"v1/features/template/twig/#configuration","text":"The following details configuration specific to Twig, as consumed by the TwigRendererFactory : return [ 'templates' => [ 'extension' => 'file extension used by templates; defaults to html.twig', 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ], 'twig' => [ 'cache_dir' => 'path to cached templates', 'assets_url' => 'base URL for assets', 'assets_version' => 'base version for assets', 'extensions' => [ // extension service names or instances ], 'globals' => [ // Global variables passed to twig templates 'ga_tracking' => 'UA-XXXXX-X' ], ], ];","title":"Configuration"},{"location":"v1/features/template/zend-view/","text":"Using zend-view zend-view provides a native PHP template system via its PhpRenderer , and is maintained by Zend Framework. It provides: Layout facilities. Helpers for escaping, and the ability to provide custom helper extensions. We provide a TemplateRendererInterface wrapper for zend-view's PhpRenderer via Zend\\Expressive\\ZendView\\ZendViewRenderer . Installing zend-view To use the zend-view wrapper, you must first install the zend-view integration: $ composer require zendframework/zend-expressive-zendviewrenderer Using the wrapper If instantiated without arguments, Zend\\Expressive\\ZendView\\ZendViewRenderer will create an instance of the PhpRenderer , which it will then proxy to. use Zend\\Expressive\\ZendView\\ZendViewRenderer; $renderer = new ZendViewRenderer(); Alternately, you can instantiate and configure the engine yourself, and pass it to the Zend\\Expressive\\ZendView\\ZendViewRenderer constructor: use Zend\\Expressive\\ZendView\\ZendViewRenderer; use Zend\\View\\Renderer\\PhpRenderer; use Zend\\View\\Resolver; // Create the engine instance: $renderer = new PhpRenderer(); // Configure it: $resolver = new Resolver\\AggregateResolver(); $resolver->attach( new Resolver\\TemplateMapResolver(include 'config/templates.php'), 100 ); $resolver->attach( (new Resolver\\TemplatePathStack()) ->setPaths(include 'config/template_paths.php') ); $renderer->setResolver($resolver); // Inject: $renderer = new ZendViewRenderer($renderer); Namespaced path resolving Expressive defines a custom zend-view resolver, Zend\\Expressive\\ZendView\\NamespacedPathStackResolver . This resolver provides the ability to segregate paths by namespace, and later resolve a template according to the namespace, using the namespace::template notation required of TemplateRendererInterface implementations. The ZendView adapter ensures that: An AggregateResolver is registered with the renderer. If the registered resolver is not an AggregateResolver , it creates one and adds the original resolver to it. A NamespacedPathStackResolver is registered with the AggregateResolver , at a low priority (0), ensuring attempts to resolve hit it later. With resolvers such as the TemplateMapResolver , you can also resolve namespaced templates, mapping them directly to the template on the filesystem that matches; adding such a resolver can be a nice performance boost! Layouts Unlike the other supported template engines, zend-view does not support layouts out-of-the-box. Expressive abstracts this fact away, providing two facilities for doing so: You may pass a layout template name or Zend\\View\\Model\\ModelInterface instance representing the layout as the second argument to the constructor. You may pass a \"layout\" parameter during rendering, with a value of either a layout template name or a Zend\\View\\Model\\ModelInterface instance representing the layout. Passing a layout this way will override any layout provided to the constructor. In each case, the zend-view implementation will do a depth-first, recursive render in order to provide content within the selected layout. Layout name passed to constructor use Zend\\Expressive\\ZendView\\ZendViewRenderer; // Create the engine instance with a layout name: $renderer = new ZendViewRenderer(null, 'layout::layout'); Layout view model passed to constructor use Zend\\Expressive\\ZendView\\ZendViewRenderer; use Zend\\View\\Model\\ViewModel; // Create the layout view model: $layout = new ViewModel([ 'encoding' => 'utf-8', 'cssPath' => '/css/prod/', ]); $layout->setTemplate('layout::layout'); // Create the engine instance with the layout: $renderer = new ZendViewRenderer(null, $layout); Provide a layout name when rendering $content = $renderer->render('blog/entry', [ 'layout' => 'layout::blog', 'entry' => $entry, ]); Provide a layout view model when rendering use Zend\\View\\Model\\ViewModel; // Create the layout view model: $layout = new ViewModel([ 'encoding' => 'utf-8', 'cssPath' => '/css/blog/', ]); $layout->setTemplate('layout::layout'); $content = $renderer->render('blog/entry', [ 'layout' => $layout, 'entry' => $entry, ]); Helpers Expressive provides overrides of specific view helpers in order to better integrate with PSR-7. These include: Zend\\Expressive\\ZendView\\UrlHelper . This helper consumes the application's Zend\\Expressive\\Router\\RouterInterface instance in order to generate URIs. It's signature is: url($routeName, array $substitutions = []) Zend\\Expressive\\ZendView\\ServerUrlHelper . This helper consumes the URI from the application's request in order to provide fully qualified URIs. It's signature is: serverUrl($path = null) . To use this particular helper, you will need to inject it with the request URI somewhere within your application: php $serverUrlHelper->setUri($request->getUri()); We recommend doing this within a pre-pipeline middleware. Recommendations We recommend the following practices when using the zend-view adapter: If using a layout, create a factory to return the layout view model as a service; this allows you to inject it into middleware and add variables to it. While we support passing the layout as a rendering parameter, be aware that if you change engines, this may not be supported.","title":"Using zend-view"},{"location":"v1/features/template/zend-view/#using-zend-view","text":"zend-view provides a native PHP template system via its PhpRenderer , and is maintained by Zend Framework. It provides: Layout facilities. Helpers for escaping, and the ability to provide custom helper extensions. We provide a TemplateRendererInterface wrapper for zend-view's PhpRenderer via Zend\\Expressive\\ZendView\\ZendViewRenderer .","title":"Using zend-view"},{"location":"v1/features/template/zend-view/#installing-zend-view","text":"To use the zend-view wrapper, you must first install the zend-view integration: $ composer require zendframework/zend-expressive-zendviewrenderer","title":"Installing zend-view"},{"location":"v1/features/template/zend-view/#using-the-wrapper","text":"If instantiated without arguments, Zend\\Expressive\\ZendView\\ZendViewRenderer will create an instance of the PhpRenderer , which it will then proxy to. use Zend\\Expressive\\ZendView\\ZendViewRenderer; $renderer = new ZendViewRenderer(); Alternately, you can instantiate and configure the engine yourself, and pass it to the Zend\\Expressive\\ZendView\\ZendViewRenderer constructor: use Zend\\Expressive\\ZendView\\ZendViewRenderer; use Zend\\View\\Renderer\\PhpRenderer; use Zend\\View\\Resolver; // Create the engine instance: $renderer = new PhpRenderer(); // Configure it: $resolver = new Resolver\\AggregateResolver(); $resolver->attach( new Resolver\\TemplateMapResolver(include 'config/templates.php'), 100 ); $resolver->attach( (new Resolver\\TemplatePathStack()) ->setPaths(include 'config/template_paths.php') ); $renderer->setResolver($resolver); // Inject: $renderer = new ZendViewRenderer($renderer);","title":"Using the wrapper"},{"location":"v1/features/template/zend-view/#layouts","text":"Unlike the other supported template engines, zend-view does not support layouts out-of-the-box. Expressive abstracts this fact away, providing two facilities for doing so: You may pass a layout template name or Zend\\View\\Model\\ModelInterface instance representing the layout as the second argument to the constructor. You may pass a \"layout\" parameter during rendering, with a value of either a layout template name or a Zend\\View\\Model\\ModelInterface instance representing the layout. Passing a layout this way will override any layout provided to the constructor. In each case, the zend-view implementation will do a depth-first, recursive render in order to provide content within the selected layout.","title":"Layouts"},{"location":"v1/features/template/zend-view/#helpers","text":"Expressive provides overrides of specific view helpers in order to better integrate with PSR-7. These include: Zend\\Expressive\\ZendView\\UrlHelper . This helper consumes the application's Zend\\Expressive\\Router\\RouterInterface instance in order to generate URIs. It's signature is: url($routeName, array $substitutions = []) Zend\\Expressive\\ZendView\\ServerUrlHelper . This helper consumes the URI from the application's request in order to provide fully qualified URIs. It's signature is: serverUrl($path = null) . To use this particular helper, you will need to inject it with the request URI somewhere within your application: php $serverUrlHelper->setUri($request->getUri()); We recommend doing this within a pre-pipeline middleware.","title":"Helpers"},{"location":"v1/features/template/zend-view/#recommendations","text":"We recommend the following practices when using the zend-view adapter: If using a layout, create a factory to return the layout view model as a service; this allows you to inject it into middleware and add variables to it. While we support passing the layout as a rendering parameter, be aware that if you change engines, this may not be supported.","title":"Recommendations"},{"location":"v1/getting-started/features/","text":"Overview Expressive allows you to write PSR-7 middleware applications for the web. PSR-7 is a standard defining HTTP message interfaces; these are the incoming request and outgoing response for your application. By using PSR-7, we ensure that your applications will work in other PSR-7 contexts. Middleware is any code sitting between a request and a response; it typically analyzes the request to aggregate incoming data, delegates it to another layer to process, and then creates and returns a response. Middleware can and should be relegated only to those tasks, and should be relatively easy to write and maintain. Middleware is also designed for composability; you should be able to nest middleware and re-use middleware. With Expressive, you can build PSR-7-based middleware applications: APIs Websites Single Page Applications and more. Features Expressive builds on zend-stratigility to provide a robust convenience layer on which to build applications. The features it provides include: Routing Stratigility provides limited, literal matching only. Expressive allows you to utilize dynamic routing capabilities from a variety of routers, providing much more fine-grained matching capabilities. The routing layer also allows restricting matched routes to specific HTTP methods, and will return \"405 Not Allowed\" responses with an \"Allow\" HTTP header containing allowed HTTP methods for invalid requests. Routing is abstracted in Expressive, allowing the developer to choose the routing library that best fits the project needs. By default, we provide wrappers for Aura.Router, FastRoute, and the zend-mvc router. container-interop Expressive encourages the use of Dependency Injection, and defines its Application class to compose a container-interop ContainerInterface instance. The container is used to lazy-load middleware, whether it is piped (Stratigility interface) or routed (Expressive). Templating While Expressive does not assume templating is being used, it provides a templating abstraction. Developers can write middleware that typehints on this abstraction, and assume that the underlying adapter will provide layout support and namespaced template support. Error Handling Applications should handle errors gracefully, but also handle them differently in development versus production. Expressive provides both basic error handling via Stratigility's own FinalHandler implementation, as well as more advanced error handling via two specialized error handlers: a templated error handler for production, and a Whoops-based error handler for development. Flow Overview Below is a diagram detailing the workflow used by Expressive. The Application acts as an \"onion\"; in the diagram above, the top is the outer-most layer of the onion, while the bottom is the inner-most. The Application dispatches each middleware. Each middleware accepts a request , a response , and the next middleware to dispatch. Internally, it's actually receiving the middleware stack itself, which knows which middleware to invoke next. Any given middleware can return a response , at which point execution winds its way back out the onion. Additionally, any given middleware can indicate an error occurred, at which point it can call on the next error handling middleware . These act like regular middleware, but accept an additional error argument to act on. Pipelines The terminology \"pipeline\" is often used to describe the onion. One way of looking at the \"onion\" is as a queue , which is first-in-first-out (FIFO) in operation. This means that the first middleware on the queue is executed first, and this invokes the next, and so on (and hence the \"next\" terminology). When looked at from this perspective: In most cases, the entire queue will not be traversed. The inner-most layer of the onion represents the last item in the queue. Responses are returned back through the pipeline, in reverse order of traversal. The Application allows arbitrary middleware to be injected, with each being executed in the order in which they are attached; returning a response from middleware prevents any middleware attached later from executing. You can attach middleware manually, in which case the pipeline is executed in the order of attachment, or use configuration. When you use configuration, you will specify a priority integer to dictate the order in which middleware should be attached. Middleware specifying high integer prioritiess are attached (and thus executed) earlier, while those specifying lower and/or negative integers are attached later. The default priority is 1. Expressive provides a default implementation of \"routing\" and \"dispatch\" middleware, which you either attach to the middleware pipeline manually, or via configuration. Routing within Expressive consists of decomposing the request to match it to middleware that can handle that given request. This typically consists of a combination of matching the requested URI path along with allowed HTTP methods: map a GET request to the path /api/ping to the PingMiddleware map a POST request to the path /contact/process to the HandleContactMiddleware etc. Dispatching is simply the act of calling the middleware mapped by routing. The two events are modeled as separate middleware to allow you to act on the results of routing before attempting to dispatch the mapped middleware; this can be useful for implementing route-based authentication or validation. The majority of your application will consist of routing rules that map to routed middleware. Middleware piped to the application earlier than routing should be middleware that you wish to execute for every request. These might include: bootstrapping parsing of request body parameters addition of debugging tools embedded Expressive applications that you want to match at a given literal path etc. Such middleware may decide that a request is invalid, and return a response; doing so means no further middleware will be executed! This is an important feature of middleware architectures, as it allows you to define application-specific workflows optimized for performance, security, etc. Middleware piped to the application after the routing and dispatch middleware will execute in one of two conditions: routing failed routed middleware called on the next middleware instead of returning a response. As such, the largest use case for such middleware is for error handling. One possibility is for providing custom 404 handling , or handling application-specific error conditions (such as authentication or authorization failures). Another possibility is to provide post-processing on the response before returning it. However, this is typically better handled via middleware piped early, by capturing the response before returning it: function ($request, $response, $next) { $response = $next($request, $response); return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett'); } The main points to remember are: The application is a queue, and operates in FIFO order. Each middleware can choose whether to return a response, which will cause the queue to unwind, or to traverse to the next middleware. Most of the time, you will be defining routed middleware , and the routing rules that map to them. You get to control the workflow of your application by deciding the order in which middleware is queued.","title":"Overview and Features"},{"location":"v1/getting-started/features/#overview","text":"Expressive allows you to write PSR-7 middleware applications for the web. PSR-7 is a standard defining HTTP message interfaces; these are the incoming request and outgoing response for your application. By using PSR-7, we ensure that your applications will work in other PSR-7 contexts. Middleware is any code sitting between a request and a response; it typically analyzes the request to aggregate incoming data, delegates it to another layer to process, and then creates and returns a response. Middleware can and should be relegated only to those tasks, and should be relatively easy to write and maintain. Middleware is also designed for composability; you should be able to nest middleware and re-use middleware. With Expressive, you can build PSR-7-based middleware applications: APIs Websites Single Page Applications and more.","title":"Overview"},{"location":"v1/getting-started/features/#features","text":"Expressive builds on zend-stratigility to provide a robust convenience layer on which to build applications. The features it provides include: Routing Stratigility provides limited, literal matching only. Expressive allows you to utilize dynamic routing capabilities from a variety of routers, providing much more fine-grained matching capabilities. The routing layer also allows restricting matched routes to specific HTTP methods, and will return \"405 Not Allowed\" responses with an \"Allow\" HTTP header containing allowed HTTP methods for invalid requests. Routing is abstracted in Expressive, allowing the developer to choose the routing library that best fits the project needs. By default, we provide wrappers for Aura.Router, FastRoute, and the zend-mvc router. container-interop Expressive encourages the use of Dependency Injection, and defines its Application class to compose a container-interop ContainerInterface instance. The container is used to lazy-load middleware, whether it is piped (Stratigility interface) or routed (Expressive). Templating While Expressive does not assume templating is being used, it provides a templating abstraction. Developers can write middleware that typehints on this abstraction, and assume that the underlying adapter will provide layout support and namespaced template support. Error Handling Applications should handle errors gracefully, but also handle them differently in development versus production. Expressive provides both basic error handling via Stratigility's own FinalHandler implementation, as well as more advanced error handling via two specialized error handlers: a templated error handler for production, and a Whoops-based error handler for development.","title":"Features"},{"location":"v1/getting-started/features/#flow-overview","text":"Below is a diagram detailing the workflow used by Expressive. The Application acts as an \"onion\"; in the diagram above, the top is the outer-most layer of the onion, while the bottom is the inner-most. The Application dispatches each middleware. Each middleware accepts a request , a response , and the next middleware to dispatch. Internally, it's actually receiving the middleware stack itself, which knows which middleware to invoke next. Any given middleware can return a response , at which point execution winds its way back out the onion. Additionally, any given middleware can indicate an error occurred, at which point it can call on the next error handling middleware . These act like regular middleware, but accept an additional error argument to act on.","title":"Flow Overview"},{"location":"v1/getting-started/skeleton/","text":"Quick Start: Using the Skeleton + Installer The easiest way to get started with Expressive is to use the skeleton application and installer . The skeleton provides a generic structure for creating your applications, and prompts you to choose a router, dependency injection container, template renderer, and error handler from the outset. 1. Create a new project First, we'll create a new project, using Composer's create-project command: $ composer create-project zendframework/zend-expressive-skeleton expressive This will prompt you to choose: A router. We recommend using the default, FastRoute. A dependency injection container. We recommend using the default, Zend ServiceManager. A template renderer. You can ignore this when creating an API project, but if you will be creating any HTML pages, we recommend installing one. We prefer Plates. An error handler. Whoops is a very nice option for development, as it gives you extensive, browseable information for exceptions and errors raised. 2. Start a web server The Skeleton + Installer creates a full application structure that's ready-to-go when complete. You can test it out using built-in web server . From the project root directory, execute the following: $ composer serve This starts up a web server on localhost port 8080; browse to http://localhost:8080/ to see if your application responds correctly! Next Steps The skeleton makes the assumption that you will be writing your middleware as classes, and using configuration to map routes to middleware. It also provides a default structure for templates, if you choose to use them. Let's see how you can create first vanilla middleware, and then templated middleware. Creating middleware The easiest way to create middleware is to create a class that defines an __invoke() method accepting a request, response, and callable \"next\" argument (for invoking the \"next\" middleware in the queue). The skeleton defines an App namespace for you, and suggests placing middleware under the namespace App\\Action . Let's create a \"Hello\" action. Place the following in src/App/Action/HelloAction.php : <?php namespace App\\Action; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; class HelloAction { public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next) { $query = $request->getQueryParams(); $target = isset($query['target']) ? $query['target'] : 'World'; $target = htmlspecialchars($target, ENT_HTML5, 'UTF-8'); $response->getBody()->write(sprintf( '<h1>Hello, %s!</h1>', $target )); return $response->withHeader('Content-Type', 'text/html'); } } The above looks for a query string parameter \"target\", and uses its value to provide a message, which is then returned in an HTML response. Now we need to inform the application of this middleware, and indicate what path will invoke it. Open the file config/autoload/routes.global.php . Inside that file, you should have a structure similar to the following: return [ 'dependencies' => [ /* ... */ ], 'routes' => [ /* ... */ ], ]; We're going to add an entry under routes : return [ /* ... */ 'routes' => [ /* ... */ [ 'name' => 'hello', 'path' => '/hello', 'middleware' => App\\Action\\HelloAction::class, 'allowed_methods' => ['GET'], ], ], ]; Once you've added the above entry, give it a try by going to each of the following URIs: http://localhost:8080/hello http://localhost:8080/hello?target=ME You should see the message change as you go between the two URIs! Using templates You likely don't want to hardcode HTML into your middleware; so, let's use templates. This particular exercise assumes you chose to use the Plates integration. Templates are installed under the templates/ subdirectory. By default, we also register the template namespace app to correspond with the templates/app subdirectory. Create the file templates/app/hello-world.phtml with the following contents: <?php $this->layout('layout::default', ['title' => 'Greetings']) ?> <h2>Hello, <?= $this->e($target) ?></h2> Now that we have a template, we need to: Inject a renderer into our action class. Use the renderer to render the contents. Replace your src/App/Action/HelloAction.php file with the following contents: <?php namespace App\\Action; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Template\\TemplateRendererInterface; class HelloAction { private $renderer; public function __construct(TemplateRendererInterface $renderer) { $this->renderer = $renderer; } public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next) { $query = $request->getQueryParams(); $target = isset($query['target']) ? $query['target'] : 'World'; return new HtmlResponse( $this->renderer->render('app::hello-world', ['target' => $target]) ); } } The above modifies the class to accept a renderer to the constructor, and then calls on it to render a template. A few things to note: We no longer need to escape our target; the template takes care of that for us. We're using a specific response type here, from Diactoros , which is the default PSR-7 implementation Expressive uses. This response type simplifies our response creation. How does the template renderer get into the action, however? The answer is dependency injection. For the next part of the example, we'll be creating and wiring a factory for creating the HelloAction instance; the example assumes you used the default selection for a dependency injection container, Zend ServiceManager. Let's create a factory. Create the file src/App/Action/HelloActionFactory.php with the following contents: <?php namespace App\\Action; use Interop\\Container\\ContainerInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class HelloActionFactory { public function __invoke(ContainerInterface $container) { return new HelloAction( $container->get(TemplateRendererInterface::class) ); } } With that in place, we'll now update our configuration. Open the file config/autoload/routes.global.php ; it should have a structure similar to the following: return [ 'dependencies' => [ 'invokables' => [ /* ... */ ], ], 'routes' => [ /* ... */ ], ]; We're going to tell our application that we have a factory for our HelloAction class: return [ 'dependencies' => [ /* ... */ 'factories' => [ /* ... */ App\\Action\\HelloAction::class => App\\Action\\HelloActionFactory::class, ], ], 'routes' => [ /* ... */ ], ]; Save that file, and now re-visit the URIs: http://localhost:8080/hello http://localhost:8080/hello?target=ME Your page should now have the same layout as the landing page of the skeleton application! Congratulations! Congratulations! You've now created your application, and started writing middleware! It's time to start learning about the rest of the features of Expressive: Containers Routing Templating Error Handling","title":"Quick Start: Skeleton Installer"},{"location":"v1/getting-started/skeleton/#quick-start-using-the-skeleton-installer","text":"The easiest way to get started with Expressive is to use the skeleton application and installer . The skeleton provides a generic structure for creating your applications, and prompts you to choose a router, dependency injection container, template renderer, and error handler from the outset.","title":"Quick Start: Using the Skeleton + Installer"},{"location":"v1/getting-started/skeleton/#1-create-a-new-project","text":"First, we'll create a new project, using Composer's create-project command: $ composer create-project zendframework/zend-expressive-skeleton expressive This will prompt you to choose: A router. We recommend using the default, FastRoute. A dependency injection container. We recommend using the default, Zend ServiceManager. A template renderer. You can ignore this when creating an API project, but if you will be creating any HTML pages, we recommend installing one. We prefer Plates. An error handler. Whoops is a very nice option for development, as it gives you extensive, browseable information for exceptions and errors raised.","title":"1. Create a new project"},{"location":"v1/getting-started/skeleton/#2-start-a-web-server","text":"The Skeleton + Installer creates a full application structure that's ready-to-go when complete. You can test it out using built-in web server . From the project root directory, execute the following: $ composer serve This starts up a web server on localhost port 8080; browse to http://localhost:8080/ to see if your application responds correctly!","title":"2. Start a web server"},{"location":"v1/getting-started/skeleton/#next-steps","text":"The skeleton makes the assumption that you will be writing your middleware as classes, and using configuration to map routes to middleware. It also provides a default structure for templates, if you choose to use them. Let's see how you can create first vanilla middleware, and then templated middleware.","title":"Next Steps"},{"location":"v1/getting-started/skeleton/#congratulations","text":"Congratulations! You've now created your application, and started writing middleware! It's time to start learning about the rest of the features of Expressive: Containers Routing Templating Error Handling","title":"Congratulations!"},{"location":"v1/getting-started/standalone/","text":"Quick Start: Standalone Usage Expressive allows you to get started at your own pace. You can start with the simplest example, detailed below, or move on to a more structured, configuration-driven approach as detailed in the use case examples . 1. Create a new project directory First, let's create a new project directory and enter it: $ mkdir expressive $ cd expressive 2. Install Expressive If you haven't already, install Composer . Once you have, we can install Expressive, along with a router and a container: $ composer require zendframework/zend-expressive zendframework/zend-expressive-fastroute zendframework/zend-servicemanager Routers Expressive needs a routing implementation in order to create routed middleware. We suggest FastRoute in the quick start, but you can also currently choose from Aura.Router and zend-router. Containers We highly recommend using dependency injection containers with Expressive; they allow you to define dependencies for your middleware, as well as to lazy load your middleware only when it needs to be executed. We suggest zend-servicemanager in the quick start, but you can also use any container supporting container-interop . 3. Create a web root directory You'll need a directory from which to serve your application, and for security reasons, it's a good idea to keep it separate from your source code. We'll create a public/ directory for this: $ mkdir public 4. Create your bootstrap script Next, we'll create a bootstrap script. Such scripts typically setup the environment, setup the application, and invoke it. This needs to be in our web root, and we want it to intercept any incoming request; as such, we'll use public/index.php : <?php use Zend\\Expressive\\AppFactory; chdir(dirname(__DIR__)); require 'vendor/autoload.php'; $app = AppFactory::create(); $app->get('/', function ($request, $response, $next) { $response->getBody()->write('Hello, world!'); return $response; }); $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); $app->run(); Rewriting URLs Many web servers will not rewrite URLs to the bootstrap script by default. If you use Apache, for instance, you'll need to setup rewrite rules to ensure your bootstrap is invoked for unknown URLs. We'll cover that in a later chapter. Routing and dispatching Note the lines from the above: $$$$FENCED_CODE_BLOCK_5e03bde9f16ec9.40631853 Expressive's Application class provides two separate middlewares, one for routing, and one for dispatching middleware matched by routing. This allows you to slip in validations between the two activities if desired. They are not automatically piped to the application, however, to allow exactly that situation, which means they must be piped manually. 5. Start a web server Since we're just testing out the basic functionality of our application, we'll use PHP's built-in web server . From the project root directory, execute the following: $ php -S 0.0.0.0:8080 -t public/ This starts up a web server on localhost port 8080; browse to http://localhost:8080/ to see if your application responds correctly! Tip: Serve via Composer To simplify starting up a local web server, try adding the following to your composer.json : $$$$FENCED_CODE_BLOCK_5e03bde9f170f3.50471929 Once you've added that, you can fire up the web server using: $$$$FENCED_CODE_BLOCK_5e03bde9f171f9.67149948 Next steps At this point, you have a working zend-expressive application, that responds to a single route. From here, you may want to read up on: Applications Containers Routing Templating Error Handling Additionally, we have more use case examples .","title":"Quick Start: Standalone"},{"location":"v1/getting-started/standalone/#quick-start-standalone-usage","text":"Expressive allows you to get started at your own pace. You can start with the simplest example, detailed below, or move on to a more structured, configuration-driven approach as detailed in the use case examples .","title":"Quick Start: Standalone Usage"},{"location":"v1/getting-started/standalone/#1-create-a-new-project-directory","text":"First, let's create a new project directory and enter it: $ mkdir expressive $ cd expressive","title":"1. Create a new project directory"},{"location":"v1/getting-started/standalone/#2-install-expressive","text":"If you haven't already, install Composer . Once you have, we can install Expressive, along with a router and a container: $ composer require zendframework/zend-expressive zendframework/zend-expressive-fastroute zendframework/zend-servicemanager","title":"2. Install Expressive"},{"location":"v1/getting-started/standalone/#3-create-a-web-root-directory","text":"You'll need a directory from which to serve your application, and for security reasons, it's a good idea to keep it separate from your source code. We'll create a public/ directory for this: $ mkdir public","title":"3. Create a web root directory"},{"location":"v1/getting-started/standalone/#4-create-your-bootstrap-script","text":"Next, we'll create a bootstrap script. Such scripts typically setup the environment, setup the application, and invoke it. This needs to be in our web root, and we want it to intercept any incoming request; as such, we'll use public/index.php : <?php use Zend\\Expressive\\AppFactory; chdir(dirname(__DIR__)); require 'vendor/autoload.php'; $app = AppFactory::create(); $app->get('/', function ($request, $response, $next) { $response->getBody()->write('Hello, world!'); return $response; }); $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); $app->run();","title":"4. Create your bootstrap script"},{"location":"v1/getting-started/standalone/#5-start-a-web-server","text":"Since we're just testing out the basic functionality of our application, we'll use PHP's built-in web server . From the project root directory, execute the following: $ php -S 0.0.0.0:8080 -t public/ This starts up a web server on localhost port 8080; browse to http://localhost:8080/ to see if your application responds correctly!","title":"5. Start a web server"},{"location":"v1/getting-started/standalone/#next-steps","text":"At this point, you have a working zend-expressive application, that responds to a single route. From here, you may want to read up on: Applications Containers Routing Templating Error Handling Additionally, we have more use case examples .","title":"Next steps"},{"location":"v1/reference/expressive-projects/","text":"Projects powered by zend-expressive zend-expressive can be used for anything. Here are some projects, tutorials and the related source code. Have a look around and see how others have used zend-expressive. Sample Code & Tutorials Expressive Tutorial (WIP) - source AstroSplash - source php-ddd-cargo-sample - source Personal Sites mwop.net - source xtreamwayz.com - source alejandrocelaya.com - source zimuel.it - source","title":"Expressive Projects"},{"location":"v1/reference/expressive-projects/#projects-powered-by-zend-expressive","text":"zend-expressive can be used for anything. Here are some projects, tutorials and the related source code. Have a look around and see how others have used zend-expressive.","title":"Projects powered by zend-expressive"},{"location":"v1/reference/expressive-projects/#sample-code-tutorials","text":"Expressive Tutorial (WIP) - source AstroSplash - source php-ddd-cargo-sample - source","title":"Sample Code &amp; Tutorials"},{"location":"v1/reference/expressive-projects/#personal-sites","text":"mwop.net - source xtreamwayz.com - source alejandrocelaya.com - source zimuel.it - source","title":"Personal Sites"},{"location":"v1/reference/usage-examples/","text":"Usage Examples Below are several usage examples, covering a variety of ways of creating and managing an application. In all examples, the assumption is the following directory structure: . \u251c\u2500\u2500 config \u251c\u2500\u2500 data \u251c\u2500\u2500 composer.json \u251c\u2500\u2500 public \u2502 \u2514\u2500\u2500 index.php \u251c\u2500\u2500 src \u2514\u2500\u2500 vendor We assume also that: You have installed zend-expressive per the installation instructions . public/ will be the document root of your application. Your own classes are under src/ with the top-level namespace Application , and you have configured autoloading in your composer.json for those classes. Using the built-in web server You can use the built-in web server to run the examples. Run: $$$$FENCED_CODE_BLOCK_5e03bdea006605.32609148 from the application root to start up a web server running on port 8080, and then browse to http://localhost:8080/. If you used the Expressive installer, the following is equivalent: $$$$FENCED_CODE_BLOCK_5e03bdea006777.91259778 Setting up autoloading for the Application namespace In your composer.json file, place the following: $$$$FENCED_CODE_BLOCK_5e03bdea0068d9.47732434 Once done, run: $$$$FENCED_CODE_BLOCK_5e03bdea006a27.75053112 Routing As noted in the Application documentation , routing is abstracted and can be accomplished by calling any of the following methods: route($path, $middleware, array $methods = null, $name = null) to route to a path and match any HTTP method, multiple HTTP methods, or custom HTTP methods. get($path, $middleware, $name = null) to route to a path that will only respond to the GET HTTP method. post($path, $middleware, $name = null) to route to a path that will only respond to the POST HTTP method. put($path, $middleware, $name = null) to route to a path that will only respond to the PUT HTTP method. patch($path, $middleware, $name = null) to route to a path that will only respond to the PATCH HTTP method. delete($path, $middleware, $name = null) to route to a path that will only respond to the DELETE HTTP method. All methods return a Zend\\Expressive\\Router\\Route method, which allows you to specify additional options to associate with the route (e.g., for specifying criteria, default values to match, etc.). As examples: // GET // This demonstrates passing a callable middleware (assuming $helloWorld is // callable). $app->get('/', $helloWorld); // POST // This example specifies the middleware as a service name instead of as a // callable. $app->post('/trackback', 'TrackBack'); // PUT // This example shows operating on the returned route. In this case, it's adding // regex tokens to restrict what values for {id} will match. (The tokens feature // is specific to Aura.Router.) $app->put('/post/{id}', 'ReplacePost') ->setOptions([ 'tokens' => [ 'id' => '\\d+' ], ]); // PATCH // This example builds on the one above. Expressive allows you to specify // the same path for a route matching on a different HTTP method, and // corresponding to different middleware. $app->patch('/post/{id}', 'UpdatePost') ->setOptions([ 'tokens' => [ 'id' => '\\d+' ], ]); // DELETE $app->delete('/post/{id}', 'DeletePost') ->setOptions([ 'tokens' => [ 'id' => '\\d+' ], ]); // Matching ALL HTTP methods // If the underlying router supports matching any HTTP method, the following // will do so. Note: FastRoute *requires* you to specify the HTTP methods // allowed explicitly, and does not support wildcard routes. As such, the // following example maps to the combination of HEAD, OPTIONS, GET, POST, PATCH, // PUT, TRACE, and DELETE. // Just like the previous examples, it returns a Route instance that you can // further manipulate. $app->route('/post/{id}', 'HandlePost') ->setOptions([ 'tokens' => [ 'id' => '\\d+' ], ]); // Matching multiple HTTP methods // You can pass an array of HTTP methods as a third argument to route(); in such // cases, routing will match if any of the specified HTTP methods are provided. $app->route('/post', 'HandlePostCollection', ['GET', 'POST']); // Matching NO HTTP methods // Pass an empty array to the HTTP methods. HEAD and OPTIONS will still be // honored. (In FastRoute, GET is also honored.) $app->route('/post', 'WillThisHandlePost', []); Finally, if desired, you can create a Zend\\Expressive\\Router\\Route instance manually and pass it to route() as the sole argument: $route = new Route('/post', 'HandlePost', ['GET', 'POST']); $route->setOptions($options); $app->route($route); Hello World using a Container Expressive works with container-interop , though it's an optional feature. By default, if you use the AppFactory , it will use zend-servicemanager . In the following example, we'll populate the container with our middleware, and the application will pull it from there when matched. Edit your public/index.php to read as follows: use Zend\\Diactoros\\Response\\JsonResponse; use Zend\\Expressive\\AppFactory; use Zend\\ServiceManager\\ServiceManager; require __DIR__ . '/../vendor/autoload.php'; $container = new ServiceManager(); $container->setFactory('HelloWorld', function ($container) { return function ($req, $res, $next) { $res->getBody()->write('Hello, world!'); return $res; }; }); $container->setFactory('Ping', function ($container) { return function ($req, $res, $next) { return new JsonResponse(['ack' => time()]); }; }); $app = AppFactory::create($container); $app->get('/', 'HelloWorld'); $app->get('/ping', 'Ping'); $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); $app->run(); In the example above, we pass our container to AppFactory . We could have also done this instead: $app = AppFactory::create(); $container = $app->getContainer(); and then added our service definitions. We recommend passing the container to the factory instead; if we ever change which container we use by default, your code might not work! The following two lines are the ones of interest: $app->get('/', 'HelloWorld'); $app->get('/ping', 'Ping'); These map the two paths to service names instead of callables. When routing matches a path, it does the following: If the middleware provided when defining the route is callable, it uses it directly. If the middleware is a valid service name in the container, it pulls it from the container. This is what happens in this example. Finally, if no container is available, or the service name is not found in the container, it checks to see if it's a valid class name; if so, it instantiates and returns the class instance. If you fire up your web server, you'll find that the / and /ping paths continue to work. One other approach you could take would be to define the application itself in the container, and then pull it from there: $container->setFactory('Zend\\Expressive\\Application', function ($container) { $app = AppFactory::create($container); $app->get('/', 'HelloWorld'); $app->get('/ping', 'Ping'); return $app; }); $app = $container->get('Zend\\Expressive\\Application'); $app->run(); This is a nice way to encapsulate the application creation. You could then potentially move all service configuration to another file! (We already document an ApplicationFactory for exactly this scenario. ) Hello World using a Configuration-Driven Container In the above example, we configured our middleware as services, and then passed our service container to the application. At the end, we hinted that you could potentially define the application itself as a service. Expressive already provides a service factory for the application instance to provide fine-grained control over your application. In this example, we'll leverage it, defining our routes via configuration. First, we're going to leverage zend-config to merge configuration files. This is important, as it allows us to define local, environment-specific configuration in files that we then can exclude from our repository. This practice ensures that things like credentials are not accidentally published in a public repository, and also provides a mechanism for slip-streaming in configuration based on our environment (you might use different settings in development than in production, after all!). First, install zend-config and zend-stdlib: $ composer require zendframework/zend-config zendframework/zend-stdlib Now we can start creating our configuration files and container factories. In config/config.php , place the following: <?php use Zend\\Stdlib\\ArrayUtils; use Zend\\Stdlib\\Glob; $config = []; // Load configuration from autoload path foreach (Glob::glob('config/autoload/{{,*.}global,{,*.}local}.php', Glob::GLOB_BRACE) as $file) { $config = ArrayUtils::merge($config, include $file); } // Return an ArrayObject so we can inject the config as a service in Aura.Di // and still use array checks like ``is_array``. return new ArrayObject($config, ArrayObject::ARRAY_AS_PROPS); In config/container.php , place the following: <?php use Zend\\ServiceManager\\Config; use Zend\\ServiceManager\\ServiceManager; // Load configuration $config = require __DIR__.'/config.php'; // Build container $container = new ServiceManager(); (new Config($config['dependencies']))->configureServiceManager($container); // Inject config $container->setService('config', $config); return $container; In config/autoload/dependencies.global.php , place the following: <?php use Zend\\ServiceManager\\Factory\\InvokableFactory; return [ 'dependencies' => [ 'invokables' => [ \\Application\\HelloWorldAction::class => InvokableFactory::class, \\Application\\PingAction::class => InvokableFactory::class, ], 'factories' => [ \\Zend\\Expressive\\Application::class => \\Zend\\Expressive\\Container\\ApplicationFactory::class, ], ] ]; In config/autoload/routes.global.php , place the following: <?php return [ 'routes' => [ [ 'path' => '/', 'middleware' => \\Application\\HelloWorldAction::class, 'allowed_methods' => [ 'GET' ], ], [ 'path' => '/ping', 'middleware' => \\Application\\PingAction::class, 'allowed_methods' => [ 'GET' ], ], ], ]; In src/Application/HelloWorld.php , place the following: <?php namespace Application; class HelloWorld { public function __invoke($req, $res, $next) { $res->getBody()->write('Hello, world!'); return $res; } } In src/Application/Ping.php , place the following: <?php namespace Application; use Zend\\Diactoros\\Response\\JsonResponse; class Ping { public function __invoke($req, $res, $next) { return new JsonResponse(['ack' => time()]); } } After that\u2019s done run: composer dump-autoload Finally, in public/index.php , place the following: <?php // Change to the project root, to simplify resolving paths chdir(dirname(__DIR__)); // Setup autoloading require 'vendor/autoload.php'; $container = include 'config/services.php'; $app = $container->get(Zend\\Expressive\\Application::class); $app->run(); Notice that our index file now doesn't have any code related to setting up the application any longer! All it does is setup autoloading, retrieve our service container, pull the application from it, and run it. Our choices for container, router, etc. are all abstracted, and if we change our mind later, this code will continue to work. Firing up the web server, you'll see the same responses as the previous examples. Hybrid Container and Programmatic Creation The above example may look a little daunting at first. By making everything configuration-driven, you sometimes lose a sense for how the code all fits together. Fortunately, you can mix the two. Building on the example above, we'll add a new route and middleware. Between pulling the application from the container and calling $app->run() , add the following in your public/index.php : $app->post('/post', function ($req, $res, $next) { $res->getBody()->write('IN POST!'); return $res; }); Note that we're using post() here; that means you'll have to use cURL, HTTPie, Postman, or some other tool to test making a POST request to the path: $ curl -X POST http://localhost:8080/post You should see IN POST! for the response! Using this approach, you can build re-usable applications that are container-driven, and add one-off routes and middleware as needed. Using the container to register middleware If you use a container to fetch your application instance, you have an additional option for specifying middleware for the pipeline: configuration: <?php return [ 'routes' => [ [ 'path' => '/path/to/match', 'middleware' => 'Middleware Service Name or Callable', 'allowed_methods' => [ 'GET', 'POST', 'PATCH' ], 'options' => [ 'stuff' => 'to', 'pass' => 'to', 'the' => 'underlying router', ], ], // etc. ], 'middleware_pipeline' => [ // See specification below ], ]; The key to note is middleware_pipeline , which is an array of middlewares to register in the pipeline; each will each be pipe() 'd to the Application in the order specified. Each middleware specified must be in the following form: [ // required: 'middleware' => 'Name of middleware service, or a callable', // optional: 'path' => '/path/to/match', 'error' => true, 'priority' => 1, // Integer ] Priority should be an integer, and follows the semantics of SplPriorityQueue : higher numbers indicate higher priority (top of the queue; executed earliest), while lower numbers indicated lower priority (bottom of the queue, executed last); negative values are low priority . Items of the same priority are executed in the order in which they are attached. The default priority is 1, and this priority is used by the routing and dispatch middleware. To indicate that middleware should execute before these, use a priority higher than 1. For error middleware, use a priority less than 1. The above specification can be used for all middleware, with one exception: registration of the routing and/or dispatch middleware that Expressive provides. In these cases, use the following constants, which will be caught by the factory and expanded: Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE for the routing middleware; this should always come before the dispatch middleware. Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE for the dispatch middleware. As an example: return [ 'middleware_pipeline' => [ [ /* ... */ ], Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, [ /* ... */ ], ], ]; Place routing middleware correctly If you are defining routes and defining other middleware for the pipeline, you must add the routing middleware. When you do so, make sure you put it at the appropriate location in the pipeline. Typically, you will place any middleware you want to execute on all requests prior to the routing middleware. This includes utilities for bootstrapping the application (such as injection of the ServerUrlHelper ), utilities for injecting common response headers (such as CORS support), etc. Make sure these middleware specifications include the priority key, and that the value of this key is greater than 1. Place error middleware after the routing middleware. This is middleware that should only execute if routing fails or routed middleware cannot complete the response. These specifications should also include the priority key, and the value of that key for such middleware should be less than 1 or negative. Use priority to shape the specific workflow you want for your middleware. Middleware items may be any callable, Zend\\Stratigility\\MiddlewareInterface implementation, or a service name that resolves to one of the two. Additionally, you can specify an array of such values; these will be composed in a single Zend\\Stratigility\\MiddlewarePipe instance, allowing layering of middleware. In fact, you can specify the various ApplicationFactory::*_MIDDLEWARE constants in such arrays as well: return [ 'middleware_pipeline' => [ [ /* ... */ ], 'routing' => [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, /* ... middleware that introspects routing results ... */ Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], [ /* ... */ ], ], ]; Pipeline keys are ignored Keys in a middleware_pipeline specification are ignored. However, they can be useful when merging several configurations; if multiple configuration files specify the same key, then those entries will be merged. Be aware, however, that the middleware entry for each, since it is an indexed array, will merge arrays by appending; in other words, order will not be guaranteed within that array after merging. If order is critical, define a middleware spec with priority keys. The path, if specified, can only be a literal path to match, and is typically used for segregating middleware applications or applying rules to subsets of an application that match a common path root. error indicates whether or not the middleware represents error middleware; this is done to ensure that lazy-loading of error middleware works as expected. Lazy-loaded Middleware One feature of the middleware_pipeline is that any middleware service pulled from the container is actually wrapped in a closure: $$$$FENCED_CODE_BLOCK_5e03bdea006b58.32541764 If the error flag is specified and is truthy, the closure looks like this instead, to ensure the middleware is treated by Stratigility as error middleware: $$$$FENCED_CODE_BLOCK_5e03bdea006d05.74679614 This implements lazy-loading for middleware pipeline services, delaying retrieval from the container until the middleware is actually invoked. This also means that if the service specified is not valid middleware, you will not find out until the application attempts to invoke it. Segregating your application to a subpath One benefit of a middleware-based application is the ability to compose middleware and segregate them by paths. Zend\\Expressive\\Application is itself middleware, allowing you to do exactly that if desired. In the following example, we'll assume that $api and $blog are Zend\\Expressive\\Application instances, and compose them into a Zend\\Stratigility\\MiddlewarePipe . use Zend\\Diactoros\\Server; use Zend\\Diactoros\\ServerRequestFactory; use Zend\\Stratigility\\MiddlewarePipe; require __DIR__ . '/../vendor/autoload.php'; $app = new MiddlewarePipe(); $app->pipe('/blog', $blog); $app->pipe('/api', $api); $server = Server::createServerFromRequest( $app, ServerRequestFactory::fromGlobals() ); $server->listen(); You could also compose them in an Application instance, and utilize run() : $app = AppFactory::create(); $app->pipe('/blog', $blog); $app->pipe('/api', $api); $app->run(); This approach allows you to develop discrete applications and compose them together to create a website.","title":"Examples"},{"location":"v1/reference/usage-examples/#usage-examples","text":"Below are several usage examples, covering a variety of ways of creating and managing an application. In all examples, the assumption is the following directory structure: . \u251c\u2500\u2500 config \u251c\u2500\u2500 data \u251c\u2500\u2500 composer.json \u251c\u2500\u2500 public \u2502 \u2514\u2500\u2500 index.php \u251c\u2500\u2500 src \u2514\u2500\u2500 vendor We assume also that: You have installed zend-expressive per the installation instructions . public/ will be the document root of your application. Your own classes are under src/ with the top-level namespace Application , and you have configured autoloading in your composer.json for those classes.","title":"Usage Examples"},{"location":"v1/reference/usage-examples/#hello-world-using-a-container","text":"Expressive works with container-interop , though it's an optional feature. By default, if you use the AppFactory , it will use zend-servicemanager . In the following example, we'll populate the container with our middleware, and the application will pull it from there when matched. Edit your public/index.php to read as follows: use Zend\\Diactoros\\Response\\JsonResponse; use Zend\\Expressive\\AppFactory; use Zend\\ServiceManager\\ServiceManager; require __DIR__ . '/../vendor/autoload.php'; $container = new ServiceManager(); $container->setFactory('HelloWorld', function ($container) { return function ($req, $res, $next) { $res->getBody()->write('Hello, world!'); return $res; }; }); $container->setFactory('Ping', function ($container) { return function ($req, $res, $next) { return new JsonResponse(['ack' => time()]); }; }); $app = AppFactory::create($container); $app->get('/', 'HelloWorld'); $app->get('/ping', 'Ping'); $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); $app->run(); In the example above, we pass our container to AppFactory . We could have also done this instead: $app = AppFactory::create(); $container = $app->getContainer(); and then added our service definitions. We recommend passing the container to the factory instead; if we ever change which container we use by default, your code might not work! The following two lines are the ones of interest: $app->get('/', 'HelloWorld'); $app->get('/ping', 'Ping'); These map the two paths to service names instead of callables. When routing matches a path, it does the following: If the middleware provided when defining the route is callable, it uses it directly. If the middleware is a valid service name in the container, it pulls it from the container. This is what happens in this example. Finally, if no container is available, or the service name is not found in the container, it checks to see if it's a valid class name; if so, it instantiates and returns the class instance. If you fire up your web server, you'll find that the / and /ping paths continue to work. One other approach you could take would be to define the application itself in the container, and then pull it from there: $container->setFactory('Zend\\Expressive\\Application', function ($container) { $app = AppFactory::create($container); $app->get('/', 'HelloWorld'); $app->get('/ping', 'Ping'); return $app; }); $app = $container->get('Zend\\Expressive\\Application'); $app->run(); This is a nice way to encapsulate the application creation. You could then potentially move all service configuration to another file! (We already document an ApplicationFactory for exactly this scenario. )","title":"Hello World using a Container"},{"location":"v1/reference/usage-examples/#hello-world-using-a-configuration-driven-container","text":"In the above example, we configured our middleware as services, and then passed our service container to the application. At the end, we hinted that you could potentially define the application itself as a service. Expressive already provides a service factory for the application instance to provide fine-grained control over your application. In this example, we'll leverage it, defining our routes via configuration. First, we're going to leverage zend-config to merge configuration files. This is important, as it allows us to define local, environment-specific configuration in files that we then can exclude from our repository. This practice ensures that things like credentials are not accidentally published in a public repository, and also provides a mechanism for slip-streaming in configuration based on our environment (you might use different settings in development than in production, after all!). First, install zend-config and zend-stdlib: $ composer require zendframework/zend-config zendframework/zend-stdlib Now we can start creating our configuration files and container factories. In config/config.php , place the following: <?php use Zend\\Stdlib\\ArrayUtils; use Zend\\Stdlib\\Glob; $config = []; // Load configuration from autoload path foreach (Glob::glob('config/autoload/{{,*.}global,{,*.}local}.php', Glob::GLOB_BRACE) as $file) { $config = ArrayUtils::merge($config, include $file); } // Return an ArrayObject so we can inject the config as a service in Aura.Di // and still use array checks like ``is_array``. return new ArrayObject($config, ArrayObject::ARRAY_AS_PROPS); In config/container.php , place the following: <?php use Zend\\ServiceManager\\Config; use Zend\\ServiceManager\\ServiceManager; // Load configuration $config = require __DIR__.'/config.php'; // Build container $container = new ServiceManager(); (new Config($config['dependencies']))->configureServiceManager($container); // Inject config $container->setService('config', $config); return $container; In config/autoload/dependencies.global.php , place the following: <?php use Zend\\ServiceManager\\Factory\\InvokableFactory; return [ 'dependencies' => [ 'invokables' => [ \\Application\\HelloWorldAction::class => InvokableFactory::class, \\Application\\PingAction::class => InvokableFactory::class, ], 'factories' => [ \\Zend\\Expressive\\Application::class => \\Zend\\Expressive\\Container\\ApplicationFactory::class, ], ] ]; In config/autoload/routes.global.php , place the following: <?php return [ 'routes' => [ [ 'path' => '/', 'middleware' => \\Application\\HelloWorldAction::class, 'allowed_methods' => [ 'GET' ], ], [ 'path' => '/ping', 'middleware' => \\Application\\PingAction::class, 'allowed_methods' => [ 'GET' ], ], ], ]; In src/Application/HelloWorld.php , place the following: <?php namespace Application; class HelloWorld { public function __invoke($req, $res, $next) { $res->getBody()->write('Hello, world!'); return $res; } } In src/Application/Ping.php , place the following: <?php namespace Application; use Zend\\Diactoros\\Response\\JsonResponse; class Ping { public function __invoke($req, $res, $next) { return new JsonResponse(['ack' => time()]); } } After that\u2019s done run: composer dump-autoload Finally, in public/index.php , place the following: <?php // Change to the project root, to simplify resolving paths chdir(dirname(__DIR__)); // Setup autoloading require 'vendor/autoload.php'; $container = include 'config/services.php'; $app = $container->get(Zend\\Expressive\\Application::class); $app->run(); Notice that our index file now doesn't have any code related to setting up the application any longer! All it does is setup autoloading, retrieve our service container, pull the application from it, and run it. Our choices for container, router, etc. are all abstracted, and if we change our mind later, this code will continue to work. Firing up the web server, you'll see the same responses as the previous examples.","title":"Hello World using a Configuration-Driven Container"},{"location":"v1/reference/usage-examples/#hybrid-container-and-programmatic-creation","text":"The above example may look a little daunting at first. By making everything configuration-driven, you sometimes lose a sense for how the code all fits together. Fortunately, you can mix the two. Building on the example above, we'll add a new route and middleware. Between pulling the application from the container and calling $app->run() , add the following in your public/index.php : $app->post('/post', function ($req, $res, $next) { $res->getBody()->write('IN POST!'); return $res; }); Note that we're using post() here; that means you'll have to use cURL, HTTPie, Postman, or some other tool to test making a POST request to the path: $ curl -X POST http://localhost:8080/post You should see IN POST! for the response! Using this approach, you can build re-usable applications that are container-driven, and add one-off routes and middleware as needed.","title":"Hybrid Container and Programmatic Creation"},{"location":"v1/reference/usage-examples/#segregating-your-application-to-a-subpath","text":"One benefit of a middleware-based application is the ability to compose middleware and segregate them by paths. Zend\\Expressive\\Application is itself middleware, allowing you to do exactly that if desired. In the following example, we'll assume that $api and $blog are Zend\\Expressive\\Application instances, and compose them into a Zend\\Stratigility\\MiddlewarePipe . use Zend\\Diactoros\\Server; use Zend\\Diactoros\\ServerRequestFactory; use Zend\\Stratigility\\MiddlewarePipe; require __DIR__ . '/../vendor/autoload.php'; $app = new MiddlewarePipe(); $app->pipe('/blog', $blog); $app->pipe('/api', $api); $server = Server::createServerFromRequest( $app, ServerRequestFactory::fromGlobals() ); $server->listen(); You could also compose them in an Application instance, and utilize run() : $app = AppFactory::create(); $app->pipe('/blog', $blog); $app->pipe('/api', $api); $app->run(); This approach allows you to develop discrete applications and compose them together to create a website.","title":"Segregating your application to a subpath"},{"location":"v1/reference/migration/rc-to-v1/","text":"Migration from RC5 or earlier RC6 introduced changes to the following: The routing middleware was split into separate middleware, one for routing, and one for dispatching. Due to the above change, we decided to remove auto-registration of routing middleware. The above change also suggested an alternative to the middleware pipeline configuration that simplifies it. Route result observers are deprecated, and no longer triggered for routing failures. Middleware configuration specifications now accept a priority key to guarantee the order of items. If you have defined your middleware pipeline in multiple files that are then merged, you will need to defined these keys to ensure order. Routing and Dispatch middleware Prior to RC6, the routing middleware: performed routing notified route result observers created a new request that composed the matched routing parameters as request attributes, and composed the route result instance itself as a request attribute. marshaled the middleware matched by routing dispatched the marshaled middleware To provide a better separation of concerns, we split the routing middleware into two distinct methods: routingMiddleware() and dispatchMiddleware() . routingMiddleware() performs the following duties: routing; and creating a new request that composes the matched routing parameters as request attributes, and composes the route result instance itself as a request attribute. dispatchMiddleware() performs the following duties: marshaling the middleware specified in the route result; and dispatching the marshaled middleware. One reason for this split is to allow injecting middleware to operate between routing and dispatch. As an example, you could have middleware that determines if a matched route requires an authenticated identity: public function __invoke($request, $response, $next) { $result = $request->getAttribute(RouteResult::class); if (! in_array($result->getMatchedRouteName(), $this->authRequired)) { return $next($request, $response); } if (! $this->authenticated) { return $next($request, $response->withStatus(401), 'authentication required'); } } The above could then be piped between the routing and dispatch middleware: $app->pipeRoutingMiddleware(); $app->pipe(AuthenticationMiddleware::class); $app->pipeDispatchMiddleware(); Since the routing middleware has been split, we determined we could no longer automatically pipe the routing middleware; detection would require detecting both sets of middleware, and ensuring they are in the correct order. Additionally, since one goal of splitting the middleware is to allow substitutions for these responsibilities, auto-injection could in some cases be undesired. As a result, we now require you to inject each manually. Impact This change will require changes in your application. If you are using Expressive programmatically (i.e., you are not using a container and the Zend\\Expressive\\Container\\ApplicationFactory ), you are now required to call Application::pipeRoutingMiddleware() . Additionally, a new method, Application::pipeDispatchMiddleware() exists for injecting the application with the dispatch middleware, this, too, must be called. This has a fortunate side effect: registering routed middleware no longer affects the middleware pipeline order. As such, you can register your pipeline first or last prior to running the application. The only stipulation is that unless you register the routing and dispatch middleware, your routed middleware will not be executed! As such, the following two lines must be added to your application prior to calling Application::run() : $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); If you are creating your Application instance using a container and the Zend\\Expressive\\Container\\ApplicationFactory , you will need to update your configuration to list the routing and dispatch middleware. The next section details the configuration changes necessary. ApplicationFactory configuration changes As noted in the document summary, the middleware pipeline configuration was changed starting in RC6. The changes are done in such a way as to honor configuration from RC5 and earlier, but using such configuration will now prompt you to update your application. RC5 and earlier defined the default middleware_pipeline configuration as follows: return [ 'middleware_pipeline' => [ // An array of middleware to register prior to registration of the // routing middleware 'pre_routing' => [ //[ // Required: // 'middleware' => 'Name or array of names of middleware services and/or callables', // Optional: // 'path' => '/path/to/match', // 'error' => true, //], [ 'middleware' => [ Helper\\ServerUrlMiddleware::class, Helper\\UrlHelperMiddleware::class, ], ], ], // An array of middleware to register after registration of the // routing middleware 'post_routing' => [ //[ // Required: // 'middleware' => 'Name of middleware service, or a callable', // Optional: // 'path' => '/path/to/match', // 'error' => true, //], ], ], ]; The following changes have been made: The concept of pre_routing and post_routing have been deprecated, and will be removed starting with the 1.1 version. A single middleware pipeline is now provided, though any individual specification can also specify an array of middleware . The routing and dispatch middleware must now be added to your configuration for them to be added to your application. Middleware specifications can now optionally provide a priority key, with 1 being the default. High integer priority indicates earlier execution, while low/negative integer priority indicates later execution. Items with the same priority are executed in the order they are registered. Priority is now how you can indicate the order in which middleware should execute. Impact While the configuration from RC5 and earlier will continue to work, it will raise deprecation notices. As such, you will need to update your configuration to follow the guidelines created with RC6. RC6 and later change the configuration to remove the pre_routing and post_routing keys. However, individual items within the array retain the same format as middleware inside those keys, with the addition of a new key, priority : [ // Required: 'middleware' => 'Name of middleware service, or a callable', // Optional: // 'path' => '/path/to/match', // 'error' => true, // 'priority' => 1, // integer ] The priority key is used to determine the order in which middleware is piped to the application. Higher integer values are piped earlier, while lower/negative integer values are piped later; middleware with the same priority are piped in the order in which they are discovered in the pipeline. The default priority used is 1. Additionally, the routing and dispatch middleware now become items in the array; they (or equivalent entries for your own implementations) must be present in your configuration if you want your routed middleware to dispatch! This change gives you full control over the flow of the pipeline. To specify the routing middleware, use the constant Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE in place of a middleware array; this has the value EXPRESSIVE_ROUTING_MIDDLEWARE , if you do not want to import the class. Similarly, for the dispatch middleware, use the constant Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE (value EXPRESSIVE_DISPATCH_MIDDLEWARE ) to specify the dispatch middleware. As such, the default configuration now becomes: return [ 'middleware_pipeline' => [ // An array of middleware to pipe to the application. // Each item is of the following structure: // [ // // Required: // 'middleware' => 'Name or array of names of middleware services and/or callables', // // Optional: // 'path' => '/path/to/match', // 'error' => true, // ], [ 'middleware' => [ Helper\\ServerUrlMiddleware::class, ], 'priority' => PHP_INT_MAX, ], // The following is an entry for: // - routing middleware // - middleware that reacts to the routing results // - dispatch middleware [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Helper\\UrlHelperMiddleware::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ] // The following is an entry for the dispatch middleware: // Place error handling middleware after the routing and dispatch // middleware, with negative priority. // [ // 'middleware' => [ // ], // 'priority' => -1000, // ], ], ]; To update an existing application: Promote all pre_routing middleware up a level, and remove the pre_routing key. Provide a priority value greater than 1. We recommend having a single middleware specification with an array of middleware that represents the \"pre routing\" middleware. Add the entries for Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE and Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE immediately following any pre_routing middleware, and before any post_routing middleware; we recommend grouping it per the above example. Promote all post_routing middleware up a level, and remove the post_routing key. Provide a priority value less than 1 or negative. If you have middleware_pipeline specifications in multiple files , you will need to specify priority keys for all middleware in order to guarantee order after merging. We recommend having a single middleware specification with an array of middleware that represents the \"post routing\" middleware. As an example, consider the following application configuration: return [ 'middleware_pipeline' => [ 'pre_routing' => [ [ 'middleware' => [ Zend\\Expressive\\Helper\\ServerUrlMiddleware::class, Zend\\Expressive\\Helper\\UrlHelperMiddleware::class, ], ], [ 'middleware' => DebugToolbarMiddleware::class ], [ 'middleware' => ApiMiddleware::class, 'path' => '/api', ], ], 'post_routing' => [ ['middleware' => NotFoundMiddleware::class, 'error' => true], ], ], ]; This would be rewritten to the following to work with RC6 and later: return [ 'middleware_pipeline' => [ 'always' => [ 'middleware' => [ Zend\\Expressive\\Helper\\ServerUrlMiddleware::class, DebugToolbarMiddleware::class, ], 'priority' => PHP_INT_MAX, ], 'api' => [ 'middleware' => ApiMiddleware::class, 'path' => '/api', 'priority' => 100, ], 'routing' => [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Zend\\Expressive\\Helper\\UrlHelperMiddleware::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], 'error' => [ 'middleware' => [ NotFoundMiddleware::class, ], 'error' => true, 'priority' => -1000, ], ], ] Note in the above example the various groupings. By grouping middleware by priority, you can simplify adding new middleware, particularly if you know it should execute before routing, or as error middleware, or between routing and dispatch. Keys are ignored The above example provides keys for each middleware specification. The factory will ignore these, but they can be useful for cases when you might want to specify configuration in multiple files, and merge specific entries together. Be aware, however, that the middleware key itself is an indexed array; items will be appended based on the order in which configuration files are merged. If order of these is important, create separate specifications with relevant priority values. Route result observer deprecation As of RC6, the following changes have occurred with regards to route result observers: They are deprecated for usage with Zend\\Expressive\\Application , and that class will not be a route result subject starting in 1.1. You will need to start migrating to alternative solutions. The functionality for notifying observers has been moved from the routing middleware into a dedicated Application::routeResultObserverMiddleware() method. This middleware must be piped separately to the middleware pipeline for it to trigger. Impact If you are using any route result observers, you will need to ensure your application notifies them, and you will want to migrate to alternative solutions to ensure your functionality continues to work. To ensure your observers are triggered, you will need to adapt your application, based on how you create your instance. If you are not using the ApplicationFactory , you will need to pipe the routeResultObserverMiddleware to your application, between the routing and dispatch middleware: $app->pipeRoutingMiddleware(); $app->pipeRouteResultObserverMiddleware(); $app->pipeDispatchMiddleware(); If you are using the ApplicationFactory , you may need to update your configuration to allow injecting the route result observer middleware. If you have not updated your configuration to remove the pre_routing and/or post_routing keys, the middleware will be registered for you. If you have, however, you will need to register it following the routing middleware: [ 'middleware_pipeline' => [ /* ... */ 'routing' => [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Zend\\Expressive\\Container\\ApplicationFactory::ROUTE_RESULT_OBSERVER_MIDDLEWARE, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], /* ... */ ], ] To make your observers forwards-compatible requires two changes: Rewriting your observer as middleware. Registering your observer as middleware following the routing middleware. If your observer looked like the following: use Zend\\Expressive\\Router\\RouteResult; use Zend\\Expressive\\Router\\RouteResultObserverInterface; class MyObserver implements RouteResultObserverInterface { private $logger; public function __construct(Logger $logger) { $this->logger = $logger; } public function update(RouteResult $result) { $this->logger->log($result); } } You could rewrite it as follows: use Zend\\Expressive\\Router\\RouteResult; class MyObserver { private $logger; public function __construct(Logger $logger) { $this->logger = $logger; } public function __invoke($request, $response, $next) { $result = $request->getAttribute(RouteResult::class, false); if (! $result) { return $next($request, $response); } $this->logger->log($result); return $next($request, $response); } } You would then register it following the routing middleware. If you are building your application programmatically, you would do this as follows: $app->pipeRoutingMiddleware(); $app->pipe(MyObserver::class); $app->pipeDispatchMiddleware(); If you are using the ApplicationFactory , alter your configuration: [ 'middleware_pipeline' => [ /* ... */ 'routing' => [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, MyObserver::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], /* ... */ ], ] Timeline for migration The following features will be removed in version 1.1.0: Support for the pre_routing and post_routing configuration. Support for route result observers.","title":"From RC5 and Earlier"},{"location":"v1/reference/migration/rc-to-v1/#migration-from-rc5-or-earlier","text":"RC6 introduced changes to the following: The routing middleware was split into separate middleware, one for routing, and one for dispatching. Due to the above change, we decided to remove auto-registration of routing middleware. The above change also suggested an alternative to the middleware pipeline configuration that simplifies it. Route result observers are deprecated, and no longer triggered for routing failures. Middleware configuration specifications now accept a priority key to guarantee the order of items. If you have defined your middleware pipeline in multiple files that are then merged, you will need to defined these keys to ensure order.","title":"Migration from RC5 or earlier"},{"location":"v1/reference/migration/rc-to-v1/#routing-and-dispatch-middleware","text":"Prior to RC6, the routing middleware: performed routing notified route result observers created a new request that composed the matched routing parameters as request attributes, and composed the route result instance itself as a request attribute. marshaled the middleware matched by routing dispatched the marshaled middleware To provide a better separation of concerns, we split the routing middleware into two distinct methods: routingMiddleware() and dispatchMiddleware() . routingMiddleware() performs the following duties: routing; and creating a new request that composes the matched routing parameters as request attributes, and composes the route result instance itself as a request attribute. dispatchMiddleware() performs the following duties: marshaling the middleware specified in the route result; and dispatching the marshaled middleware. One reason for this split is to allow injecting middleware to operate between routing and dispatch. As an example, you could have middleware that determines if a matched route requires an authenticated identity: public function __invoke($request, $response, $next) { $result = $request->getAttribute(RouteResult::class); if (! in_array($result->getMatchedRouteName(), $this->authRequired)) { return $next($request, $response); } if (! $this->authenticated) { return $next($request, $response->withStatus(401), 'authentication required'); } } The above could then be piped between the routing and dispatch middleware: $app->pipeRoutingMiddleware(); $app->pipe(AuthenticationMiddleware::class); $app->pipeDispatchMiddleware(); Since the routing middleware has been split, we determined we could no longer automatically pipe the routing middleware; detection would require detecting both sets of middleware, and ensuring they are in the correct order. Additionally, since one goal of splitting the middleware is to allow substitutions for these responsibilities, auto-injection could in some cases be undesired. As a result, we now require you to inject each manually.","title":"Routing and Dispatch middleware"},{"location":"v1/reference/migration/rc-to-v1/#applicationfactory-configuration-changes","text":"As noted in the document summary, the middleware pipeline configuration was changed starting in RC6. The changes are done in such a way as to honor configuration from RC5 and earlier, but using such configuration will now prompt you to update your application. RC5 and earlier defined the default middleware_pipeline configuration as follows: return [ 'middleware_pipeline' => [ // An array of middleware to register prior to registration of the // routing middleware 'pre_routing' => [ //[ // Required: // 'middleware' => 'Name or array of names of middleware services and/or callables', // Optional: // 'path' => '/path/to/match', // 'error' => true, //], [ 'middleware' => [ Helper\\ServerUrlMiddleware::class, Helper\\UrlHelperMiddleware::class, ], ], ], // An array of middleware to register after registration of the // routing middleware 'post_routing' => [ //[ // Required: // 'middleware' => 'Name of middleware service, or a callable', // Optional: // 'path' => '/path/to/match', // 'error' => true, //], ], ], ]; The following changes have been made: The concept of pre_routing and post_routing have been deprecated, and will be removed starting with the 1.1 version. A single middleware pipeline is now provided, though any individual specification can also specify an array of middleware . The routing and dispatch middleware must now be added to your configuration for them to be added to your application. Middleware specifications can now optionally provide a priority key, with 1 being the default. High integer priority indicates earlier execution, while low/negative integer priority indicates later execution. Items with the same priority are executed in the order they are registered. Priority is now how you can indicate the order in which middleware should execute.","title":"ApplicationFactory configuration changes"},{"location":"v1/reference/migration/rc-to-v1/#route-result-observer-deprecation","text":"As of RC6, the following changes have occurred with regards to route result observers: They are deprecated for usage with Zend\\Expressive\\Application , and that class will not be a route result subject starting in 1.1. You will need to start migrating to alternative solutions. The functionality for notifying observers has been moved from the routing middleware into a dedicated Application::routeResultObserverMiddleware() method. This middleware must be piped separately to the middleware pipeline for it to trigger.","title":"Route result observer deprecation"},{"location":"v1/reference/migration/rc-to-v1/#timeline-for-migration","text":"The following features will be removed in version 1.1.0: Support for the pre_routing and post_routing configuration. Support for route result observers.","title":"Timeline for migration"},{"location":"v1/reference/migration/to-v1-1/","text":"Migration to Expressive 1.1 Expressive 1.1 should not result in any upgrade problems for users. However, starting in this version, we offer a few changes affecting the following that you should be aware of, and potentially update your application to adopt: Deprecations Original request and response messages Recommendation to use programmatic pipelines Error handling Deprecations The following classes and/or methods are deprecated with the 1.1.0 release, and will be removed for the 2.0 release: Zend\\Expressive\\Application::pipeErrorHandler() : Stratigility v1 error middleware are removed in the Stratigility v2 release, which Expressive 2.0 will adopt. Zend\\Expressive\\Application::routeMiddleware() : routing middleware moves to a dedicated class starting in Expressive 2.0. If you were referencing the method in order to pipe it as middleware, use pipeRoutingMiddleware() or pipe(ApplicationFactory::ROUTING_MIDDLEWARE) instead. Zend\\Expressive\\Application::dispatchMiddleware() : dispatch middleware moves to a dedicated class starting in Expressive 2.0.If you were referencing the method in order to pipe it as middleware, use pipeDispatchMiddleware() or pipe(ApplicationFactory::DISPATCH_MIDDLEWARE) instead. Zend\\Expressive\\Application::getFinalHandler() : this method gets renamed to getDefaultDelegate() in Expressive 2.0. We recommend retrieving the value from the application dependency injection container if you need it elsewhere. Zend\\Expressive\\Application::raiseThrowables() : this method becomes a no-op in Stratigility 2.0, on which Expressive 2.0 is based; the behavior it enabled becomes the default behavior in that version. Zend\\Expressive\\Container\\Exception\\InvalidArgumentException : this exception type is thrown by ApplicationFactory ; in Expressive 2.0, it throws Zend\\Expressive\\Exception\\InvalidArgumentException instead. Zend\\Expressive\\Container\\Exception\\NotFoundException : this exception type is not currently used anyways. Zend\\Expressive\\ErrorMiddlewarePipe : Stratigility v1 error middleware are removed in the Stratigility v2 release, which Expressive 2.0 will adopt, making this specialized middleware pipe type irrelvant. Zend\\Expressive\\TemplatedErrorHandler and Zend\\Expressive\\WhoopsErrorHandler : The concept of \"final handlers\" will be removed in Expressive 2.0, to be replaced with \"default delegates\" (implementations of Interop\\Http\\ServerMiddleware\\DelegateInterface that will be called if the middleware pipeline is exhausted, and which will be guaranteed to return a response). Expressive 2.0 will provide tooling to upgrade your dependencies to make the transition seamless; end users will only be affected if they were extending these classes. If you were calling any of these directly, or extending or overriding them, you will need to update your code to work for version 2.0. We recommend not using these. Original messages Stratigility 1.3 deprecates its internal request and response decorators, Zend\\Stratigility\\Http\\Request and Zend\\Stratigility\\Http\\Response , respectively. The main utility of these instances was to provide access in inner middleware layers to the original request, original response, and original URI. As such access may still be desired, Stratigility 1.3 introduced Zend\\Stratigility\\Middleware\\OriginalMessages . This middleware injects the following attributes into the request it passes to $next() : originalRequest is the request instance provided to the middleware. originalUri is the URI instance associated with that request. originalResponse is the response instance provided to the middleware. Zend\\Stratigility\\FinalHandler was updated to use these when they're available starting with version 1.0.3. We recommend adding the OriginalMessages middleware as the outermost (first) middleware in your pipeline. Using configuration-driven middleware, that would look like this: // config/autoload/middleware-pipeline.global.php /* ... */ use Zend\\Expressive\\Helper; use Zend\\Stratigility\\Middleware\\OriginalMessages; return [ 'dependencies' => [ 'invokables' => [ OriginalMessages::class => OriginalMessages::class, ], /* ... */ ], 'middleware_pipeline' => [ 'always' => [ 'middleware' => [ OriginalMessages::class, // <----- Add this entry Helper\\ServerUrlMiddleware::class, /* ... */ ], 'priority' => 10000, ], /* ... */ ], ]; If you are programmatically creating your pipeline , use the following: $app->pipe(OriginalMessages::class); /* all other middleware */ Identifying and fixing getOriginal calls To help you identify and update calls in your own code to the getOriginal*() methods, we provide a tool via the zendframework/zend-expressive-tooling package, vendor/bin/expressive-migrate-original-messages . First, install the tooling package; since the tooling it provides is only useful during development, install it as a development requirement: $ composer require --dev zendframework/zend-expressive-tooling Once installed, you can execute the tool using: $ ./vendor/bin/expressive-migrate-original-messages Passing the arguments help , --help , or -h will provide usage information; in most cases, it will assume sane defaults in order to run its scans. The tool updates calls to getOriginalRequest() and getOriginalUri() to instead use the new request attributes that the OriginalMessages middleware injects: getOriginalRequest() becomes getAttribute('originalRequest', $request) getOriginalUri() becomes getAttribute('originalUri', $request->getUri()) In both cases, $request will be replaced with whatever variable name you used for the request instance. For getOriginalResponse() calls, which happen on the response instance, the tool will instead tell you what files had such calls, and detail how you can update those calls to use the originalResponse request attribute. Programmatic middleware pipelines With Expressive 1.0, we recommended creating middleware pipelines and routing via configuration. Starting with 1.1, we recommend programmatic creation of pipelines and routing . Programmatic pipelines exercise the existing Expressive API. Methods include: pipe() allows you to pipe middleware for the pipeline; this can optionally take a $path argument. (If one argument is present, it is assumed to be middleware; with two arguments, the first argument is the $path .) Paths are literal URI path segments. If the incoming request matches that segment, the middleware will execute; otherwise, it will not. These can be used to provide sub-applications with their own routing. pipeRoutingMiddleware() is used to pipe the internal routing middleware into the pipeline. pipeDispatchMiddleware() is used to pipe the internal dispatch middleware into the pipeline. pipeErrorMiddleware() is used to pipe the legacy Stratigility error middleware into the pipeline. We recommend NOT using this method, and instead adapting your application to use standard middleware for error handling . Otherwise, it acts just like pipe() . Starting in Expressive 1.1, this method will emit a deprecation notice. As an example pipeline: $app->pipe(OriginalMessages::class); $app->pipe(Helper\\ServerUrlMiddleware::class); $app->pipe(ErrorHandler::class); $app->pipeRoutingMiddleware(); $app->pipe(Helper\\UrlHelperMiddleware::class); $app->pipeDispatchMiddleware(); $app->pipe(NotFoundHandler::class); Expressive also provides methods for specifying routed middleware. These include: get($path, $middleware, $name = null) post($path, $middleware, $name = null) put($path, $middleware, $name = null) patch($path, $middleware, $name = null) delete($path, $middleware, $name = null) route($path, $middleware, array $methods = null, $name = null) Each returns a Zend\\Expressive\\Router\\Route instance; this is useful if you wish to provide additional options to your route: $app->get('/api/ping', Ping::class) ->setOptions([ 'timestamp' => date(), ]); As an example, the default routes defined in the skeleton application can be written as follows: $app->get('/', \\App\\Action\\HomePageAction::class, 'home'); $app->get('/api/ping', \\App\\Action\\PingAction::class, 'api.ping'); We recommend rewriting your middleware pipeline and routing configuration into programmatic/declarative statements. Specifically: We recommend putting the pipeline declarations into config/pipeline.php . We recommend putting the routing declarations into config/routes.php . Once you've written these, you will then need to make the following changes to your application: First, enable the zend-expressive.programmatic_pipeline configuration flag. This can be done in any config/autoload/*.global.php file: php return [ 'zend-expressive' => [ 'programmatic_pipeline' => true, ], ]; Once enabled, any middleware_pipeline or routes configuration will be ignored when creating the Application instance. Second, update your public/index.php to add the following lines immediately prior to calling $app->run(); : php require 'config/pipeline.php'; require 'config/routes.php'; Once this has been done, the application will use your new programmatic pipelines instead of configuration. You can remove the middleware_pipeline and routes configuration after verifying your application continues to work. For programmatic pipelines to work properly, you will also need to provide error handling middleware, which is discussed in the next section. Error handling Prior to version 1.1, error handling was accomplished via two mechanisms: Stratigility \"error middleware\" (middleware with the signature function ($error, ServerRequestInterface $request, ResponseInterface $response, callable $next) ). This middleware would be invoked when calling $next() with a third argument indicating an error, and would be expected to handle it or delegate to the next error middleware. Internally, Stratigility would execute each middleware within a try/catch block; if an exception were caught, it would then delegate to the next error middleware using the caught exception as the $err argument. The \"Final Handler\". This is a handler invoked when the middleware pipeline is exhausted without returning a response, and has the signature function (ServerRequestInterface $request, ResponseInterface $response, $err = null) ; it is provided to the middleware pipeline when invoking the outermost middleware; in the case of Expressive, it is composed in the Application instance, and passed to the application middleware when it executes run() . When invoked, it needs to decide if invocation is due to no middleware executing (HTTP 404 status), middleware calling $next() with an altered response (response is then returned), or due to invocation of error middleware (calling $next() with the third, error, argument) with no error middleware returning a response. Expressive 1.1 updates the minimum supported Stratigility version to 1.3, which deprecates the concept of error middleware, and recommends a \"final handler\" that does no error handling, but instead returns a canned response (typically a 404). Additionally, it deprecates the practice of wrapping middleware execution in a try/catch block, and provides a flag for disabling that behavior entirely, raise_throwables . Starting in Expressive 1.1, you can set the raise_throwables flag in your configuration: return [ 'zend-expressive' => [ 'raise_throwables' => true, ], ]; When enabled, the internal dispatcher will no longer catch exceptions. This both allows you to, and requires you to, write your own error handling middleware. This will require two things: Middleware with a try/catch block that operates as the outermost (or close to outermost) layer of your application, and which can provide error pages or details to your end users. Middleware at the innermost layer that is guaranteed to return a response; generally, reaching this means no middleware was able to route the request, and thus a 404 condition. The below sections detail approaches to each. Error handling middleware Error handling middleware generally will look something like this: function ( ServerRequestInterface $request, ResponseInterface $response, callable $next ) { try { $response = $next($request, $response); return $response; } catch (\\Throwable $exception) { // caught PHP 7 throwable } catch (\\Exception $exception) { // caught PHP 5 exception } // ... // do something with $exception and generate a response // ... return $response; } Stratigility 1.3 provides such an implementation via its Zend\\Stratigility\\Middleware\\ErrorHandler . In addition to the try/catch block, it also sets up a PHP error handler that will catch any PHP error types in the current error_reporting mask; the error handler will raise exceptions of the type ErrorException with the PHP error details. Stratigility's ErrorHandler allows injection of an \"error response generator\", which allows you to alter how the error response is generated based on the current environment. Error response generators are callables with the signature: function ( Throwable|Exception $e, ServerRequestInterface $request, ResponseInterface $response ) : ResponseInterface We recommend using the Stratigility ErrorHandler and writing and attaching a custom error response generator. As a simple example, the following details a generator that will use a template to display an error page: namespace Acme; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class TemplatedErrorResponseGenerator { const TEMPLATE_DEFAULT = 'error::error'; private $renderer; private $template; public function __construct( TemplateRendererInterface $renderer, $template = TEMPLATE_DEFAULT ) { $this->renderer = $renderer; $this->template = $template; } public function __invoke( $e, ServerRequestInterface $request, ResponseInterface $response ) { $response->write($this->renderer->render($this->template, [ 'exception' => $e, 'request' => $request, ])); return $response; } } You might then create a factory for generating the ErrorHandler and attaching this response generator as follows: namespace Acme\\Container; use Acme\\TemplatedErrorResponseGenerator; use Interop\\Container\\ContainerInterface; use Zend\\Diactoros\\Response; use Zend\\Expressive\\Template\\TemplateRendererInterface; use Zend\\Stratigility\\Middleware\\ErrorHandler; class ErrorHandlerFactory { public function __invoke(ContainerInterface $container) { $generator = new TemplatedErrorResponseGenerator( $container->get(TemplateRendererInterface::class) ); return new ErrorHandler(new Response(), $generator); } } Once that is created you can tell your middleware configuration about it: // in config/autoload/middleware-pipeline.global.php use Acme\\Container\\ErrorHandlerFactory; use Zend\\Stratigility\\Middleware\\ErrorHandler; return [ 'dependencies' => [ /* ... */ 'factories' => [ ErrorHandler::class => ErrorHandlerFactory::class, /* ... */ ], /* ... */ ], 'middleware_pipeline' => [ 'always' => [ 'middleware' => [ ErrorHandler::class, /* ... */ ], 'priority' => 10000, ], /* ... */ ], ]; Alternately, if using a programmatic pipeline, as detailed in the previous section, you can use the following: use Zend\\Stratigility\\Middleware\\ErrorHandler; $app->pipe(ErrorHandler::class); // add all other middleware after it Not Found middleware At the innermost layer of your application, you need middleware guaranteed to return a response; typically, this indicates a failure to route the request, and, as such, an HTTP 404 response. Zend\\Stratigility\\Middleware\\NotFoundHandler provides an implementation, but is written such that the response body remains empty. As such, you might write a custom, templated handler: namespace Acme; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response; use Zend\\Expressive\\Template\\TemplateRendererInterface; class TemplatedNotFoundHandler { const TEMPLATE_DEFAULT = 'error::404'; private $renderer; private $template; public function __construct( TemplateRendererInterface $renderer, $template = self::TEMPLATE_DEFAULT ) { $this->renderer = $renderer; $this->template = $template; } public function __invoke( ServerRequestInterface $request, ResponseInterface $response, callable $next ) { $response = new Response(); $response->write($this->renderer->render($this->template)); return $response->withStatus(404); } } Similar to the discussion of the ErrorHandler above, we'll create a factory for this: namespace Acme\\Container; use Acme\\TemplatedNotFoundHandler; use Interop\\Container\\ContainerInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class TemplatedNotFoundHandlerFactory { public function __invoke(ContainerInterface $container) { return new TemplatedNotFoundHandler( $container->get(TemplateRendererInterface::class) ); } } We can then register it in our pipeline: // in config/autoload/middleware-pipeline.global.php use Acme\\Container\\NotFoundHandlerFactory; use Acme\\TemplatedNotFoundHandler; return [ 'dependencies' => [ /* ... */ 'factories' => [ TemplatedNotFoundHandler::class => TemplatedNotFoundHandlerFactory::class, /* ... */ ], /* ... */ ], 'middleware_pipeline' => [ /* ... */ // After 'routing', but before 'error'; // alternately as last item in 'routing' middleware list. 'not-found' => [ 'middleware' => TemplatedNotFoundHandler::class, 'priority' => 0, ], /* ... */ ], ]; If you are using programmatic pipelines, as described in the previous section: use Acme\\TemplatedNotFoundHandler; // all other pipeline directives, and then: $app->pipe(TemplatedNotFoundHandler::class); Detecting error middleware usage If you use the new error handling paradigm, we recommend that you also audit your application for legacy Stratigility error middleware, as well as invocation of error middleware. To do this, we provide a tool via the zendframework/zend-expressive-tooling package, vendor/bin/expressive-scan-for-error-middleware . First, install the tooling as a development requirement: $ composer require --dev zendframework/zend-expressive-tooling The tool will scan the src/ directory by default, but allows you to scan other directories via the --dir flag. It will detect and report files with any of the following: Classes implementing Zend\\Stratigility\\ErrorMiddlewareInterface . Invokable classes implementing the error middleware signature. Methods accepting $next that invoke it with an error argument. As an example running it: $ ./vendor/bin/expressive-scan-for-error-middleware scan # or, with a directory argument: $ ./vendor/bin/expressive-scan-for-error-middleware scan --dir ./lib You may also call the tool using its help command, or either of the --help or -h flags to get full usage information. Use this tool to identify potential problem areas in your application, and update your code to use the new error handling facilities as outlined above. Full example Putting all of the above together \u2014 original message memoizing , programmatic pipelines , and middleware-based error handling \u2014 might look like the following examples. First, we'll tell Expressive to use programmatic pipelines, and to enable the new error handling (by telling it to \"raise throwables\", instead of catching them): // In config/autoload/zend-expressive.global.php: return [ /* ... */ 'zend-expressive' => [ 'programmatic_pipeline' => true, 'raise_throwables' => true, /* ... */ ], ]; Next, we'll update config/autoload/middleware-pipeline.global.php to list only dependencies: use Acme\\Container; use Acme\\TemplatedNotFoundHandler; use Zend\\Expressive\\Container\\ApplicationFactory; use Zend\\Expressive\\Helper; use Zend\\Stratigility\\Middleware\\ErrorHandler; use Zend\\Stratigility\\Middleware\\OriginalMessages; return [ 'dependencies' => [ 'invokables' => [ OriginalMessages::class => OriginalMesssages::class, ], 'factories' => [ ErrorHandler::class => Container\\ErrorHandlerFactory::class, Helper\\ServerUrlMiddleware::class => Helper\\ServerUrlMiddlewareFactory::class, Helper\\UrlHelperMiddleware::class => Helper\\UrlHelperMiddlewareFactory::class, TemplatedNotFoundHandler::class => Container\\TemplatedNotFoundHandlerFactory::class, ], ], ]; We'll also update config/autoload/routes.global.php to only list dependencies; in the following example, we list only the middleware shipped by default with the skeleton application: use App\\Action; use Zend\\Expressive\\Router\\FastRouteRouter; use Zend\\Expressive\\Router\\RouterInterface; return [ 'dependencies' => [ 'invokables' => [ RouterInterface::class => FastRouteRouter::class, Action\\PingAction::class => Action\\PingAction::class, ], 'factories' => [ Action\\HomePageAction::class => Action\\HomePageFactory::class, ], ], ]; To create our pipeline, we will create the file config/pipeline.php : use Acme\\TemplatedNotFoundHandler; use Zend\\Expressive\\Container\\ApplicationFactory; use Zend\\Expressive\\Helper; use Zend\\Stratigility\\Middleware\\ErrorHandler; use Zend\\Stratigility\\Middleware\\OriginalMessages; $app->pipe(OriginalMessages::class); $app->pipe(ErrorHandler::class); $app->pipe(Helper\\ServerUrlMiddleware::class); $app->pipe([ ApplicationFactory::ROUTING_MIDDLEWARE, Helper\\UrlHelperMiddleware::class, ApplicationFactory::DISPATCH_MIDDLEWARE, ]); $app->pipe(TemplatedNotFoundHandler::class); Note that you can use arrays of middleware just like you did in the configuration; this allows you to separate middleware into logical groups if desired! To provide our routed middleware, we will create the file config/pipeline.php : use App\\Action; $app->get('/', Action\\HomePageAction::class, 'home'); $app->get('/api/ping', Action\\PingAction::class, 'api.ping'); The above exercises the various routing methods of the Application class. Finally, we will need to update our public/index.php , to tell it to require our new pipeline and routing files; we'll do that between retrieving the application from the container, and running the application: $app = $container->get(\\Zend\\Expressive\\Application::class); require 'config/pipeline.php'; require 'config/routes.php'; $app->run(); With these changes in place, your application should continue to run as it did previously! Looking forward Expressive 2.0 will ship error handling middleware and \"not found\" middleware, as well as tools to convert your application to a programmatic pipeline in such a way as to utilize these shipped implementations. In the meantime, however, you can adopt programmatic pipelines and the new error handling paradigm within the version 1 series using the configuration flags and guidelines listed above in order to make your application forwards-compatible.","title":"To Expressive 1.1"},{"location":"v1/reference/migration/to-v1-1/#migration-to-expressive-11","text":"Expressive 1.1 should not result in any upgrade problems for users. However, starting in this version, we offer a few changes affecting the following that you should be aware of, and potentially update your application to adopt: Deprecations Original request and response messages Recommendation to use programmatic pipelines Error handling","title":"Migration to Expressive 1.1"},{"location":"v1/reference/migration/to-v1-1/#deprecations","text":"The following classes and/or methods are deprecated with the 1.1.0 release, and will be removed for the 2.0 release: Zend\\Expressive\\Application::pipeErrorHandler() : Stratigility v1 error middleware are removed in the Stratigility v2 release, which Expressive 2.0 will adopt. Zend\\Expressive\\Application::routeMiddleware() : routing middleware moves to a dedicated class starting in Expressive 2.0. If you were referencing the method in order to pipe it as middleware, use pipeRoutingMiddleware() or pipe(ApplicationFactory::ROUTING_MIDDLEWARE) instead. Zend\\Expressive\\Application::dispatchMiddleware() : dispatch middleware moves to a dedicated class starting in Expressive 2.0.If you were referencing the method in order to pipe it as middleware, use pipeDispatchMiddleware() or pipe(ApplicationFactory::DISPATCH_MIDDLEWARE) instead. Zend\\Expressive\\Application::getFinalHandler() : this method gets renamed to getDefaultDelegate() in Expressive 2.0. We recommend retrieving the value from the application dependency injection container if you need it elsewhere. Zend\\Expressive\\Application::raiseThrowables() : this method becomes a no-op in Stratigility 2.0, on which Expressive 2.0 is based; the behavior it enabled becomes the default behavior in that version. Zend\\Expressive\\Container\\Exception\\InvalidArgumentException : this exception type is thrown by ApplicationFactory ; in Expressive 2.0, it throws Zend\\Expressive\\Exception\\InvalidArgumentException instead. Zend\\Expressive\\Container\\Exception\\NotFoundException : this exception type is not currently used anyways. Zend\\Expressive\\ErrorMiddlewarePipe : Stratigility v1 error middleware are removed in the Stratigility v2 release, which Expressive 2.0 will adopt, making this specialized middleware pipe type irrelvant. Zend\\Expressive\\TemplatedErrorHandler and Zend\\Expressive\\WhoopsErrorHandler : The concept of \"final handlers\" will be removed in Expressive 2.0, to be replaced with \"default delegates\" (implementations of Interop\\Http\\ServerMiddleware\\DelegateInterface that will be called if the middleware pipeline is exhausted, and which will be guaranteed to return a response). Expressive 2.0 will provide tooling to upgrade your dependencies to make the transition seamless; end users will only be affected if they were extending these classes. If you were calling any of these directly, or extending or overriding them, you will need to update your code to work for version 2.0. We recommend not using these.","title":"Deprecations"},{"location":"v1/reference/migration/to-v1-1/#original-messages","text":"Stratigility 1.3 deprecates its internal request and response decorators, Zend\\Stratigility\\Http\\Request and Zend\\Stratigility\\Http\\Response , respectively. The main utility of these instances was to provide access in inner middleware layers to the original request, original response, and original URI. As such access may still be desired, Stratigility 1.3 introduced Zend\\Stratigility\\Middleware\\OriginalMessages . This middleware injects the following attributes into the request it passes to $next() : originalRequest is the request instance provided to the middleware. originalUri is the URI instance associated with that request. originalResponse is the response instance provided to the middleware. Zend\\Stratigility\\FinalHandler was updated to use these when they're available starting with version 1.0.3. We recommend adding the OriginalMessages middleware as the outermost (first) middleware in your pipeline. Using configuration-driven middleware, that would look like this: // config/autoload/middleware-pipeline.global.php /* ... */ use Zend\\Expressive\\Helper; use Zend\\Stratigility\\Middleware\\OriginalMessages; return [ 'dependencies' => [ 'invokables' => [ OriginalMessages::class => OriginalMessages::class, ], /* ... */ ], 'middleware_pipeline' => [ 'always' => [ 'middleware' => [ OriginalMessages::class, // <----- Add this entry Helper\\ServerUrlMiddleware::class, /* ... */ ], 'priority' => 10000, ], /* ... */ ], ]; If you are programmatically creating your pipeline , use the following: $app->pipe(OriginalMessages::class); /* all other middleware */","title":"Original messages"},{"location":"v1/reference/migration/to-v1-1/#programmatic-middleware-pipelines","text":"With Expressive 1.0, we recommended creating middleware pipelines and routing via configuration. Starting with 1.1, we recommend programmatic creation of pipelines and routing . Programmatic pipelines exercise the existing Expressive API. Methods include: pipe() allows you to pipe middleware for the pipeline; this can optionally take a $path argument. (If one argument is present, it is assumed to be middleware; with two arguments, the first argument is the $path .) Paths are literal URI path segments. If the incoming request matches that segment, the middleware will execute; otherwise, it will not. These can be used to provide sub-applications with their own routing. pipeRoutingMiddleware() is used to pipe the internal routing middleware into the pipeline. pipeDispatchMiddleware() is used to pipe the internal dispatch middleware into the pipeline. pipeErrorMiddleware() is used to pipe the legacy Stratigility error middleware into the pipeline. We recommend NOT using this method, and instead adapting your application to use standard middleware for error handling . Otherwise, it acts just like pipe() . Starting in Expressive 1.1, this method will emit a deprecation notice. As an example pipeline: $app->pipe(OriginalMessages::class); $app->pipe(Helper\\ServerUrlMiddleware::class); $app->pipe(ErrorHandler::class); $app->pipeRoutingMiddleware(); $app->pipe(Helper\\UrlHelperMiddleware::class); $app->pipeDispatchMiddleware(); $app->pipe(NotFoundHandler::class); Expressive also provides methods for specifying routed middleware. These include: get($path, $middleware, $name = null) post($path, $middleware, $name = null) put($path, $middleware, $name = null) patch($path, $middleware, $name = null) delete($path, $middleware, $name = null) route($path, $middleware, array $methods = null, $name = null) Each returns a Zend\\Expressive\\Router\\Route instance; this is useful if you wish to provide additional options to your route: $app->get('/api/ping', Ping::class) ->setOptions([ 'timestamp' => date(), ]); As an example, the default routes defined in the skeleton application can be written as follows: $app->get('/', \\App\\Action\\HomePageAction::class, 'home'); $app->get('/api/ping', \\App\\Action\\PingAction::class, 'api.ping'); We recommend rewriting your middleware pipeline and routing configuration into programmatic/declarative statements. Specifically: We recommend putting the pipeline declarations into config/pipeline.php . We recommend putting the routing declarations into config/routes.php . Once you've written these, you will then need to make the following changes to your application: First, enable the zend-expressive.programmatic_pipeline configuration flag. This can be done in any config/autoload/*.global.php file: php return [ 'zend-expressive' => [ 'programmatic_pipeline' => true, ], ]; Once enabled, any middleware_pipeline or routes configuration will be ignored when creating the Application instance. Second, update your public/index.php to add the following lines immediately prior to calling $app->run(); : php require 'config/pipeline.php'; require 'config/routes.php'; Once this has been done, the application will use your new programmatic pipelines instead of configuration. You can remove the middleware_pipeline and routes configuration after verifying your application continues to work. For programmatic pipelines to work properly, you will also need to provide error handling middleware, which is discussed in the next section.","title":"Programmatic middleware pipelines"},{"location":"v1/reference/migration/to-v1-1/#error-handling","text":"Prior to version 1.1, error handling was accomplished via two mechanisms: Stratigility \"error middleware\" (middleware with the signature function ($error, ServerRequestInterface $request, ResponseInterface $response, callable $next) ). This middleware would be invoked when calling $next() with a third argument indicating an error, and would be expected to handle it or delegate to the next error middleware. Internally, Stratigility would execute each middleware within a try/catch block; if an exception were caught, it would then delegate to the next error middleware using the caught exception as the $err argument. The \"Final Handler\". This is a handler invoked when the middleware pipeline is exhausted without returning a response, and has the signature function (ServerRequestInterface $request, ResponseInterface $response, $err = null) ; it is provided to the middleware pipeline when invoking the outermost middleware; in the case of Expressive, it is composed in the Application instance, and passed to the application middleware when it executes run() . When invoked, it needs to decide if invocation is due to no middleware executing (HTTP 404 status), middleware calling $next() with an altered response (response is then returned), or due to invocation of error middleware (calling $next() with the third, error, argument) with no error middleware returning a response. Expressive 1.1 updates the minimum supported Stratigility version to 1.3, which deprecates the concept of error middleware, and recommends a \"final handler\" that does no error handling, but instead returns a canned response (typically a 404). Additionally, it deprecates the practice of wrapping middleware execution in a try/catch block, and provides a flag for disabling that behavior entirely, raise_throwables . Starting in Expressive 1.1, you can set the raise_throwables flag in your configuration: return [ 'zend-expressive' => [ 'raise_throwables' => true, ], ]; When enabled, the internal dispatcher will no longer catch exceptions. This both allows you to, and requires you to, write your own error handling middleware. This will require two things: Middleware with a try/catch block that operates as the outermost (or close to outermost) layer of your application, and which can provide error pages or details to your end users. Middleware at the innermost layer that is guaranteed to return a response; generally, reaching this means no middleware was able to route the request, and thus a 404 condition. The below sections detail approaches to each.","title":"Error handling"},{"location":"v1/reference/migration/to-v1-1/#full-example","text":"Putting all of the above together \u2014 original message memoizing , programmatic pipelines , and middleware-based error handling \u2014 might look like the following examples. First, we'll tell Expressive to use programmatic pipelines, and to enable the new error handling (by telling it to \"raise throwables\", instead of catching them): // In config/autoload/zend-expressive.global.php: return [ /* ... */ 'zend-expressive' => [ 'programmatic_pipeline' => true, 'raise_throwables' => true, /* ... */ ], ]; Next, we'll update config/autoload/middleware-pipeline.global.php to list only dependencies: use Acme\\Container; use Acme\\TemplatedNotFoundHandler; use Zend\\Expressive\\Container\\ApplicationFactory; use Zend\\Expressive\\Helper; use Zend\\Stratigility\\Middleware\\ErrorHandler; use Zend\\Stratigility\\Middleware\\OriginalMessages; return [ 'dependencies' => [ 'invokables' => [ OriginalMessages::class => OriginalMesssages::class, ], 'factories' => [ ErrorHandler::class => Container\\ErrorHandlerFactory::class, Helper\\ServerUrlMiddleware::class => Helper\\ServerUrlMiddlewareFactory::class, Helper\\UrlHelperMiddleware::class => Helper\\UrlHelperMiddlewareFactory::class, TemplatedNotFoundHandler::class => Container\\TemplatedNotFoundHandlerFactory::class, ], ], ]; We'll also update config/autoload/routes.global.php to only list dependencies; in the following example, we list only the middleware shipped by default with the skeleton application: use App\\Action; use Zend\\Expressive\\Router\\FastRouteRouter; use Zend\\Expressive\\Router\\RouterInterface; return [ 'dependencies' => [ 'invokables' => [ RouterInterface::class => FastRouteRouter::class, Action\\PingAction::class => Action\\PingAction::class, ], 'factories' => [ Action\\HomePageAction::class => Action\\HomePageFactory::class, ], ], ]; To create our pipeline, we will create the file config/pipeline.php : use Acme\\TemplatedNotFoundHandler; use Zend\\Expressive\\Container\\ApplicationFactory; use Zend\\Expressive\\Helper; use Zend\\Stratigility\\Middleware\\ErrorHandler; use Zend\\Stratigility\\Middleware\\OriginalMessages; $app->pipe(OriginalMessages::class); $app->pipe(ErrorHandler::class); $app->pipe(Helper\\ServerUrlMiddleware::class); $app->pipe([ ApplicationFactory::ROUTING_MIDDLEWARE, Helper\\UrlHelperMiddleware::class, ApplicationFactory::DISPATCH_MIDDLEWARE, ]); $app->pipe(TemplatedNotFoundHandler::class); Note that you can use arrays of middleware just like you did in the configuration; this allows you to separate middleware into logical groups if desired! To provide our routed middleware, we will create the file config/pipeline.php : use App\\Action; $app->get('/', Action\\HomePageAction::class, 'home'); $app->get('/api/ping', Action\\PingAction::class, 'api.ping'); The above exercises the various routing methods of the Application class. Finally, we will need to update our public/index.php , to tell it to require our new pipeline and routing files; we'll do that between retrieving the application from the container, and running the application: $app = $container->get(\\Zend\\Expressive\\Application::class); require 'config/pipeline.php'; require 'config/routes.php'; $app->run(); With these changes in place, your application should continue to run as it did previously!","title":"Full example"},{"location":"v1/reference/migration/to-v1-1/#looking-forward","text":"Expressive 2.0 will ship error handling middleware and \"not found\" middleware, as well as tools to convert your application to a programmatic pipeline in such a way as to utilize these shipped implementations. In the meantime, however, you can adopt programmatic pipelines and the new error handling paradigm within the version 1 series using the configuration flags and guidelines listed above in order to make your application forwards-compatible.","title":"Looking forward"},{"location":"v2/","text":"Expressive: PSR-7 Middleware in Minutes Expressive builds on Stratigility to provide a minimalist PSR-7 middleware framework for PHP, with the following features: Routing. Choose your own router; we support: Aura.Router FastRoute zend-router DI Containers, via PSR-11 Container . All middleware composed in Expressive may be retrieved from the composed container. Optionally, templating. We support: Plates Twig ZF2's PhpRenderer Error handling. Create templated error pages, or use tools like whoops for debugging purposes. Nested middleware applications. Write an application, and compose it later in another, optionally under a separate subpath. Simplified installation . Our custom Composer -based installer prompts you for your initial stack choices, giving you exactly the base you want to start from. Essentially, Expressive allows you to develop using the tools you prefer, and provides minimal structure and facilities to ease your development. Should I choose it over Zend\\Mvc? That\u2019s a good question. Here\u2019s what we recommend. If you\u2019re keen to get started, then keep reading and get started writing your first middleware application today!","title":"Expressive: PSR-7 Middleware in Minutes"},{"location":"v2/#expressive-psr-7-middleware-in-minutes","text":"Expressive builds on Stratigility to provide a minimalist PSR-7 middleware framework for PHP, with the following features: Routing. Choose your own router; we support: Aura.Router FastRoute zend-router DI Containers, via PSR-11 Container . All middleware composed in Expressive may be retrieved from the composed container. Optionally, templating. We support: Plates Twig ZF2's PhpRenderer Error handling. Create templated error pages, or use tools like whoops for debugging purposes. Nested middleware applications. Write an application, and compose it later in another, optionally under a separate subpath. Simplified installation . Our custom Composer -based installer prompts you for your initial stack choices, giving you exactly the base you want to start from. Essentially, Expressive allows you to develop using the tools you prefer, and provides minimal structure and facilities to ease your development. Should I choose it over Zend\\Mvc? That\u2019s a good question. Here\u2019s what we recommend. If you\u2019re keen to get started, then keep reading and get started writing your first middleware application today!","title":"Expressive: PSR-7 Middleware in Minutes"},{"location":"v2/why-expressive/","text":"Should You Choose zend-expressive Over zend-mvc? We recommend that you choose Expressive for any new project \u2014 if the choice is yours to make . Why Use zend-mvc? zend-mvc is a proven platform, with more than half a decade of development behind it. It is stable and battle-tested in production platforms. Because it is opinionated about project structure and architecture, fewer decisions need be made up front; developers know where new code goes, and how it will wire into the overall application. Additionally, a number of training courses exist, including offerings by Zend , allowing you or your team to fully learn the framework and take advantage of all its features. Finally, zend-mvc has a lively module ecosystem , allowing you to add features and capabilities to your application without needing to develop them from scratch. We Recommend Expressive zend-mvc has many preconceptions about how things work, yet they're very broad and general. What\u2019s more, it also has several pre-wired structures in place that may either aid you \u2014 or get in your way. As a result, you are required to know a lot of what those things are \u2014 if you want to use it optimally. And to acquire that depth of knowledge, you\u2019re going to need to spend a lot of time digging deep into zend-mvc\u2019s internals before you begin to get the most out of it. To quote Zend Framework project lead, Matthew Weier O\u2019Phinney : The problem is that zend-mvc is anything but beginner-friendly at this point. You're required to deep dive into the event manager, service manager, and module system \u2014 right from the outset; And to do this you need more than a passing understanding of object-oriented programming and a range of design patterns. Expressive (specifically applications based on the Expressive Skeleton Installer ) on the other hand, comes with barely any of these assumptions and requirements. It provides a very minimalist structure. Essentially all you have to become familiar with are five core components. These are: A DI container. A router. An error handler for development. A template engine (if you\u2019re not creating an API). PSR-7 messages and http-interop (future PSR-15) middleware. In many cases, these are provided for you by the skeleton, and do not require any additional knowledge on your part. Given that, you can quickly get up to speed with the framework and begin creating the application that you need. We believe that this approach \u2014 in contrast to the zend-mvc approach \u2014 is more flexible and accommodating. What\u2019s more, you can mix and match the types of applications that you create. Do you just need an API? Great; you can do that quite quickly. Do you want an HTML-based front-end? That\u2019s available too. When building applications with Expressive, you can make use of the various Zend components, or any third-party components or middleware. You can pick and choose what you need, as and when you need it. You\u2019re not bound by many, if any, constraints and design decisions. In Conclusion For what it\u2019s worth, we\u2019re not saying that zend-mvc is a poor choice! What we are saying is: The learning curve, from getting started to building the first application, is significantly lower with Expressive The ways in which you can create applications, whether through multiple pieces of middleware or by combining multiple Expressive apps, into one larger one, is a much more efficient and fluid way to work Ultimately, the choice is always up to you, your team, and your project\u2019s needs. We just want to ensure that you\u2019ve got all the information you need, to make an informed decision.","title":"Why choose Expressive?"},{"location":"v2/why-expressive/#should-you-choose-zend-expressive-over-zend-mvc","text":"We recommend that you choose Expressive for any new project \u2014 if the choice is yours to make .","title":"Should You Choose zend-expressive Over zend-mvc?"},{"location":"v2/why-expressive/#why-use-zend-mvc","text":"zend-mvc is a proven platform, with more than half a decade of development behind it. It is stable and battle-tested in production platforms. Because it is opinionated about project structure and architecture, fewer decisions need be made up front; developers know where new code goes, and how it will wire into the overall application. Additionally, a number of training courses exist, including offerings by Zend , allowing you or your team to fully learn the framework and take advantage of all its features. Finally, zend-mvc has a lively module ecosystem , allowing you to add features and capabilities to your application without needing to develop them from scratch.","title":"Why Use zend-mvc?"},{"location":"v2/why-expressive/#we-recommend-expressive","text":"zend-mvc has many preconceptions about how things work, yet they're very broad and general. What\u2019s more, it also has several pre-wired structures in place that may either aid you \u2014 or get in your way. As a result, you are required to know a lot of what those things are \u2014 if you want to use it optimally. And to acquire that depth of knowledge, you\u2019re going to need to spend a lot of time digging deep into zend-mvc\u2019s internals before you begin to get the most out of it. To quote Zend Framework project lead, Matthew Weier O\u2019Phinney : The problem is that zend-mvc is anything but beginner-friendly at this point. You're required to deep dive into the event manager, service manager, and module system \u2014 right from the outset; And to do this you need more than a passing understanding of object-oriented programming and a range of design patterns. Expressive (specifically applications based on the Expressive Skeleton Installer ) on the other hand, comes with barely any of these assumptions and requirements. It provides a very minimalist structure. Essentially all you have to become familiar with are five core components. These are: A DI container. A router. An error handler for development. A template engine (if you\u2019re not creating an API). PSR-7 messages and http-interop (future PSR-15) middleware. In many cases, these are provided for you by the skeleton, and do not require any additional knowledge on your part. Given that, you can quickly get up to speed with the framework and begin creating the application that you need. We believe that this approach \u2014 in contrast to the zend-mvc approach \u2014 is more flexible and accommodating. What\u2019s more, you can mix and match the types of applications that you create. Do you just need an API? Great; you can do that quite quickly. Do you want an HTML-based front-end? That\u2019s available too. When building applications with Expressive, you can make use of the various Zend components, or any third-party components or middleware. You can pick and choose what you need, as and when you need it. You\u2019re not bound by many, if any, constraints and design decisions.","title":"We Recommend Expressive"},{"location":"v2/why-expressive/#in-conclusion","text":"For what it\u2019s worth, we\u2019re not saying that zend-mvc is a poor choice! What we are saying is: The learning curve, from getting started to building the first application, is significantly lower with Expressive The ways in which you can create applications, whether through multiple pieces of middleware or by combining multiple Expressive apps, into one larger one, is a much more efficient and fluid way to work Ultimately, the choice is always up to you, your team, and your project\u2019s needs. We just want to ensure that you\u2019ve got all the information you need, to make an informed decision.","title":"In Conclusion"},{"location":"v2/cookbook/autowiring-routes-and-pipelines/","text":"How can I autowire routes and pipelines? Expressive 2.0 switched to programmatic pipelines and routes, versus configuration-driven pipelines and routing as used in version 1. One drawback is that with configuration-driven approaches, users could provide configuration via a module ConfigProvider , and automatically expose new pipeline middleware or routes; with a programmatic approach, this is no longer possible. Or is it? Delegator Factories One possibility available to version 2 applications is to use delegator factories on the Zend\\Expressive\\Application instance in order to inject these items. A delegator factory is a factory that delegates creation of an instance to a callback, and then operates on that instance for the purpose of altering the instance or providing a replacement (e.g., a decorator or proxy). The delegate callback usually wraps a service factory, or, because delegator factories also return an instance, additional delegator factories. As such, you assign delegator factories , plural, to instances, allowing multiple delegator factories to intercept processing of the service initialization. For the purposes of this particular example, we will use delegator factories to both pipe middleware as well as route middleware. To demonstrate, we'll take the default pipeline and routing from the skeleton application, and provide it via a delegator factory instead. First, we'll create the class App\\Factory\\PipelineAndRoutesDelegator , with the following contents: <?php namespace App\\Factory; use App\\Action; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\Helper\\ServerUrlMiddleware; use Zend\\Expressive\\Helper\\UrlHelperMiddleware; use Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware; use Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware; use Zend\\Expressive\\Middleware\\NotFoundHandler; use Zend\\Stratigility\\Middleware\\ErrorHandler; class PipelineAndRoutesDelegator { /** * @param ContainerInterface $container * @param string $serviceName Name of the service being created. * @param callable $callback Creates and returns the service. * @return Application */ public function __invoke(ContainerInterface $container, $serviceName, callable $callback) { /** @var $app Application */ $app = $callback(); // Setup pipeline: $app->pipe(ErrorHandler::class); $app->pipe(ServerUrlMiddleware::class); $app->pipeRoutingMiddleware(); $app->pipe(ImplicitHeadMiddleware::class); $app->pipe(ImplicitOptionsMiddleware::class); $app->pipe(UrlHelperMiddleware::class); $app->pipeDispatchMiddleware(); $app->pipe(NotFoundHandler::class); // Setup routes: $app->get('/', Action\\HomePageAction::class, 'home'); $app->get('/api/ping', Action\\PingAction::class, 'api.ping'); return $app; } } Where to put the factory You will place the factory class in one of the following locations: src/App/Factory/PipelineAndRoutesDelegator.php if using the default, flat, application structure. src/App/src/Factory/PipelineAndRoutesDelegator.php if using the recommended, modular, application structure. Once you've created this, edit the class App\\ConfigProvider ; in it, we'll update the getDependencies() method to add the delegator factory: public function getDependencies() { return [ /* . . . */ 'delegators' => [ \\Zend\\Expressive\\Application::class => [ Factory\\PipelineAndRoutesDelegator::class, ], ], ]; } Where is the ConfigProvider class? The ConfigProvider class is in one of the following locations: src/App/ConfigProvider.php if using the default, flat, application structure. src/App/src/ConfigProvider.php using the recommended, modular, application structure. Why is an array assigned? As noted above in the description of delegator factories, since each delegator factory returns an instance, you can nest multiple delegator factories in order to shape initialization of a service. As such, they are assigned as an array to the service. Once you've done this, you can remove: config/pipeline.php config/routes.php The following lines from public/index.php : php // Import programmatic/declarative middleware pipeline and routing // configuration statements require 'config/pipeline.php'; require 'config/routes.php'; If you reload your application at this point, you should see that everything continues to work as expected! Caution: pipelines Using delegator factories is a nice way to keep your routing and pipeline configuration close to the modules in which they are defined. However, there is a caveat: you likely should not register pipeline middleware in a delegator factory other than within your root application module . The reason for this is simple: pipelines are linear, and specific to your application. If one module pipes in middleware, there's no guarantee it will be piped before or after your main pipeline, and no way to pipe the middleware at a position in the middle of the pipeline! As such: Use a config/pipeline.php file for your pipeline, OR Ensure you only define the pipeline in a single delegator factory on your Application instance. Caution: third-party, distributed modules If you are developing a module to distribute as a package via Composer , you should not autowire any delegator factories that inject pipeline middleware or routes in the Application . Why? As noted in the above section, pipelines should be created exactly once, at the application level. Registering pipeline middleware within a distributable package will very likely not have the intended consequences. If you ship with pipeline middleware, we suggest that you: Document the middleware, and where you anticipate it being used in the middleware pipeline. Document how to add the middleware service to dependency configuration, or provide the dependency configuration via your module's ConfigProvider . With regards to routes, there are other considerations: Routes defined by the package might conflict with the application, or with other packages used by the application. Routing definitions are typically highly specific to the router implementation in use. As an example, each of the currently supported router implementations has a different syntax for placeholders: /user/:id + \"constraints\" configuration to define constraints (zend-router) /user/{id} + \"tokens\" configuration to define constraints (Aura.Router) /user/{id:\\d+} (FastRoute) Your application may have specific routing considerations or design. You could, of course, detect what router is in use, and provide routing for each known, supported router implementation within your delegator factory. We even recommend doing exactly that. However, we note that such an approach does not solve the other two points above. However, we still recommend shipping a delegator factory that would register your routes, since routes are often a part of module design; just do not autowire that delegator factory. This way, end-users who can use the defaults do not need to cut-and-paste routing definitions from your documentation into their own applications; they will instead opt-in to your delegator factory by wiring it into their own configuration. Synopsis We recommend using delegator factories for the purpose of autowiring routes, and, with caveats, pipeline middleware: The pipeline should be created exactly once, so calls to pipe() should occur in exactly one delegator factory. Distributable packages should create a delegator factory for routes only , but should not register the delegator factory by default. ApplicationConfigInjectionDelegator Since version 2.2 Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator allows you to define configuration that is then used to call pipe() or the various routing methods of Zend\\Expressive\\Application . This is particularly useful for injecting routes . The format of routes configuration is as follows: return [ 'routes' => [ [ 'path' => '/path/to/match', 'middleware' => 'Middleware Service Name', 'allowed_methods' => ['GET', 'POST', 'PATCH'], 'options' => [ 'stuff' => 'to', 'pass' => 'to', 'the' => 'underlying router', ], ], // etc. ], ]; All your various modules could provide route configuration, and you could then use a single delegator to add all of them at once.","title":"Autowiring routes and pipeline middleware"},{"location":"v2/cookbook/autowiring-routes-and-pipelines/#how-can-i-autowire-routes-and-pipelines","text":"Expressive 2.0 switched to programmatic pipelines and routes, versus configuration-driven pipelines and routing as used in version 1. One drawback is that with configuration-driven approaches, users could provide configuration via a module ConfigProvider , and automatically expose new pipeline middleware or routes; with a programmatic approach, this is no longer possible. Or is it?","title":"How can I autowire routes and pipelines?"},{"location":"v2/cookbook/autowiring-routes-and-pipelines/#delegator-factories","text":"One possibility available to version 2 applications is to use delegator factories on the Zend\\Expressive\\Application instance in order to inject these items. A delegator factory is a factory that delegates creation of an instance to a callback, and then operates on that instance for the purpose of altering the instance or providing a replacement (e.g., a decorator or proxy). The delegate callback usually wraps a service factory, or, because delegator factories also return an instance, additional delegator factories. As such, you assign delegator factories , plural, to instances, allowing multiple delegator factories to intercept processing of the service initialization. For the purposes of this particular example, we will use delegator factories to both pipe middleware as well as route middleware. To demonstrate, we'll take the default pipeline and routing from the skeleton application, and provide it via a delegator factory instead. First, we'll create the class App\\Factory\\PipelineAndRoutesDelegator , with the following contents: <?php namespace App\\Factory; use App\\Action; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\Helper\\ServerUrlMiddleware; use Zend\\Expressive\\Helper\\UrlHelperMiddleware; use Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware; use Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware; use Zend\\Expressive\\Middleware\\NotFoundHandler; use Zend\\Stratigility\\Middleware\\ErrorHandler; class PipelineAndRoutesDelegator { /** * @param ContainerInterface $container * @param string $serviceName Name of the service being created. * @param callable $callback Creates and returns the service. * @return Application */ public function __invoke(ContainerInterface $container, $serviceName, callable $callback) { /** @var $app Application */ $app = $callback(); // Setup pipeline: $app->pipe(ErrorHandler::class); $app->pipe(ServerUrlMiddleware::class); $app->pipeRoutingMiddleware(); $app->pipe(ImplicitHeadMiddleware::class); $app->pipe(ImplicitOptionsMiddleware::class); $app->pipe(UrlHelperMiddleware::class); $app->pipeDispatchMiddleware(); $app->pipe(NotFoundHandler::class); // Setup routes: $app->get('/', Action\\HomePageAction::class, 'home'); $app->get('/api/ping', Action\\PingAction::class, 'api.ping'); return $app; } }","title":"Delegator Factories"},{"location":"v2/cookbook/autowiring-routes-and-pipelines/#caution-pipelines","text":"Using delegator factories is a nice way to keep your routing and pipeline configuration close to the modules in which they are defined. However, there is a caveat: you likely should not register pipeline middleware in a delegator factory other than within your root application module . The reason for this is simple: pipelines are linear, and specific to your application. If one module pipes in middleware, there's no guarantee it will be piped before or after your main pipeline, and no way to pipe the middleware at a position in the middle of the pipeline! As such: Use a config/pipeline.php file for your pipeline, OR Ensure you only define the pipeline in a single delegator factory on your Application instance.","title":"Caution: pipelines"},{"location":"v2/cookbook/autowiring-routes-and-pipelines/#caution-third-party-distributed-modules","text":"If you are developing a module to distribute as a package via Composer , you should not autowire any delegator factories that inject pipeline middleware or routes in the Application . Why? As noted in the above section, pipelines should be created exactly once, at the application level. Registering pipeline middleware within a distributable package will very likely not have the intended consequences. If you ship with pipeline middleware, we suggest that you: Document the middleware, and where you anticipate it being used in the middleware pipeline. Document how to add the middleware service to dependency configuration, or provide the dependency configuration via your module's ConfigProvider . With regards to routes, there are other considerations: Routes defined by the package might conflict with the application, or with other packages used by the application. Routing definitions are typically highly specific to the router implementation in use. As an example, each of the currently supported router implementations has a different syntax for placeholders: /user/:id + \"constraints\" configuration to define constraints (zend-router) /user/{id} + \"tokens\" configuration to define constraints (Aura.Router) /user/{id:\\d+} (FastRoute) Your application may have specific routing considerations or design. You could, of course, detect what router is in use, and provide routing for each known, supported router implementation within your delegator factory. We even recommend doing exactly that. However, we note that such an approach does not solve the other two points above. However, we still recommend shipping a delegator factory that would register your routes, since routes are often a part of module design; just do not autowire that delegator factory. This way, end-users who can use the defaults do not need to cut-and-paste routing definitions from your documentation into their own applications; they will instead opt-in to your delegator factory by wiring it into their own configuration.","title":"Caution: third-party, distributed modules"},{"location":"v2/cookbook/autowiring-routes-and-pipelines/#synopsis","text":"We recommend using delegator factories for the purpose of autowiring routes, and, with caveats, pipeline middleware: The pipeline should be created exactly once, so calls to pipe() should occur in exactly one delegator factory. Distributable packages should create a delegator factory for routes only , but should not register the delegator factory by default.","title":"Synopsis"},{"location":"v2/cookbook/autowiring-routes-and-pipelines/#applicationconfiginjectiondelegator","text":"Since version 2.2 Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator allows you to define configuration that is then used to call pipe() or the various routing methods of Zend\\Expressive\\Application . This is particularly useful for injecting routes . The format of routes configuration is as follows: return [ 'routes' => [ [ 'path' => '/path/to/match', 'middleware' => 'Middleware Service Name', 'allowed_methods' => ['GET', 'POST', 'PATCH'], 'options' => [ 'stuff' => 'to', 'pass' => 'to', 'the' => 'underlying router', ], ], // etc. ], ]; All your various modules could provide route configuration, and you could then use a single delegator to add all of them at once.","title":"ApplicationConfigInjectionDelegator"},{"location":"v2/cookbook/common-prefix-for-routes/","text":"How can I prepend a common path to all my routes? You may have multiple middleware in your project, each providing their own functionality: $middleware1 = new UserMiddleware(); $middleware2 = new ProjectMiddleware(); $app = AppFactory::create(); $app->pipe($middleware1); $app->pipe($middleware2); $app->run(); Let's assume the above represents an API. As your application progresses, you may have a mixture of different content, and now want to have the above segregated under the path /api . This is essentially the same problem as addressed in the \"Segregating your application to a subpath\" example. To accomplish it: Create a new application. Pipe the previous application to the new one, under the path /api . $middleware1 = new UserMiddleware(); $middleware2 = new ProjectMiddleware(); $api = AppFactory::create(); $api->pipe($middleware1); $api->pipe($middleware2); $app = AppFactory::create(); $app->pipe('/api', $api); $app->run(); The above works, because every Application instance is itself middleware, and, more specifically, an instance of Stratigility's MiddlewarePipe , which provides the ability to compose middleware.","title":"Prepending a common path to all routes"},{"location":"v2/cookbook/common-prefix-for-routes/#how-can-i-prepend-a-common-path-to-all-my-routes","text":"You may have multiple middleware in your project, each providing their own functionality: $middleware1 = new UserMiddleware(); $middleware2 = new ProjectMiddleware(); $app = AppFactory::create(); $app->pipe($middleware1); $app->pipe($middleware2); $app->run(); Let's assume the above represents an API. As your application progresses, you may have a mixture of different content, and now want to have the above segregated under the path /api . This is essentially the same problem as addressed in the \"Segregating your application to a subpath\" example. To accomplish it: Create a new application. Pipe the previous application to the new one, under the path /api . $middleware1 = new UserMiddleware(); $middleware2 = new ProjectMiddleware(); $api = AppFactory::create(); $api->pipe($middleware1); $api->pipe($middleware2); $app = AppFactory::create(); $app->pipe('/api', $api); $app->run(); The above works, because every Application instance is itself middleware, and, more specifically, an instance of Stratigility's MiddlewarePipe , which provides the ability to compose middleware.","title":"How can I prepend a common path to all my routes?"},{"location":"v2/cookbook/debug-toolbars/","text":"How can I get a debug toolbar for my Expressive application? Many modern frameworks and applications provide debug toolbars: in-browser toolbars to provide profiling information of the request executed. These can provide invaluable details into application objects, database queries, and more. As an Expressive user, how can you get similar functionality? Zend Server Z-Ray Zend Server ships with a tool called Z-Ray , which provides both a debug toolbar and debug console (for API debugging). Z-Ray is also currently available as a standalone technology preview , and can be added as an extension to an existing PHP installation. When using Zend Server or the standalone Z-Ray, you do not need to make any changes to your application whatsoever to benefit from it; you simply need to make sure Z-Ray is enabled and/or that you've setup a security token to selectively enable it on-demand. See the Z-Ray documentation for full usage details. bitExpert/prophiler-psr7-middleware Another option is bitExpert's prophiler-psr7-middleware . This package wraps fabfuel/prophiler , which provides a PHP-based profiling tool and toolbar; the bitExpert package wraps this in PSR-7 middleware to make consumption in those paradigms trivial. To add the toolbar middleware to your application, use composer: $ composer require bitExpert/prophiler-psr7-middleware From there, you will need to create a factory for the middleware, and add it to your middleware pipeline. Stephan Hochd\u00f6rfer, author of the package, has written a post detailing these steps . Use locally! One minor change we recommend over the directions Stephan provides is that you configure the factory and middleware in the config/autoload/middleware-pipeline.local.php file, vs the .global version. Doing so enables the middleware and toolbar only in the local environment \u2014 and not in production, where you likely do not want to expose such information! php-middleware/php-debug-bar php-middleware/php-debug-bar provides a PSR-7 middleware wrapper around maximebf/php-debugbar , a popular framework-agnostic debug bar for PHP projects. First, install the middleware in your application: $ composer require php-middleware/php-debug-bar This package supplies a config provider, which could be added to your config/config.php when using zend-config-aggregator or expressive-config-manager. However, because it should only be enabled in development, we recommend creating a \"local\" configuration file (e.g., config/autoload/php-debugbar.local.php ) when you need to enable it, with the following contents: <?php use PhpMiddleware\\PhpDebugBar\\ConfigProvider; $provider = new ConfigProvider(); return $provider(); Use locally! Remember to enable PhpMiddleware\\PhpDebugBar\\ConfigProvider only in your development enviroments!","title":"Enabling debug toolbars"},{"location":"v2/cookbook/debug-toolbars/#how-can-i-get-a-debug-toolbar-for-my-expressive-application","text":"Many modern frameworks and applications provide debug toolbars: in-browser toolbars to provide profiling information of the request executed. These can provide invaluable details into application objects, database queries, and more. As an Expressive user, how can you get similar functionality?","title":"How can I get a debug toolbar for my Expressive application?"},{"location":"v2/cookbook/debug-toolbars/#zend-server-z-ray","text":"Zend Server ships with a tool called Z-Ray , which provides both a debug toolbar and debug console (for API debugging). Z-Ray is also currently available as a standalone technology preview , and can be added as an extension to an existing PHP installation. When using Zend Server or the standalone Z-Ray, you do not need to make any changes to your application whatsoever to benefit from it; you simply need to make sure Z-Ray is enabled and/or that you've setup a security token to selectively enable it on-demand. See the Z-Ray documentation for full usage details.","title":"Zend Server Z-Ray"},{"location":"v2/cookbook/debug-toolbars/#bitexpertprophiler-psr7-middleware","text":"Another option is bitExpert's prophiler-psr7-middleware . This package wraps fabfuel/prophiler , which provides a PHP-based profiling tool and toolbar; the bitExpert package wraps this in PSR-7 middleware to make consumption in those paradigms trivial. To add the toolbar middleware to your application, use composer: $ composer require bitExpert/prophiler-psr7-middleware From there, you will need to create a factory for the middleware, and add it to your middleware pipeline. Stephan Hochd\u00f6rfer, author of the package, has written a post detailing these steps .","title":"bitExpert/prophiler-psr7-middleware"},{"location":"v2/cookbook/debug-toolbars/#php-middlewarephp-debug-bar","text":"php-middleware/php-debug-bar provides a PSR-7 middleware wrapper around maximebf/php-debugbar , a popular framework-agnostic debug bar for PHP projects. First, install the middleware in your application: $ composer require php-middleware/php-debug-bar This package supplies a config provider, which could be added to your config/config.php when using zend-config-aggregator or expressive-config-manager. However, because it should only be enabled in development, we recommend creating a \"local\" configuration file (e.g., config/autoload/php-debugbar.local.php ) when you need to enable it, with the following contents: <?php use PhpMiddleware\\PhpDebugBar\\ConfigProvider; $provider = new ConfigProvider(); return $provider();","title":"php-middleware/php-debug-bar"},{"location":"v2/cookbook/flash-messengers/","text":"How Can I Implement Flash Messages? Flash messages are used to display one-time messages to a user. A typical use case is for setting and later displaying a successful submission via a Post/Redirect/Get (PRG) workflow, where the flash message would be set during the POST request, but displayed during the GET request. (PRG is used to prevent double-submission of forms.) As such, flash messages usually are session-based; the message is set in one request, and accessed and cleared in another. Expressive does not provide native session facilities out-of-the-box, which means you will need: Session functionality. Flash message functionality, for handling message expiry from the session after first access. A number of flash message libraries already exist that can be integrated via middleware, and these typically either use PHP's ext/session functionality or have a dependency on a session library. Two such libraries are slim/flash and damess/expressive-session-middleware. slim/flash Slim's Flash messages service provider can be used in Expressive. It uses PHP's native session support. First, you'll need to add it to your application: $ composer require slim/flash Second, create middleware that will add the flash message provider to the request: <?php namespace App; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Slim\\Flash\\Messages; class SlimFlashMiddleware implements MiddlewareInterface { public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // Start the session whenever we use this! session_start(); return $delegate->process( $request->withAttribute('flash', new Messages()) ); } } Third, we will register the new middleware with our container as an invokable. Edit either the file config/autoload/dependencies.global.php or config/autoload/middleware-pipeline.global.php to add the following: return [ 'dependencies' => [ 'invokables' => [ App\\SlimFlashMiddleware::class => App\\SlimFlashMiddleware::class, /* ... */ ], /* ... */ ], ]; Finally, let's register it with our middleware pipeline. For programmatic pipelines, pipe the middleware somewhere, generally before the routing middleware: $app->pipe(App\\SlimFlashMiddleware::class); Or as part of a routed middleware pipeline: $app->post('/form/handler', [ App\\SlimFlashMiddleware::class, FormHandlerMiddleware::class, ]); If using configuration-driven pipelines, edit config/autoload/middleware-pipeline.global.php to make the following additions: return [ 'middleware_pipeline' => [ 'always' => [ 'middleware' => [ 'App\\SlimFlashMiddleware', /* ... */ ], 'priority' => 10000, ], /* ... */ ], ]; Where to register the flash middleware Sessions can sometimes be expensive. As such, you may not want the flash middleware enabled for every request. If this is the case, add the flash middleware as part of a route-specific pipeline instead, as demonstrated in the programmatic pipelines above. From here, you can add and read messages by accessing the request's flash attribute. As an example, middleware generating messages might read as follows: use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Zend\\Diactoros\\Response\\RedirectResponse; function($request, DelegateInterface $delegate) { $flash = $request->getAttribute('flash'); $flash->addMessage('message', 'Hello World!'); return new RedirectResponse('/other-middleware'); } And middleware consuming the message might read: use Interop\\Http\\ServerMiddleware\\DelegateInterface; function($request, DelegateInterface $delegate) { $flash = $request->getAttribute('flash'); $messages = $flash->getMessages(); // ... } From there, it's a matter of providing the flash messages to your template. damess/expressive-session-middleware and Aura.Session damess/expressive-session-middleware provides middleware for initializing an Aura.Session instance; Aura.Session provides flash messaging capabilities as part of its featureset. Install it via Composer: $ composer require damess/expressive-session-middleware In config/autoload/dependencies.global.php , add an entry for Aura.Session: return [ 'dependencies' => [ 'factories' => [ Aura\\Session\\Session::class => DaMess\\Factory\\AuraSessionFactory::class, /* ... */ ], /* ... */ ], ]; In either config/autoload/dependencies.global.php or config/autoload/middleware-pipeline.global.php , add a factory entry for the damess/expressive-session-middleware : return [ 'dependencies' => [ 'factories' => [ DaMess\\Http\\SessionMiddleware::class => DaMess\\Factory\\SessionMiddlewareFactory::class, /* ... */ ], /* ... */ ], ]; Finally, add it to your middleware pipeline. For programmatic pipelines: use DaMess\\Http\\SessionMiddleware; $app->pipe(SessionMiddleware::class); /* ... */ If using configuration-driven pipelines, edit config/autoload/middleware-pipeline.global.php and add an entry for the new middleware: return [ 'middleware_pipeline' => [ 'always' => [ 'middleware' => [ DaMess\\Http\\SessionMiddleware::class, /* ... */ ], 'priority' => 10000, ], /* ... */ ], ]; Where to register the session middleware Sessions can sometimes be expensive. As such, you may not want the session middleware enabled for every request. If this is the case, add the session middleware as part of a route-specific pipeline instead. Once enabled, the SessionMiddleware will inject the Aura.Session instance into the request as the session attribute; you can thus retrieve it within middleware using the following: $session = $request->getAttribute('session'); To create and consume flash messages, use Aura.Session's flash values . As an example, the middleware that is processing a POST request might set a flash message: use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Zend\\Diactoros\\Response\\RedirectResponse; function($request, DelegateInterface $delegate) { $session = $request->getAttribute('session'); $session->getSegment(__NAMESPACE__) ->setFlash('message', 'Hello World!'); return new RedirectResponse('/other-middleware'); } Another middleware, to which the original middleware redirects, might look like this: use Interop\\Http\\ServerMiddleware\\DelegateInterface; function($request, DelegateInterface $delegate) { $session = $request->getAttribute('session'); $message = $session->getSegment(__NAMESPACE__) ->getFlash('message'); // ... } From there, it's a matter of providing the flash messages to your template.","title":"Flash Messengers"},{"location":"v2/cookbook/flash-messengers/#how-can-i-implement-flash-messages","text":"Flash messages are used to display one-time messages to a user. A typical use case is for setting and later displaying a successful submission via a Post/Redirect/Get (PRG) workflow, where the flash message would be set during the POST request, but displayed during the GET request. (PRG is used to prevent double-submission of forms.) As such, flash messages usually are session-based; the message is set in one request, and accessed and cleared in another. Expressive does not provide native session facilities out-of-the-box, which means you will need: Session functionality. Flash message functionality, for handling message expiry from the session after first access. A number of flash message libraries already exist that can be integrated via middleware, and these typically either use PHP's ext/session functionality or have a dependency on a session library. Two such libraries are slim/flash and damess/expressive-session-middleware.","title":"How Can I Implement Flash Messages?"},{"location":"v2/cookbook/flash-messengers/#slimflash","text":"Slim's Flash messages service provider can be used in Expressive. It uses PHP's native session support. First, you'll need to add it to your application: $ composer require slim/flash Second, create middleware that will add the flash message provider to the request: <?php namespace App; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Slim\\Flash\\Messages; class SlimFlashMiddleware implements MiddlewareInterface { public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // Start the session whenever we use this! session_start(); return $delegate->process( $request->withAttribute('flash', new Messages()) ); } } Third, we will register the new middleware with our container as an invokable. Edit either the file config/autoload/dependencies.global.php or config/autoload/middleware-pipeline.global.php to add the following: return [ 'dependencies' => [ 'invokables' => [ App\\SlimFlashMiddleware::class => App\\SlimFlashMiddleware::class, /* ... */ ], /* ... */ ], ]; Finally, let's register it with our middleware pipeline. For programmatic pipelines, pipe the middleware somewhere, generally before the routing middleware: $app->pipe(App\\SlimFlashMiddleware::class); Or as part of a routed middleware pipeline: $app->post('/form/handler', [ App\\SlimFlashMiddleware::class, FormHandlerMiddleware::class, ]); If using configuration-driven pipelines, edit config/autoload/middleware-pipeline.global.php to make the following additions: return [ 'middleware_pipeline' => [ 'always' => [ 'middleware' => [ 'App\\SlimFlashMiddleware', /* ... */ ], 'priority' => 10000, ], /* ... */ ], ];","title":"slim/flash"},{"location":"v2/cookbook/flash-messengers/#damessexpressive-session-middleware-and-aurasession","text":"damess/expressive-session-middleware provides middleware for initializing an Aura.Session instance; Aura.Session provides flash messaging capabilities as part of its featureset. Install it via Composer: $ composer require damess/expressive-session-middleware In config/autoload/dependencies.global.php , add an entry for Aura.Session: return [ 'dependencies' => [ 'factories' => [ Aura\\Session\\Session::class => DaMess\\Factory\\AuraSessionFactory::class, /* ... */ ], /* ... */ ], ]; In either config/autoload/dependencies.global.php or config/autoload/middleware-pipeline.global.php , add a factory entry for the damess/expressive-session-middleware : return [ 'dependencies' => [ 'factories' => [ DaMess\\Http\\SessionMiddleware::class => DaMess\\Factory\\SessionMiddlewareFactory::class, /* ... */ ], /* ... */ ], ]; Finally, add it to your middleware pipeline. For programmatic pipelines: use DaMess\\Http\\SessionMiddleware; $app->pipe(SessionMiddleware::class); /* ... */ If using configuration-driven pipelines, edit config/autoload/middleware-pipeline.global.php and add an entry for the new middleware: return [ 'middleware_pipeline' => [ 'always' => [ 'middleware' => [ DaMess\\Http\\SessionMiddleware::class, /* ... */ ], 'priority' => 10000, ], /* ... */ ], ];","title":"damess/expressive-session-middleware and Aura.Session"},{"location":"v2/cookbook/passing-data-between-middleware/","text":"Passing Data Between Middleware A frequently asked question is how to pass data between middleware. The answer is present in every middleware: via request object attributes. Middleware is always executed in the order in which it is piped to the application. This way you can ensure the request object in middleware receiving data contains an attribute containing data passed by outer middleware. In the following example, PassingDataMiddleware prepares data to pass as a request attribute to nested middleware. We use the fully qualified class name for the attribute name to ensure uniqueness, but you can name it anything you want. namespace App\\Middleware; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; class PassingDataMiddleware implements MiddlewareInterface { // ... public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // Step 1: Do something first $data = [ 'foo' => 'bar', ]; // Step 2: Inject data into the request, call the next middleware and wait for the response $response = $delegate->process($request->withAttribute(self::class, $data)); // Step 3: Optionally, do something (with the response) before returning the response // Step 4: Return the response return $response; } } Later, ReceivingDataMiddleware grabs the data and processes it: namespace App\\Middleware; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; class ReceivingDataMiddleware implements MiddlewareInterface { // ... public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // Step 1: Grab the data from the request and use it $data = $request->getAttribute(PassingDataMiddleware::class); // Step 2: Call the next middleware and wait for the response $response = $delegate->process($request); // Step 3: Optionally, do something (with the response) before returning the response // Step 4: Return the response return $response; } } Of course, you could also use the data in routed middleware, which is usually at the innermost layer of your application. The ExampleAction below takes that information and passes it to the template renderer to create an HtmlResponse : namespace App\\Action; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\HtmlResponse; class ExampleAction implements MiddlewareInterface { // ... public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // Step 1: Grab the data from the request $data = $request->getAttribute(PassingDataMiddleware::class); $id = $request->getAttribute('id'); // Step 2: Do some more stuff // Step 3: Return a Response return new HtmlResponse( $this->templateRenderer->render('blog::entry', [ 'data' => $data, 'id' => $id, ]) ); } }","title":"Passing data between middleware"},{"location":"v2/cookbook/passing-data-between-middleware/#passing-data-between-middleware","text":"A frequently asked question is how to pass data between middleware. The answer is present in every middleware: via request object attributes. Middleware is always executed in the order in which it is piped to the application. This way you can ensure the request object in middleware receiving data contains an attribute containing data passed by outer middleware. In the following example, PassingDataMiddleware prepares data to pass as a request attribute to nested middleware. We use the fully qualified class name for the attribute name to ensure uniqueness, but you can name it anything you want. namespace App\\Middleware; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; class PassingDataMiddleware implements MiddlewareInterface { // ... public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // Step 1: Do something first $data = [ 'foo' => 'bar', ]; // Step 2: Inject data into the request, call the next middleware and wait for the response $response = $delegate->process($request->withAttribute(self::class, $data)); // Step 3: Optionally, do something (with the response) before returning the response // Step 4: Return the response return $response; } } Later, ReceivingDataMiddleware grabs the data and processes it: namespace App\\Middleware; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; class ReceivingDataMiddleware implements MiddlewareInterface { // ... public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // Step 1: Grab the data from the request and use it $data = $request->getAttribute(PassingDataMiddleware::class); // Step 2: Call the next middleware and wait for the response $response = $delegate->process($request); // Step 3: Optionally, do something (with the response) before returning the response // Step 4: Return the response return $response; } } Of course, you could also use the data in routed middleware, which is usually at the innermost layer of your application. The ExampleAction below takes that information and passes it to the template renderer to create an HtmlResponse : namespace App\\Action; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\HtmlResponse; class ExampleAction implements MiddlewareInterface { // ... public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // Step 1: Grab the data from the request $data = $request->getAttribute(PassingDataMiddleware::class); $id = $request->getAttribute('id'); // Step 2: Do some more stuff // Step 3: Return a Response return new HtmlResponse( $this->templateRenderer->render('blog::entry', [ 'data' => $data, 'id' => $id, ]) ); } }","title":"Passing Data Between Middleware"},{"location":"v2/cookbook/route-specific-pipeline/","text":"How can I specify a route-specific middleware pipeline? Sometimes you may want to use a middleware pipeline only if a particular route is matched. As an example, for an API resource, you might want to: check for authentication credentials check for authorization for the selected action parse the incoming body validate the parsed body parameters before you actually execute the selected middleware. The above might each be encapsulated as discrete middleware, but should be executed within the routed middleware's context. You can accomplish this in one of two ways: Have your middleware service resolve to a MiddlewarePipe instance that composes the various middlewares. Specify an array of middlewares (either as actual instances, or as container service names); this effectively creates and returns a MiddlewarePipe . Resolving to a MiddlewarePipe You can do this programmatically within a container factory, assuming you are using a container that supports factories. use Psr\\Container\\ContainerInterface; use Zend\\Stratigility\\MiddlewarePipe; class ApiResourcePipelineFactory { public function __invoke(ContainerInterface $container) { $pipeline = new MiddlewarePipe(); // These correspond to the bullet points above $pipeline->pipe($container->get('AuthenticationMiddleware')); $pipeline->pipe($container->get('AuthorizationMiddleware')); $pipeline->pipe($container->get('BodyParsingMiddleware')); $pipeline->pipe($container->get('ValidationMiddleware')); // This is the actual middleware you're routing to. $pipeline->pipe($container->get('ApiResource')); return $pipeline; } } This gives you full control over the creation of the pipeline. You would, however, need to ensure that you map the middleware to the pipeline factory when setting up your container configuration. One alternative when using zend-servicemanager is to use a delegator factory . Delegator factories allow you to decorate the primary factory used to create the middleware in order to change the instance or return an alternate instance. In this case, we'd do the latter. The following is an example: use Psr\\Container\\ContainerInterface; use Zend\\ServiceManager\\DelegatorFactoryInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; use Zend\\Stratigility\\MiddlewarePipe; class ApiResourcePipelineDelegatorFactory implements DelegatorFactoryInterface { /** * zend-servicemanager v3 support */ public function __invoke( ContainerInterface $container, $name, callable $callback, array $options = null ) { $pipeline = new MiddlewarePipe(); // These correspond to the bullet points above $pipeline->pipe($container->get('AuthenticationMiddleware')); $pipeline->pipe($container->get('AuthorizationMiddleware')); $pipeline->pipe($container->get('BodyParsingMiddleware')); $pipeline->pipe($container->get('ValidationMiddleware')); // This is the actual middleware you're routing to. $pipeline->pipe($callback()); return $pipeline; } /** * zend-servicemanager v2 support */ public function createDelegatorWithName( ServiceLocatorInterface $container, $name, $requestedName, $callback ) { return $this($container, $name, $callback); } } When configuring the container, you'd do something like the following: return [ 'dependencies' => [ 'factories' => [ 'AuthenticationMiddleware' => '...', 'AuthorizationMiddleware' => '...', 'BodyParsingMiddleware' => '...', 'ValidationMiddleware' => '...', 'ApiResourceMiddleware' => '...', ], 'delegators' => [ 'ApiResourceMiddleware' => [ 'ApiResourcePipelineDelegatorFactory', ], ], ], ]; This approach allows you to cleanly separate the factory for your middleware from the pipeline you want to compose it in, and allows you to re-use the pipeline creation across multiple middleware if desired. Middleware Arrays If you'd rather not create a factory for each such middleware, the other option is to use arrays of middlewares in your configuration or when routing manually. Via configuration looks like this: return [ 'routes' => [ [ 'name' => 'api-resource', 'path' => '/api/resource[/{id:[a-f0-9]{32}}]', 'allowed_methods' => ['GET', 'POST', 'PATCH', 'DELETE'], 'middleware' => [ 'AuthenticationMiddleware', 'AuthorizationMiddleware', 'BodyParsingMiddleware', 'ValidationMiddleware', 'ApiResourceMiddleware', ], ], ], ]; Manual routing looks like this: $app->route('/api/resource[/{id:[a-f0-9]{32}}]', [ 'AuthenticationMiddleware', 'AuthorizationMiddleware', 'BodyParsingMiddleware', 'ValidationMiddleware', 'ApiResourceMiddleware', ], ['GET', 'POST', 'PATCH', 'DELETE'], 'api-resource'); When either of these approaches are used, the individual middleware listed MUST be one of the following: an instance of Interop\\Http\\ServerMiddleware\\MiddlewareInterface ; a callable middleware (will be decorated as interop middleware); a service name of middleware available in the container; a fully qualified class name of a directly instantiable (no constructor arguments) middleware class. This approach is essentially equivalent to creating a factory that returns a middleware pipeline. What about pipeline middleware configuration? What if you want to do this with your pipeline middleware configuration? The answer is that the syntax is exactly the same! return [ 'middleware_pipeline' => [ 'api' => [ 'path' => '/api', 'middleware' => [ 'AuthenticationMiddleware', 'AuthorizationMiddleware', 'BodyParsingMiddleware', 'ValidationMiddleware', ], 'priority' => 100, ], ], ];","title":"Route-specific middleware pipelines"},{"location":"v2/cookbook/route-specific-pipeline/#how-can-i-specify-a-route-specific-middleware-pipeline","text":"Sometimes you may want to use a middleware pipeline only if a particular route is matched. As an example, for an API resource, you might want to: check for authentication credentials check for authorization for the selected action parse the incoming body validate the parsed body parameters before you actually execute the selected middleware. The above might each be encapsulated as discrete middleware, but should be executed within the routed middleware's context. You can accomplish this in one of two ways: Have your middleware service resolve to a MiddlewarePipe instance that composes the various middlewares. Specify an array of middlewares (either as actual instances, or as container service names); this effectively creates and returns a MiddlewarePipe .","title":"How can I specify a route-specific middleware pipeline?"},{"location":"v2/cookbook/route-specific-pipeline/#resolving-to-a-middlewarepipe","text":"You can do this programmatically within a container factory, assuming you are using a container that supports factories. use Psr\\Container\\ContainerInterface; use Zend\\Stratigility\\MiddlewarePipe; class ApiResourcePipelineFactory { public function __invoke(ContainerInterface $container) { $pipeline = new MiddlewarePipe(); // These correspond to the bullet points above $pipeline->pipe($container->get('AuthenticationMiddleware')); $pipeline->pipe($container->get('AuthorizationMiddleware')); $pipeline->pipe($container->get('BodyParsingMiddleware')); $pipeline->pipe($container->get('ValidationMiddleware')); // This is the actual middleware you're routing to. $pipeline->pipe($container->get('ApiResource')); return $pipeline; } } This gives you full control over the creation of the pipeline. You would, however, need to ensure that you map the middleware to the pipeline factory when setting up your container configuration. One alternative when using zend-servicemanager is to use a delegator factory . Delegator factories allow you to decorate the primary factory used to create the middleware in order to change the instance or return an alternate instance. In this case, we'd do the latter. The following is an example: use Psr\\Container\\ContainerInterface; use Zend\\ServiceManager\\DelegatorFactoryInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; use Zend\\Stratigility\\MiddlewarePipe; class ApiResourcePipelineDelegatorFactory implements DelegatorFactoryInterface { /** * zend-servicemanager v3 support */ public function __invoke( ContainerInterface $container, $name, callable $callback, array $options = null ) { $pipeline = new MiddlewarePipe(); // These correspond to the bullet points above $pipeline->pipe($container->get('AuthenticationMiddleware')); $pipeline->pipe($container->get('AuthorizationMiddleware')); $pipeline->pipe($container->get('BodyParsingMiddleware')); $pipeline->pipe($container->get('ValidationMiddleware')); // This is the actual middleware you're routing to. $pipeline->pipe($callback()); return $pipeline; } /** * zend-servicemanager v2 support */ public function createDelegatorWithName( ServiceLocatorInterface $container, $name, $requestedName, $callback ) { return $this($container, $name, $callback); } } When configuring the container, you'd do something like the following: return [ 'dependencies' => [ 'factories' => [ 'AuthenticationMiddleware' => '...', 'AuthorizationMiddleware' => '...', 'BodyParsingMiddleware' => '...', 'ValidationMiddleware' => '...', 'ApiResourceMiddleware' => '...', ], 'delegators' => [ 'ApiResourceMiddleware' => [ 'ApiResourcePipelineDelegatorFactory', ], ], ], ]; This approach allows you to cleanly separate the factory for your middleware from the pipeline you want to compose it in, and allows you to re-use the pipeline creation across multiple middleware if desired.","title":"Resolving to a MiddlewarePipe"},{"location":"v2/cookbook/route-specific-pipeline/#middleware-arrays","text":"If you'd rather not create a factory for each such middleware, the other option is to use arrays of middlewares in your configuration or when routing manually. Via configuration looks like this: return [ 'routes' => [ [ 'name' => 'api-resource', 'path' => '/api/resource[/{id:[a-f0-9]{32}}]', 'allowed_methods' => ['GET', 'POST', 'PATCH', 'DELETE'], 'middleware' => [ 'AuthenticationMiddleware', 'AuthorizationMiddleware', 'BodyParsingMiddleware', 'ValidationMiddleware', 'ApiResourceMiddleware', ], ], ], ]; Manual routing looks like this: $app->route('/api/resource[/{id:[a-f0-9]{32}}]', [ 'AuthenticationMiddleware', 'AuthorizationMiddleware', 'BodyParsingMiddleware', 'ValidationMiddleware', 'ApiResourceMiddleware', ], ['GET', 'POST', 'PATCH', 'DELETE'], 'api-resource'); When either of these approaches are used, the individual middleware listed MUST be one of the following: an instance of Interop\\Http\\ServerMiddleware\\MiddlewareInterface ; a callable middleware (will be decorated as interop middleware); a service name of middleware available in the container; a fully qualified class name of a directly instantiable (no constructor arguments) middleware class. This approach is essentially equivalent to creating a factory that returns a middleware pipeline.","title":"Middleware Arrays"},{"location":"v2/cookbook/route-specific-pipeline/#what-about-pipeline-middleware-configuration","text":"What if you want to do this with your pipeline middleware configuration? The answer is that the syntax is exactly the same! return [ 'middleware_pipeline' => [ 'api' => [ 'path' => '/api', 'middleware' => [ 'AuthenticationMiddleware', 'AuthorizationMiddleware', 'BodyParsingMiddleware', 'ValidationMiddleware', ], 'priority' => 100, ], ], ];","title":"What about pipeline middleware configuration?"},{"location":"v2/cookbook/setting-locale-depending-routing-parameter/","text":"How can I setup the locale depending on a routing parameter? Localized web applications often set the locale (and therefor the language) based on a routing parameter, the session, or a specialized sub-domain. In this recipe we will concentrate on using a routing parameter. Routing parameters Using the approach in this chapter requires that you add a /:locale (or similar) segment to each and every route that can be localized, and, depending on the router used, may also require additional options for specifying constraints. If the majority of your routes are localized, this will become tedious quickly. In such a case, you may want to look at the related recipe on setting the locale without routing parameters . Setting up the route If you want to set the locale depending on an routing parameter, you first have to add a locale parameter to each route that requires localization. In the following examples, we use the locale parameter, which should consist of two lowercase alphabetical characters. Dependency configuration The examples assume the following middleware dependency configuration: use Application\\Action; return [ 'dependencies' => [ 'factories' => [ Action\\HomePageAction::class => Action\\HomePageFactory::class, Action\\ContactPageAction::class => Action\\ContactPageFactory::class, ], ], ]; Programmatic routes The following describes routing configuration for use when using a programmatic application. use Application\\Action\\ContactPageAction; use Application\\Action\\HomePageAction; $localeOptions = ['locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)']; $app->get('/:locale', HomePageAction::class, 'home') ->setOptions($localeOptions); $app->get('/:locale/contact', ContactPageAction::class, 'contact') ->setOptions($localeOptions); Configuration-based routes The following describes routing configuration for use when using a configuration-driven application. return [ 'routes' => [ [ 'name' => 'home', 'path' => '/:locale', 'middleware' => Application\\Action\\HomePageAction::class, 'allowed_methods' => ['GET'], 'options' => [ 'constraints' => [ 'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)', ], ], ], [ 'name' => 'contact', 'path' => '/:locale/contact', 'middleware' => Application\\Action\\ContactPageAction::class, 'allowed_methods' => ['GET'], 'options' => [ 'constraints' => [ 'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)', ], ], ], ], ]; Note: Routing may differ based on router The routing examples in this recipe use syntax for the zend-mvc router, and, as such, may not work in your application. For Aura.Router, the 'home' route as listed above would read: $$$$FENCED_CODE_BLOCK_5e03bde9f07599.38384867 For FastRoute: $$$$FENCED_CODE_BLOCK_5e03bde9f07707.93362331 As such, be aware as you read the examples that you might not be able to simply cut-and-paste them without modification. Create a route result middleware class for localization To make sure that you can setup the locale after the routing has been processed, you need to implement localization middleware that acts on the route result, and registered in the pipeline immediately following the routing middleware. Such a LocalizationMiddleware class could look similar to this: <?php namespace Application\\I18n; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Locale; use Psr\\Http\\Message\\ServerRequestInterface; class LocalizationMiddleware implements MiddlewareInterface { const LOCALIZATION_ATTRIBUTE = 'locale'; public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // Get locale from route, fallback to the user's browser preference $locale = $request->getAttribute( 'locale', Locale::acceptFromHttp( $request->getServerParams()['HTTP_ACCEPT_LANGUAGE'] ?? 'en_US' ) ); // Store the locale as a request attribute return $delegate->process($request->withAttribute(self::LOCALIZATION_ATTRIBUTE, $locale)); } } Locale::setDefault is unsafe Do not use Locale::setDefault($locale) to set a global static locale. PSR-7 apps may run in async processes, which could lead to another process overwriting the value, and thus lead to unexpected results for your users. Use a request parameter as detailed above instead, as the request is created specific to each process. Register this new middleware in either config/autoload/middleware-pipeline.global.php or config/autoload/dependencies.global.php : return [ 'dependencies' => [ 'invokables' => [ LocalizationMiddleware::class => LocalizationMiddleware::class, /* ... */ ], /* ... */ ], ]; If using a programmatic pipeline, pipe it immediately after your routing middleware: use Application\\I18n\\LocalizationMiddleware; /* ... */ $app->pipeRoutingMiddleware(); $app->pipe(LocalizationMiddleware::class); /* ... */ If using a configuration-driven application, register it within your config/autoload/middleware-pipeline.global.php file, injecting it into the pipeline following the routing middleware: return [ 'middleware_pipeline' => [ /* ... */ [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Helper\\UrlHelperMiddleware::class, LocalizationMiddleware::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], /* ... */ ], ];","title":"Setting a locale based on a routing parameter"},{"location":"v2/cookbook/setting-locale-depending-routing-parameter/#how-can-i-setup-the-locale-depending-on-a-routing-parameter","text":"Localized web applications often set the locale (and therefor the language) based on a routing parameter, the session, or a specialized sub-domain. In this recipe we will concentrate on using a routing parameter.","title":"How can I setup the locale depending on a routing parameter?"},{"location":"v2/cookbook/setting-locale-depending-routing-parameter/#setting-up-the-route","text":"If you want to set the locale depending on an routing parameter, you first have to add a locale parameter to each route that requires localization. In the following examples, we use the locale parameter, which should consist of two lowercase alphabetical characters.","title":"Setting up the route"},{"location":"v2/cookbook/setting-locale-depending-routing-parameter/#create-a-route-result-middleware-class-for-localization","text":"To make sure that you can setup the locale after the routing has been processed, you need to implement localization middleware that acts on the route result, and registered in the pipeline immediately following the routing middleware. Such a LocalizationMiddleware class could look similar to this: <?php namespace Application\\I18n; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Locale; use Psr\\Http\\Message\\ServerRequestInterface; class LocalizationMiddleware implements MiddlewareInterface { const LOCALIZATION_ATTRIBUTE = 'locale'; public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // Get locale from route, fallback to the user's browser preference $locale = $request->getAttribute( 'locale', Locale::acceptFromHttp( $request->getServerParams()['HTTP_ACCEPT_LANGUAGE'] ?? 'en_US' ) ); // Store the locale as a request attribute return $delegate->process($request->withAttribute(self::LOCALIZATION_ATTRIBUTE, $locale)); } }","title":"Create a route result middleware class for localization"},{"location":"v2/cookbook/setting-locale-without-routing-parameter/","text":"How can I setup the locale without routing parameters? Localized web applications often set the locale (and therefore the language) based on a routing parameter, the session, or a specialized sub-domain. In this recipe we will concentrate on introspecting the URI path via middleware, which allows you to have a global mechanism for detecting the locale without requiring any changes to existing routes. Distinguishing between routes that require localization If your application has a mixture of routes that require localization, and those that do not, the solution in this recipe may lead to multiple URIs that resolve to the identical action, which may be undesirable. In such cases, you may want to prefix the specific routes that require localization with a required routing parameter; this approach is described in the \"Setting a locale based on a routing parameter\" recipe . Setup a middleware to extract the locale from the URI First, we need to setup middleware that extracts the locale param directly from the request URI's path. If if doesn't find one, it sets a default. If it does find one, it uses the value to setup the locale. It also: amends the request with a truncated path (removing the locale segment). adds the locale segment as the base path of the UrlHelper . <?php namespace Application\\I18n; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Locale; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Expressive\\Helper\\UrlHelper; class SetLocaleMiddleware implements MiddlewareInterface { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { $uri = $request->getUri(); $path = $uri->getPath(); if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) { Locale::setDefault('de_DE'); return $delegate->process($request); } $locale = $matches['locale']; Locale::setDefault(Locale::canonicalize($locale)); $this->helper->setBasePath($locale); return $delegate->process($request->withUri( $uri->withPath(substr($path, strlen($locale)+1)) )); } } Then you will need a factory for the SetLocaleMiddleware to inject the UrlHelper instance. <?php namespace Application\\I18n; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Helper\\UrlHelper; class SetLocaleMiddlewareFactory { public function __invoke(ContainerInterface $container) { return new SetLocaleMiddleware( $container->get(UrlHelper::class) ); } } Next, map the middleware to its factory in either /config/autoload/dependencies.global.php or /config/autoload/middleware-pipeline.global.php : use Application\\I18n\\SetLocaleMiddleware; use Application\\I18n\\SetLocaleMiddlewareFactory; return [ 'dependencies' => [ /* ... */ 'factories' => [ SetLocaleMiddleware::class => SetLocaleMiddlewareFactory::class, /* ... */ ], ], ]; Finally, you will need to configure your middleware pipeline to ensure this middleware is executed on every request. If using a programmatic pipeline: use Application\\I18n\\SetLocaleMiddleware; use Zend\\Expressive\\Helper\\UrlHelperMiddleware; /* ... */ $app->pipe(SetLocaleMiddleware::class); /* ... */ $app->pipeRoutingMiddleware(); $app->pipe(UrlHelperMiddleware::class); $app->pipeDispatchMiddleware(); /* ... */ If using a configuration-driven application, update /config/autoload/middleware-pipeline.global.php to add the middleware: return [ 'middleware_pipeline' => [ [ 'middleware' => [ Application\\I18n\\SetLocaleMiddleware::class, /* ... */ ], 'priority' => 1000, ], /* ... */ 'routing' => [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Zend\\Expressive\\Helper\\UrlHelperMiddleware::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], /* ... */ ], ]; Url generation in the view Since the UrlHelper has the locale set as a base path, you don't need to worry about generating URLs within your view. Just use the helper to generate a URL and it will do the rest. <?php echo $this->url('your-route') ?> Helpers differ between template renderers The above example is specific to zend-view; syntax will differ for Twig and Plates. Redirecting within your middleware If you want to add the locale parameter when creating URIs within your action middleware, you just need to inject the UrlHelper into your middleware and use it for URL generation: <?php namespace Application\\Action; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\RedirectResponse; use Zend\\Expressive\\Helper\\UrlHelper; class RedirectAction implements MiddlewareInterface { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } /** * @param ServerRequestInterface $request * @param DelegateInterface $delegate * @return RedirectResponse */ public function process(ServerRequestInterface $request, DelegateInterface $delegate) { $routeParams = [ /* ... */ ]; return new RedirectResponse( $this->helper->generate('your-route', $routeParams) ); } } Injecting the UrlHelper into your middleware will also require that the middleware have a factory that manages the injection. As an example, the following would work for the above middleware: namespace Application\\Action; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Helper\\UrlHelper; class RedirectActionFactory { public function __invoke(ContainerInterface $container) { return new RedirectAction( $container->get(UrlHelper::class) ); } }","title":"Setting a locale without a routing parameter"},{"location":"v2/cookbook/setting-locale-without-routing-parameter/#how-can-i-setup-the-locale-without-routing-parameters","text":"Localized web applications often set the locale (and therefore the language) based on a routing parameter, the session, or a specialized sub-domain. In this recipe we will concentrate on introspecting the URI path via middleware, which allows you to have a global mechanism for detecting the locale without requiring any changes to existing routes.","title":"How can I setup the locale without routing parameters?"},{"location":"v2/cookbook/setting-locale-without-routing-parameter/#setup-a-middleware-to-extract-the-locale-from-the-uri","text":"First, we need to setup middleware that extracts the locale param directly from the request URI's path. If if doesn't find one, it sets a default. If it does find one, it uses the value to setup the locale. It also: amends the request with a truncated path (removing the locale segment). adds the locale segment as the base path of the UrlHelper . <?php namespace Application\\I18n; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Locale; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Expressive\\Helper\\UrlHelper; class SetLocaleMiddleware implements MiddlewareInterface { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { $uri = $request->getUri(); $path = $uri->getPath(); if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) { Locale::setDefault('de_DE'); return $delegate->process($request); } $locale = $matches['locale']; Locale::setDefault(Locale::canonicalize($locale)); $this->helper->setBasePath($locale); return $delegate->process($request->withUri( $uri->withPath(substr($path, strlen($locale)+1)) )); } } Then you will need a factory for the SetLocaleMiddleware to inject the UrlHelper instance. <?php namespace Application\\I18n; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Helper\\UrlHelper; class SetLocaleMiddlewareFactory { public function __invoke(ContainerInterface $container) { return new SetLocaleMiddleware( $container->get(UrlHelper::class) ); } } Next, map the middleware to its factory in either /config/autoload/dependencies.global.php or /config/autoload/middleware-pipeline.global.php : use Application\\I18n\\SetLocaleMiddleware; use Application\\I18n\\SetLocaleMiddlewareFactory; return [ 'dependencies' => [ /* ... */ 'factories' => [ SetLocaleMiddleware::class => SetLocaleMiddlewareFactory::class, /* ... */ ], ], ]; Finally, you will need to configure your middleware pipeline to ensure this middleware is executed on every request. If using a programmatic pipeline: use Application\\I18n\\SetLocaleMiddleware; use Zend\\Expressive\\Helper\\UrlHelperMiddleware; /* ... */ $app->pipe(SetLocaleMiddleware::class); /* ... */ $app->pipeRoutingMiddleware(); $app->pipe(UrlHelperMiddleware::class); $app->pipeDispatchMiddleware(); /* ... */ If using a configuration-driven application, update /config/autoload/middleware-pipeline.global.php to add the middleware: return [ 'middleware_pipeline' => [ [ 'middleware' => [ Application\\I18n\\SetLocaleMiddleware::class, /* ... */ ], 'priority' => 1000, ], /* ... */ 'routing' => [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Zend\\Expressive\\Helper\\UrlHelperMiddleware::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], /* ... */ ], ];","title":"Setup a middleware to extract the locale from the URI"},{"location":"v2/cookbook/setting-locale-without-routing-parameter/#url-generation-in-the-view","text":"Since the UrlHelper has the locale set as a base path, you don't need to worry about generating URLs within your view. Just use the helper to generate a URL and it will do the rest. <?php echo $this->url('your-route') ?>","title":"Url generation in the view"},{"location":"v2/cookbook/setting-locale-without-routing-parameter/#redirecting-within-your-middleware","text":"If you want to add the locale parameter when creating URIs within your action middleware, you just need to inject the UrlHelper into your middleware and use it for URL generation: <?php namespace Application\\Action; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\RedirectResponse; use Zend\\Expressive\\Helper\\UrlHelper; class RedirectAction implements MiddlewareInterface { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } /** * @param ServerRequestInterface $request * @param DelegateInterface $delegate * @return RedirectResponse */ public function process(ServerRequestInterface $request, DelegateInterface $delegate) { $routeParams = [ /* ... */ ]; return new RedirectResponse( $this->helper->generate('your-route', $routeParams) ); } } Injecting the UrlHelper into your middleware will also require that the middleware have a factory that manages the injection. As an example, the following would work for the above middleware: namespace Application\\Action; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Helper\\UrlHelper; class RedirectActionFactory { public function __invoke(ContainerInterface $container) { return new RedirectAction( $container->get(UrlHelper::class) ); } }","title":"Redirecting within your middleware"},{"location":"v2/cookbook/using-a-base-path/","text":"How can I tell my application about a base path? In some environments, your application may be running in a subdirectory of your web root. For example: var/ |- www/ | |- wordpress/ | |- expressive/ | | |- public/ | | | |- index.php where /var/www is the web root, and your Expressive application is in the expressive/ subdirectory. How can you make your application work correctly in this environment? .htaccess in the application root. If you are using Apache, your first step is to add an .htaccess file to your application root, with directives for rewriting to the public/ directory: RewriteEngine On RewriteRule (.*) ./public/$1 Using other web servers If you are using a web-server other than Apache, and know how to do a similar rewrite, we'd love to know! Please submit ideas/instructions to our issue tracker ! Use middleware to rewrite the path The above step ensures that clients can hit the website. Now we need to ensure that the application can route to middleware! To do this, we will add pipeline middleware to intercept the request, and rewrite the URL accordingly. At the time of writing, we have two suggestions: los/basepath provides the basic mechanics of rewriting the URL, and has a stable release. mtymek/blast-base-url provides the URL rewriting mechanics, as well as utilities for generating URIs that retain the base path, but does not have a stable release yet. los/basepath To use los/basepath , install it via Composer, copy the configuration files to your application, and then edit the configuration. To install and copy the configuration: $ composer require los/basepath $ cp vendor/los/basepath/config/los-basepath.global.php.dist config/autoload/los-basepath.global.php We recommend copying the global configuration to a local configuration file as well; this allows you to have the production settings in your global configuration, and development settings in a local configuration (which is excluded from git by default): $ cp config/autoload/los-basepath.global.php config/autoload/los-basepath.local.php Then edit one or both, to change the los_basepath settings: return [ 'los_basepath' => '<base path here>', /* ... */ ]; The base path should be the portion of the web root leading up to the index.php of your application. In the above example, this would be /expressive . mtymek/blast-base-url To use mtymek/blast-base-url , install it via Composer, and register some configuration. To install it: $ composer require mtymek/blast-base-url To configure it, update the file config/autoload/middleware-pipeline.global.php , or config/autoload/dependencies.global.php to map the middleware to its factory: return [ 'dependencies' => [ 'factories' => [ Blast\\BaseUrl\\BaseUrlMiddleware::class => Blast\\BaseUrl\\BaseUrlMiddlewareFactory::class, /* ... */ ], /* ... */ ], ]; If using programmatic pipelines, pipe the middleware early in your pipeline: $app->pipe(\\Blast\\BaseUrl\\BaseUrlMiddleware::class); For configuration-driven pipelines, add an entry in your config/autoload/middleware-pipeline.global.php file: 'middleware_pipeline' => [ ['middleware' => [Blast\\BaseUrl\\BaseUrlMiddleware::class], 'priority' => 1000], /* ... */ ], At this point, the middleware will take care of the rewriting for you. No configuration is necessary, as it does auto-detection of the base path based on the request URI and the operating system path to the application. The primary advantage of mtymek/blast-base-url is in its additional features: it injects Zend\\Expressive\\Helper\\UrlHelper with the base path, allowing you to create relative route-based URLs. it provides a new helper, Blast\\BaseUrl\\BasePathHelper , which allows you to create URLs relative to the base path; this is particularly useful for assets. To enable these features, we'll add some configuration to config/autoload/dependencies.global.php file: return [ 'dependencies' => [ 'invokables' => [ Blast\\BaseUrl\\BasePathHelper::class => Blast\\BaseUrl\\BasePathHelper::class, /* ... */ ], ], ]; Finally, if you're using zend-view, you can register a new \"basePath\" helper in your config/autoload/templates.global.php : return [ /* ... */ 'view_helpers' => [ 'factories' => [ 'basePath' => Blast\\BaseUrl\\BasePathViewHelperFactory::class, /* ... */ ], /* ... */ ], ]; Usage of the BasePath helper is as follows: // where $basePathHelper is an instance of Blast\\BaseUrl\\BasePathHelper // as pulled from your container: echo $basePathHelper('/icons/favicon.ico'); // or, from zend-view's PhpRenderer: echo $this->basePath('/icons/favicon.ico');","title":"Using Expressive from a subdirectory"},{"location":"v2/cookbook/using-a-base-path/#how-can-i-tell-my-application-about-a-base-path","text":"In some environments, your application may be running in a subdirectory of your web root. For example: var/ |- www/ | |- wordpress/ | |- expressive/ | | |- public/ | | | |- index.php where /var/www is the web root, and your Expressive application is in the expressive/ subdirectory. How can you make your application work correctly in this environment?","title":"How can I tell my application about a base path?"},{"location":"v2/cookbook/using-a-base-path/#htaccess-in-the-application-root","text":"If you are using Apache, your first step is to add an .htaccess file to your application root, with directives for rewriting to the public/ directory: RewriteEngine On RewriteRule (.*) ./public/$1","title":".htaccess in the application root."},{"location":"v2/cookbook/using-a-base-path/#use-middleware-to-rewrite-the-path","text":"The above step ensures that clients can hit the website. Now we need to ensure that the application can route to middleware! To do this, we will add pipeline middleware to intercept the request, and rewrite the URL accordingly. At the time of writing, we have two suggestions: los/basepath provides the basic mechanics of rewriting the URL, and has a stable release. mtymek/blast-base-url provides the URL rewriting mechanics, as well as utilities for generating URIs that retain the base path, but does not have a stable release yet.","title":"Use middleware to rewrite the path"},{"location":"v2/cookbook/using-custom-view-helpers/","text":"How do you register custom view helpers when using zend-view? If you've selected zend-view as your preferred template renderer, you may want to define and use custom view helpers. How can you use them? Assuming you've used the Expressive skeleton to start your application, you will already have a factory defined for Zend\\View\\HelperPluginManager , and it will be injected into the PhpRenderer instance used. Since the HelperPluginManager is available, we can configure it. Open the file config/autoload/templates.global.php . In that file, you'll see three top-level keys: return [ 'dependencies' => [ /* ... */ ], 'templates' => [ /* ... */ ], 'view_helpers' => [ /* ... */ ], ]; The last is the one you want. In this, you can define service mappings, including aliases, invokables, factories, and abstract factories to define how helpers are named and created. See the zend-view custom helpers documentation for information on how to populate this configuration.","title":"Registering custom view helpers when using zend-view"},{"location":"v2/cookbook/using-custom-view-helpers/#how-do-you-register-custom-view-helpers-when-using-zend-view","text":"If you've selected zend-view as your preferred template renderer, you may want to define and use custom view helpers. How can you use them? Assuming you've used the Expressive skeleton to start your application, you will already have a factory defined for Zend\\View\\HelperPluginManager , and it will be injected into the PhpRenderer instance used. Since the HelperPluginManager is available, we can configure it. Open the file config/autoload/templates.global.php . In that file, you'll see three top-level keys: return [ 'dependencies' => [ /* ... */ ], 'templates' => [ /* ... */ ], 'view_helpers' => [ /* ... */ ], ]; The last is the one you want. In this, you can define service mappings, including aliases, invokables, factories, and abstract factories to define how helpers are named and created. See the zend-view custom helpers documentation for information on how to populate this configuration.","title":"How do you register custom view helpers when using zend-view?"},{"location":"v2/cookbook/using-routed-middleware-class-as-controller/","text":"Handling multiple routes in a single class Typically, in Expressive, we would define one middleware class per route. For a standard CRUD-style application, however, this leads to multiple related classes: AlbumPageIndex AlbumPageEdit AlbumPageAdd If you are familiar with frameworks that provide controllers capable of handling multiple \"actions\", such as those found in Zend Framework's MVC layer, Symfony, CodeIgniter, CakePHP, and other popular frameworks, you may want to apply a similar pattern when using Expressive. In other words, what if we want to use only one middleware class to facilitate all three of the above? In the following example, we'll use an action routing parameter which our middleware class will use in order to determine which internal method to invoke. Consider the following route configuration: use Album\\Action\\AlbumPage; // Programmatic: $app->get('/album[/{action:add|edit}[/{id}]]', AlbumPage::class, 'album'); // Config-driven: return [ /* ... */ 'routes' => [ /* ... */ [ 'name' => 'album', 'path' => '/album[/{action:add|edit}[/{id}]]', 'middleware' => AlbumPage::class, 'allowed_methods' => ['GET'], ], /* ... */ ], ]; The above each define a route that will match any of the following: /album /album/add /album/edit/3 The action attribute can thus be one of add or edit , and we can optionally also receive an id attribute (in the latter example, it would be 3 ). Routing definitions may vary Depending on the router you chose when starting your project, your routing definition may differ. The above example uses the default FastRoute implementation. We might then implement Album\\Action\\AlbumPage as follows: <?php namespace Album\\Action; use Fig\\Http\\Message\\StatusCodeInterface as StatusCode; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\EmptyResponse; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Template\\TemplateRendererInterface; class AlbumPage implements MiddlewareInterface { private $template; public function __construct(TemplateRendererInterface $template) { $this->template = $template; } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { switch ($request->getAttribute('action', 'index')) { case 'index': return $this->indexAction($request, $delegate); case 'add': return $this->addAction($request, $delegate); case 'edit': return $this->editAction($request, $delegate); default: // Invalid; thus, a 404! return new EmptyResponse(StatusCode::STATUS_NOT_FOUND); } } public function indexAction(ServerRequestInterface $request, DelegateInterface $delegate) { return new HtmlResponse($this->template->render('album::album-page')); } public function addAction(ServerRequestInterface $request, DelegateInterface $delegate) { return new HtmlResponse($this->template->render('album::album-page-add')); } public function editAction(ServerRequestInterface $request, DelegateInterface $delegate) { $id = $request->getAttribute('id', false); if (! $id) { throw new \\InvalidArgumentException('id parameter must be provided'); } return new HtmlResponse( $this->template->render('album::album-page-edit', ['id' => $id]) ); } } This allows us to have the same dependencies for a set of related actions, and, if desired, even have common internal methods each can utilize. This approach is reasonable, but requires that I create a similar process() implementation every time I want to accomplish a similar workflow. Let's create a generic implementation, via an AbstractPage class: <?php namespace App\\Action; use Fig\\Http\\Message\\StatusCodeInterface as StatusCode; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\EmptyResponse; abstract class AbstractPage implements MiddlewareInterface { public function process(ServerRequestInterface $request, DelegateInterface $delegate) { $action = $request->getAttribute('action', 'index') . 'Action'; if (! method_exists($this, $action)) { return new EmptyResponse(StatusCode::STATUS_NOT_FOUND); } return $this->$action($request, $delegate); } } The above abstract class pulls the action attribute on invocation, and concatenates it with the word Action . It then uses this value to determine if a corresponding method exists in the current class, and, if so, calls it with the arguments it received; otherwise, it returns an empty 404 response. Our original AlbumPage implementation could then be modified to extend AbstractPage : namespace Album\\Action; use App\\Action\\AbstractPage; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Template\\TemplateRendererInterface; class AlbumPage extends AbstractPage { private $template; public function __construct(TemplateRendererInterface $template) { $this->template = $template; } public function indexAction( /* ... */ ) { /* ... */ } public function addAction( /* ... */ ) { /* ... */ } public function editAction( /* ... */ ) { /* ... */ } } Or use a trait As an alternative to an abstract class, you could define the __invoke() logic in a trait, which you then compose into your middleware: $$$$FENCED_CODE_BLOCK_5e03bde9f00f21.37682149 You would then compose it into a class as follows: $$$$FENCED_CODE_BLOCK_5e03bde9f010d9.29572579","title":"Handling multiple routes in a single class"},{"location":"v2/cookbook/using-routed-middleware-class-as-controller/#handling-multiple-routes-in-a-single-class","text":"Typically, in Expressive, we would define one middleware class per route. For a standard CRUD-style application, however, this leads to multiple related classes: AlbumPageIndex AlbumPageEdit AlbumPageAdd If you are familiar with frameworks that provide controllers capable of handling multiple \"actions\", such as those found in Zend Framework's MVC layer, Symfony, CodeIgniter, CakePHP, and other popular frameworks, you may want to apply a similar pattern when using Expressive. In other words, what if we want to use only one middleware class to facilitate all three of the above? In the following example, we'll use an action routing parameter which our middleware class will use in order to determine which internal method to invoke. Consider the following route configuration: use Album\\Action\\AlbumPage; // Programmatic: $app->get('/album[/{action:add|edit}[/{id}]]', AlbumPage::class, 'album'); // Config-driven: return [ /* ... */ 'routes' => [ /* ... */ [ 'name' => 'album', 'path' => '/album[/{action:add|edit}[/{id}]]', 'middleware' => AlbumPage::class, 'allowed_methods' => ['GET'], ], /* ... */ ], ]; The above each define a route that will match any of the following: /album /album/add /album/edit/3 The action attribute can thus be one of add or edit , and we can optionally also receive an id attribute (in the latter example, it would be 3 ).","title":"Handling multiple routes in a single class"},{"location":"v2/cookbook/using-zend-form-view-helpers/","text":"How can I use zend-form view helpers? If you've selected zend-view as your preferred template renderer, you'll likely want to use the various view helpers available in other components, such as: zend-form zend-i18n zend-navigation By default, only the view helpers directly available in zend-view are available; how can you add the others? ConfigProvider When you install zend-form, Composer should prompt you if you want to inject one or more ConfigProvider classes, including those from zend-hydrator, zend-inputfilter, and several others. Always answer \"yes\" to these; when you do, a Composer plugin will add entries for their ConfigProvider classes to your config/config.php file. If for some reason you are not prompted, or chose \"no\" when answering the prompts, you can add them manually. Add the following entries in the array used to create your ConfigAggregator instance within config/config.php : \\Zend\\Form\\ConfigProvider::class, \\Zend\\InputFilter\\ConfigProvider::class, \\Zend\\Filter\\ConfigProvider::class, \\Zend\\Validator\\ConfigProvider::class, \\Zend\\Hydrator\\ConfigProvider::class, If you installed Expressive via the skeleton, the service Zend\\View\\HelperPluginManager is registered for you, and represents the helper plugin manager injected into the PhpRenderer instance. This instance gets its helper configuration from the view_helpers top-level configuration key \u2014 which the zend-form ConfigProvider helps to populate! At this point, all view helpers provided by zend-form are registered and ready to use. Alternative options to configure HelperPluginManager: Replace the HelperPluginManager factory with your own; or Add a delegator factory to or extend the HelperPluginManager service to inject the additional helper configuration; or Add pipeline middleware that composes the HelperPluginManager and configures it. Replacing the HelperPluginManager factory The zend-view integration provides Zend\\Expressive\\ZendView\\HelperPluginManagerFactory , and the Expressive skeleton registers it be default. The simplest solution for adding other helpers is to replace it with your own. In your own factory, you will also configure the plugin manager with the configuration from the zend-form component (or whichever other components you wish to use). namespace Your\\Application; use Psr\\Container\\ContainerInterface; use Zend\\ServiceManager\\Config; use Zend\\View\\HelperPluginManager; class HelperPluginManagerFactory { public function __invoke(ContainerInterface $container) { $manager = new HelperPluginManager($container); $config = $container->has('config') ? $container->get('config') : []; $config = isset($config['view_helpers']) ? $config['view_helpers'] : []; (new Config($config))->configureServiceManager($manager); return $manager; } } In your config/autoload/templates.global.php file, change the line that reads: Zend\\View\\HelperPluginManager::class => Zend\\Expressive\\ZendView\\HelperPluginManagerFactory::class, to instead read as: Zend\\View\\HelperPluginManager::class => Your\\Application\\HelperPluginManagerFactory::class, This approach will work for any of the various containers supported. Delegator factories/service extension Delegator factories and service extension operate on the same principle: they intercept after the original factory was called, and then operate on the generated instance, either modifying or replacing it. We'll demonstrate this for zend-servicemanager and Pimple; at the time of writing, we're unaware of a mechanism for doing so in Aura.Di. zend-servicemanager You'll first need to create a delegator factory: namespace Your\\Application; use Psr\\Container\\ContainerInterface; use Zend\\ServiceManager\\Config; use Zend\\ServiceManager\\DelegatorFactoryInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; class FormHelpersDelegatorFactory { /** * zend-servicemanager v3 support */ public function __invoke( ContainerInterface $container, $name, callable $callback, array $options = null ) { $helpers = $callback(); $config = $container->has('config') ? $container->get('config') : []; $config = new Config($config['view_helpers']); $config->configureServiceManager($helpers); return $helpers; } /** * zend-servicemanager v2 support */ public function createDelegatorWithName( ServiceLocatorInterface $container, $name, $requestedName, $callback ) { return $this($container, $name, $callback); } } The above creates an instance of Zend\\ServiceManager\\Config , uses it to configure the already created Zend\\View\\HelperPluginManager instance, and then returns the plugin manager instance. From here, you'll add a delegators configuration key in your config/autoload/templates.global.php file: return [ 'dependencies' => [ 'delegators' => [ Zend\\View\\HelperPluginManager::class => [ Your\\Application\\FormHelpersDelegatorFactory::class, ], ], /* ... */ ], 'templates' => [ /* ... */ ], 'view_helpers' => [ /* ... */ ], ]; Note: delegator factories are keyed by the service they modify, and the value is an array of delegator factories, to allow multiple such factories to be in use. Pimple For Pimple, we don't currently support configuration of service extensions, so you'll need to edit the main container configuration file, config/container.php . Place the following anywhere after the factories and invokables are defined: // The following assumes you've added the following import statements to // the start of the file: // use Zend\\ServiceManager\\Config as ServiceConfig; // use Zend\\View\\HelperPluginManager; $container[HelperPluginManager::class] = $container->extend( HelperPluginManager::class, function ($helpers, $container) { $config = isset($container['config']) ? $container['config'] : []; $config = new ServiceConfig($config['view_helpers']); $config->configureServiceManager($helpers); return $helpers; } ); Pipeline middleware Another option is to use pipeline middleware. This approach will require that the middleware execute on every request, which introduces (very slight) performance overhead. However, it's a portable method that works regardless of the container implementation you choose. First, define the middleware: namespace Your\\Application use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Form\\View\\HelperConfig as FormHelperConfig; use Zend\\View\\HelperPluginManager; class FormHelpersMiddleware implements MiddlewareInterface { private $helpers; public function __construct(HelperPluginManager $helpers) { $this->helpers = $helpers; } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { $config = new FormHelperConfig(); $config->configureServiceManager($this->helpers); return $delegate->process($request); } } You'll also need a factory for the middleware, to ensure it receives the HelperPluginManager : namespace Your\\Application use Zend\\View\\HelperPluginManager; class FormHelpersMiddlewareFactory { public function __invoke($container) { return new FormHelpersMiddleware( $container->get(HelperPluginManager::class) ); } } Next, register the middleware with its factory in one of config/autoload/middleware-pipeline.global.php or config/autoload/dependencies.global.php : return [ 'dependencies' => [ 'factories' => [ Your\\Application\\FormHelpersMiddleware::class => Your\\Application\\FormHelpersMiddlewareFactory::class /* ... */ ], /* ... */ ], ]; If using programmatic pipelines, pipe the middleware in an appropriate location in your pipeline: $app->pipe(FormHelpersMiddleware::class); // or, perhaps, in a route-specific middleware pipeline: $app->post('/register', [ FormHelpersMiddleware::class, RegisterMiddleware::class, ], 'register'); If using configuration-driven pipelines or routing: // Via the middleware pipeline: 'middleware_pipeline' => [ ['middleware' => Your\\Application\\FormHelpersMiddleware::class, 'priority' => 1000], ], // Or via routes: 'routes' => [ [ 'name' => 'register', 'path' => '/register', 'middleware' => [ FormHelpersMiddleware::class, RegisterMiddleware::class, ], 'allowed_methods' => ['POST'], ] ] At that point, you're all set! Registering more helpers What if you need to register helpers from multiple components? You can do so using the same technique above. Better yet, do them all at once! If you chose to use delegator factories/service extension, do all helper configuration registrations for all components in the same factory. If you chose to use middleware, do all helper configuration registrations for all components in the same middleware.","title":"Using zend-form view helpers"},{"location":"v2/cookbook/using-zend-form-view-helpers/#how-can-i-use-zend-form-view-helpers","text":"If you've selected zend-view as your preferred template renderer, you'll likely want to use the various view helpers available in other components, such as: zend-form zend-i18n zend-navigation By default, only the view helpers directly available in zend-view are available; how can you add the others?","title":"How can I use zend-form view helpers?"},{"location":"v2/cookbook/using-zend-form-view-helpers/#configprovider","text":"When you install zend-form, Composer should prompt you if you want to inject one or more ConfigProvider classes, including those from zend-hydrator, zend-inputfilter, and several others. Always answer \"yes\" to these; when you do, a Composer plugin will add entries for their ConfigProvider classes to your config/config.php file. If for some reason you are not prompted, or chose \"no\" when answering the prompts, you can add them manually. Add the following entries in the array used to create your ConfigAggregator instance within config/config.php : \\Zend\\Form\\ConfigProvider::class, \\Zend\\InputFilter\\ConfigProvider::class, \\Zend\\Filter\\ConfigProvider::class, \\Zend\\Validator\\ConfigProvider::class, \\Zend\\Hydrator\\ConfigProvider::class, If you installed Expressive via the skeleton, the service Zend\\View\\HelperPluginManager is registered for you, and represents the helper plugin manager injected into the PhpRenderer instance. This instance gets its helper configuration from the view_helpers top-level configuration key \u2014 which the zend-form ConfigProvider helps to populate! At this point, all view helpers provided by zend-form are registered and ready to use. Alternative options to configure HelperPluginManager: Replace the HelperPluginManager factory with your own; or Add a delegator factory to or extend the HelperPluginManager service to inject the additional helper configuration; or Add pipeline middleware that composes the HelperPluginManager and configures it.","title":"ConfigProvider"},{"location":"v2/cookbook/using-zend-form-view-helpers/#replacing-the-helperpluginmanager-factory","text":"The zend-view integration provides Zend\\Expressive\\ZendView\\HelperPluginManagerFactory , and the Expressive skeleton registers it be default. The simplest solution for adding other helpers is to replace it with your own. In your own factory, you will also configure the plugin manager with the configuration from the zend-form component (or whichever other components you wish to use). namespace Your\\Application; use Psr\\Container\\ContainerInterface; use Zend\\ServiceManager\\Config; use Zend\\View\\HelperPluginManager; class HelperPluginManagerFactory { public function __invoke(ContainerInterface $container) { $manager = new HelperPluginManager($container); $config = $container->has('config') ? $container->get('config') : []; $config = isset($config['view_helpers']) ? $config['view_helpers'] : []; (new Config($config))->configureServiceManager($manager); return $manager; } } In your config/autoload/templates.global.php file, change the line that reads: Zend\\View\\HelperPluginManager::class => Zend\\Expressive\\ZendView\\HelperPluginManagerFactory::class, to instead read as: Zend\\View\\HelperPluginManager::class => Your\\Application\\HelperPluginManagerFactory::class, This approach will work for any of the various containers supported.","title":"Replacing the HelperPluginManager factory"},{"location":"v2/cookbook/using-zend-form-view-helpers/#delegator-factoriesservice-extension","text":"Delegator factories and service extension operate on the same principle: they intercept after the original factory was called, and then operate on the generated instance, either modifying or replacing it. We'll demonstrate this for zend-servicemanager and Pimple; at the time of writing, we're unaware of a mechanism for doing so in Aura.Di.","title":"Delegator factories/service extension"},{"location":"v2/cookbook/using-zend-form-view-helpers/#pipeline-middleware","text":"Another option is to use pipeline middleware. This approach will require that the middleware execute on every request, which introduces (very slight) performance overhead. However, it's a portable method that works regardless of the container implementation you choose. First, define the middleware: namespace Your\\Application use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Form\\View\\HelperConfig as FormHelperConfig; use Zend\\View\\HelperPluginManager; class FormHelpersMiddleware implements MiddlewareInterface { private $helpers; public function __construct(HelperPluginManager $helpers) { $this->helpers = $helpers; } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { $config = new FormHelperConfig(); $config->configureServiceManager($this->helpers); return $delegate->process($request); } } You'll also need a factory for the middleware, to ensure it receives the HelperPluginManager : namespace Your\\Application use Zend\\View\\HelperPluginManager; class FormHelpersMiddlewareFactory { public function __invoke($container) { return new FormHelpersMiddleware( $container->get(HelperPluginManager::class) ); } } Next, register the middleware with its factory in one of config/autoload/middleware-pipeline.global.php or config/autoload/dependencies.global.php : return [ 'dependencies' => [ 'factories' => [ Your\\Application\\FormHelpersMiddleware::class => Your\\Application\\FormHelpersMiddlewareFactory::class /* ... */ ], /* ... */ ], ]; If using programmatic pipelines, pipe the middleware in an appropriate location in your pipeline: $app->pipe(FormHelpersMiddleware::class); // or, perhaps, in a route-specific middleware pipeline: $app->post('/register', [ FormHelpersMiddleware::class, RegisterMiddleware::class, ], 'register'); If using configuration-driven pipelines or routing: // Via the middleware pipeline: 'middleware_pipeline' => [ ['middleware' => Your\\Application\\FormHelpersMiddleware::class, 'priority' => 1000], ], // Or via routes: 'routes' => [ [ 'name' => 'register', 'path' => '/register', 'middleware' => [ FormHelpersMiddleware::class, RegisterMiddleware::class, ], 'allowed_methods' => ['POST'], ] ] At that point, you're all set!","title":"Pipeline middleware"},{"location":"v2/cookbook/using-zend-form-view-helpers/#registering-more-helpers","text":"What if you need to register helpers from multiple components? You can do so using the same technique above. Better yet, do them all at once! If you chose to use delegator factories/service extension, do all helper configuration registrations for all components in the same factory. If you chose to use middleware, do all helper configuration registrations for all components in the same middleware.","title":"Registering more helpers"},{"location":"v2/features/application/","text":"Applications In zend-expressive, you define a Zend\\Expressive\\Application instance and execute it. The Application instance is itself middleware that composes: a router , for dynamically routing requests to middleware. a dependency injection container , for retrieving middleware to dispatch. a default delegate (Expressive 2.X) or final handler an emitter , for emitting the response when application execution is complete. You can define the Application instance in several ways: Direct instantiation, which requires providing several dependencies. The AppFactory , which will use some common defaults, but allows injecting alternate container and/or router implementations. Via a dependency injection container; we provide a factory for setting up all aspects of the instance via configuration and other defined services. Regardless of how you setup the instance, there are several methods you will likely interact with at some point or another. Instantiation As noted at the start of this document, we provide several ways to create an Application instance. Constructor If you wish to manually instantiate the Application instance, it has the following constructor: /** * @param Zend\\Expressive\\Router\\RouterInterface $router * @param null|Psr\\Container\\ContainerInterface $container IoC container from which to pull services, if any. * @param null|Interop\\Http\\ServerMiddleware\\DelegateInterface $defaultDelegate * Delegate to invoke when the internal middleware pipeline is exhausted * without returning a response. * @param null|Zend\\Diactoros\\Response\\EmitterInterface $emitter Emitter to use when `run()` is * invoked. */ public function __construct( Zend\\Expressive\\Router\\RouterInterface $router, Psr\\Container\\ContainerInterface $container = null, Interop\\Http\\ServerMiddleware\\DelegateInterface $defaultDelegate = null, Zend\\Diactoros\\Response\\EmitterInterface $emitter = null ); If no container is provided at instantiation, then all routed and piped middleware must be provided as callables. AppFactory Deprecated since version 2.2; instantiate Application directly and/or use a Zend\\Stratigility\\MiddlewarePipe instance instead. Zend\\Expressive\\AppFactory provides a convenience layer for creating an Application instance; it makes the assumption that you will use defaults in most situations, and likely only change which container and/or router you wish to use. It has the following signature: AppFactory::create( Psr\\Container\\ContainerInterface $container = null, Zend\\Expressive\\Router\\RouterInterface $router = null ); When no container or router are provided, it defaults to: zend-servicemanager for the container. FastRoute for the router. Container factory We also provide a factory that can be consumed by a PSR-11 dependency injection container; see the container factories documentation for details. Adding routable middleware We discuss routing vs piping elsewhere ; routing is the act of dynamically matching an incoming request against criteria, and it is one of the primary features of zend-expressive. Regardless of which router implementation you use, you can use the following methods to provide routable middleware: route() route() has the following signature: public function route( $pathOrRoute, $middleware = null, array $methods = null, $name = null ) : Zend\\Expressive\\Router\\Route where: $pathOrRoute may be either a string path to match, or a Zend\\Expressive\\Router\\Route instance. $middleware must be present if $pathOrRoute is a string path, and must be: a callable; a service name that resolves to valid middleware in the container; a fully qualified class name of a constructor-less class; an array of any of the above; these will be composed in order into a Zend\\Stratigility\\MiddlewarePipe instance. $methods must be an array of HTTP methods valid for the given path and middleware. If null, it assumes any method is valid. $name is the optional name for the route, and is used when generating a URI from known routes. See the section on route naming for details. This method is typically only used if you want a single middleware to handle multiple HTTP request methods. get(), post(), put(), patch(), delete(), any() Each of the methods get() , post() , put() , patch() , delete() , and any() proxies to route() and has the signature: function ( $pathOrRoute, $middleware = null, $name = null ) : Zend\\Expressive\\Router\\Route Essentially, each calls route() and specifies an array consisting solely of the corresponding HTTP method for the $methods argument. Piping Because zend-expressive builds on zend-stratigility , and, more specifically, its MiddlewarePipe definition, you can also pipe (queue) middleware to the application. This is useful for adding middleware that should execute on each request, defining error handlers, and/or segregating applications by subpath. The signature of pipe() is: public function pipe($pathOrMiddleware, $middleware = null) where: $pathOrMiddleware is either a string URI path (for path segregation), a callable middleware, or the service name for a middleware to fetch from the composed container. $middleware is required if $pathOrMiddleware is a string URI path. It can be one of: a callable; a service name that resolves to valid middleware in the container; a fully qualified class name of a constructor-less class; an array of any of the above; these will be composed in order into a Zend\\Stratigility\\MiddlewarePipe instance. Unlike Zend\\Stratigility\\MiddlewarePipe , Application::pipe() allows fetching middleware by service name . This facility allows lazy-loading of middleware only when it is invoked. Internally, it wraps the call to fetch and dispatch the middleware inside a closure. Additionally, we define a new method, pipeErrorHandler() , with the following signature: public function pipeErrorHandler($pathOrMiddleware, $middleware = null) It acts just like pipe() except when the middleware specified is a service name; in that particular case, when it wraps the middleware in a closure, it uses the error handler signature: function ($error, ServerRequestInterface $request, ResponseInterface $response, callable $next); Read the section on piping vs routing for more information. Registering routing and dispatch middleware Routing is accomplished via dedicated middleware, Zend\\Expressive\\Middleware\\RouteMiddleware ; similarly, dispatching of routed middleware has a corresponding middleware, Zend\\Expressive\\Middleware\\DispatchMiddleware . Each can be piped/registered with other middleware platforms if desired. These methods MUST be piped to the application so that the application will route and dispatch routed middleware. This is done using the following methods: $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); See the section on piping to see how you can register non-routed middleware and create layered middleware applications. Changed in version 2.2 Starting in version 2.2, the methods pipeRoutingMiddleware and pipeDispatchMiddleware are deprecated in favor of piping the middleware manually. Additionally, the middleware has been ported to the zend-expressive-router package, under the namespace Zend\\Expressive\\Router\\Middleware . We suggest piping them by service name. Please see our migration documentation for more details, and for information on how to automatically update your application. Retrieving dependencies As noted in the intro, the Application class has several dependencies. Some of these may allow further configuration, or may be useful on their own, and have methods for retrieving them. They include: getContainer() : returns the composed PSR-11 container instance (used to retrieve routed middleware). getEmitter() : returns the composed emitter , typically a Zend\\Expressive\\Emitter\\EmitterStack instance. getDefaultDelegate() : retrieves the default delegate to use when the internal middleware pipeline is exhausted without returning a response. If none is provided at instantiation, this method will do one of the following: If no container is composed, instanatiates a Zend\\Expressive\\Delegate\\NotFoundDelegate using the composed response prototype only. If a container is composed, but does not have the Zend\\Expressive\\Delegate\\DefaultDelegate service, it creates and invokes an instance of Zend\\Expressive\\Container\\NotFoundDelegateFactory , passing it the composed container, and uses the value created. If a container is composed and contains the Zend\\Expressive\\Delegate\\DefaultDelegate service, it returns that. Deprecated Each of the above methods are deprecated starting in version 2.2, and will be removed in version 3.0. Executing the application: run() When the application is completely setup, you can execute it with the run() method. The method may be called with no arguments, but has the following signature: public function run( ServerRequestInterface $request = null, ResponseInterface $response = null );","title":"Applications"},{"location":"v2/features/application/#applications","text":"In zend-expressive, you define a Zend\\Expressive\\Application instance and execute it. The Application instance is itself middleware that composes: a router , for dynamically routing requests to middleware. a dependency injection container , for retrieving middleware to dispatch. a default delegate (Expressive 2.X) or final handler an emitter , for emitting the response when application execution is complete. You can define the Application instance in several ways: Direct instantiation, which requires providing several dependencies. The AppFactory , which will use some common defaults, but allows injecting alternate container and/or router implementations. Via a dependency injection container; we provide a factory for setting up all aspects of the instance via configuration and other defined services. Regardless of how you setup the instance, there are several methods you will likely interact with at some point or another.","title":"Applications"},{"location":"v2/features/application/#instantiation","text":"As noted at the start of this document, we provide several ways to create an Application instance.","title":"Instantiation"},{"location":"v2/features/application/#adding-routable-middleware","text":"We discuss routing vs piping elsewhere ; routing is the act of dynamically matching an incoming request against criteria, and it is one of the primary features of zend-expressive. Regardless of which router implementation you use, you can use the following methods to provide routable middleware:","title":"Adding routable middleware"},{"location":"v2/features/application/#retrieving-dependencies","text":"As noted in the intro, the Application class has several dependencies. Some of these may allow further configuration, or may be useful on their own, and have methods for retrieving them. They include: getContainer() : returns the composed PSR-11 container instance (used to retrieve routed middleware). getEmitter() : returns the composed emitter , typically a Zend\\Expressive\\Emitter\\EmitterStack instance. getDefaultDelegate() : retrieves the default delegate to use when the internal middleware pipeline is exhausted without returning a response. If none is provided at instantiation, this method will do one of the following: If no container is composed, instanatiates a Zend\\Expressive\\Delegate\\NotFoundDelegate using the composed response prototype only. If a container is composed, but does not have the Zend\\Expressive\\Delegate\\DefaultDelegate service, it creates and invokes an instance of Zend\\Expressive\\Container\\NotFoundDelegateFactory , passing it the composed container, and uses the value created. If a container is composed and contains the Zend\\Expressive\\Delegate\\DefaultDelegate service, it returns that.","title":"Retrieving dependencies"},{"location":"v2/features/application/#executing-the-application-run","text":"When the application is completely setup, you can execute it with the run() method. The method may be called with no arguments, but has the following signature: public function run( ServerRequestInterface $request = null, ResponseInterface $response = null );","title":"Executing the application: run()"},{"location":"v2/features/emitters/","text":"Emitters To simplify the usage of Expressive, we added the run() method, which handles the incoming request, and emits a response. The latter aspect, emitting the response, is the responsibility of an emitter . An emitter accepts a response instance, and then does something with it, usually sending the response back to a browser. Diactoros defines an EmitterInterface , and \u2014 as of the time we write this \u2014 a single emitter implementation, Zend\\Diactoros\\Response\\SapiEmitter , which sends headers and output using PHP's standard SAPI mechanisms (the header() method and the output buffer). We recognize that there are times when you may want to use alternate emitter implementations; for example, if you use React , the SAPI emitter will likely not work for you. To facilitate alternate emitters, we offer two facilities: First, Application composes an emitter, and you can specify an alternate emitter during instantiation, or via the Zend\\Diactoros\\Response\\EmitterInterface service when using the container factory. Second, we provide Zend\\Expressive\\Emitter\\EmitterStack , which allows you to compose multiple emitter strategies; the first to return a value other than boolean false will cause execution of the stack to short-circuit. Application composes an EmitterStack by default, with an SapiEmitter composed at the bottom of the stack. EmitterStack The EmitterStack is an SplStack extension that implements EmitterInterface . You can add emitters to the stack by pushing them on: $stack->push($emitterInstance); As a stack, execution is in LIFO (last in, first out) order; the first emitter on the stack will be evaluated last. Deprecated with version 2.2 Starting in version 2.2, the EmitterStack is deprecated, and moved, along with the zend-diactoros EmitterInterface and implementations, to a new package, zend-httphandlerrunner . The interface and the EmitterStack are roughly identical to what is present in version 2; if you are defining a Zend\\Diactoros\\Emitter\\EmitterInterface service of your own, you will need to update it in that version.","title":"Emitters"},{"location":"v2/features/emitters/#emitters","text":"To simplify the usage of Expressive, we added the run() method, which handles the incoming request, and emits a response. The latter aspect, emitting the response, is the responsibility of an emitter . An emitter accepts a response instance, and then does something with it, usually sending the response back to a browser. Diactoros defines an EmitterInterface , and \u2014 as of the time we write this \u2014 a single emitter implementation, Zend\\Diactoros\\Response\\SapiEmitter , which sends headers and output using PHP's standard SAPI mechanisms (the header() method and the output buffer). We recognize that there are times when you may want to use alternate emitter implementations; for example, if you use React , the SAPI emitter will likely not work for you. To facilitate alternate emitters, we offer two facilities: First, Application composes an emitter, and you can specify an alternate emitter during instantiation, or via the Zend\\Diactoros\\Response\\EmitterInterface service when using the container factory. Second, we provide Zend\\Expressive\\Emitter\\EmitterStack , which allows you to compose multiple emitter strategies; the first to return a value other than boolean false will cause execution of the stack to short-circuit. Application composes an EmitterStack by default, with an SapiEmitter composed at the bottom of the stack.","title":"Emitters"},{"location":"v2/features/emitters/#emitterstack","text":"The EmitterStack is an SplStack extension that implements EmitterInterface . You can add emitters to the stack by pushing them on: $stack->push($emitterInstance); As a stack, execution is in LIFO (last in, first out) order; the first emitter on the stack will be evaluated last.","title":"EmitterStack"},{"location":"v2/features/error-handling/","text":"Error Handling We recommend that your code raise exceptions for conditions where it cannot gracefully recover. Additionally, we recommend that you have a reasonable PHP error_reporting setting that includes warnings and fatal errors: error_reporting(E_ALL & ~E_USER_DEPRECATED & ~E_DEPRECATED & ~E_STRICT & ~E_NOTICE); If you follow these guidelines, you can then write or use middleware that does the following: sets an error handler that converts PHP errors to ErrorException instances. wraps execution of the delegate ( $delegate->process() ) with a try/catch block. As an example: function ($request, DelegateInterface $delegate) { set_error_handler(function ($errno, $errstr, $errfile, $errline) { if (! (error_reporting() & $errno)) { // Error is not in mask return; } throw new ErrorException($errstr, 0, $errno, $errfile, $errline); }); try { $response = $delegate->process($request); return $response; } catch (Throwable $e) { } catch (Exception $e) { } restore_error_handler(); $response = new TextResponse(sprintf( \"[%d] %s\\n\\n%s\", $e->getCode(), $e->getMessage(), $e->getTraceAsString() ), 500); } You would then pipe this as the outermost (or close to outermost) layer of your application: $app->pipe($errorMiddleware); So that you do not need to do this, we provide an error handler for you, via zend-stratigility: Zend\\Stratigility\\Middleware\\ErrorHandler . This implementation allows you to both: provide a response generator, invoked when an error is caught; and register listeners to trigger when errors are caught. We provide the factory Zend\\Expressive\\Container\\ErrorHandlerFactory for generating the instance; it should be mapped to the service Zend\\Stratigility\\Middleware\\ErrorHandler . We provide two error response generators for you: Zend\\Expressive\\Middleware\\ErrorResponseGenerator , which optionally will accept a Zend\\Expressive\\Template\\TemplateRendererInterface instance, and a template name. When present, these will be used to generate response content; otherwise, a plain text response is generated that notes the request method and URI. Zend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator , which uses whoops to present detailed exception and request information; this implementation is intended for development purposes. Each also has an accompanying factory for generating the instance: Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory Map the service Zend\\Expressive\\Middleware\\ErrorResponseGenerator to one of these two factories in your configuration: use Zend\\Expressive\\Container; use Zend\\Expressive\\Middleware; use Zend\\Stratigility\\Middleware\\ErrorHandler; return [ 'dependencies' => [ 'factories' => [ ErrorHandler::class => Container\\ErrorHandlerFactory::class, Middleware\\ErrorResponseGenerator::class => Container\\ErrorResponseGeneratorFactory::class, ], ], ]; Use development mode configuration to enable whoops You can specify the above in one of your config/autoload/*.global.php files, to ensure you have a production-capable error response generator. If you are using zf-development-mode in your application (which is provided by default in the skeleton application), you can toggle usage of whoops by adding configuration to the file config/autoload/development.local.php.dist : $$$$FENCED_CODE_BLOCK_5e03bde9ed87b3.86804867 When you enable development mode, whoops will then be enabled; when you disable development mode, you'll be using your production generator. If you are not using zf-development-mode, you can define a config/autoload/*.local.php file with the above configuration whenever you want to enable whoops. Listening for errors When errors occur, you may want to listen for them in order to provide features such as logging. Zend\\Stratigility\\Middleware\\ErrorHandler provides the ability to do so via its attachListener() method. This method accepts a callable with the following signature: function ( Throwable|Exception $error, ServerRequestInterface $request, ResponseInterface $response ) : void The response provided is the response returned by your error response generator, allowing the listener the ability to introspect the generated response as well. As an example, you could create a logging listener as follows: namespace Acme; use Exception; use Psr\\Log\\LoggerInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Throwable; class LoggingErrorListener { /** * Log format for messages: * * STATUS [METHOD] path: message */ const LOG_FORMAT = '%d [%s] %s: %s'; private $logger; public function __construct(LoggerInterface $logger) { $this->logger = $logger; } public function __invoke($error, ServerRequestInterface $request, ResponseInterface $response) { $this->logger->error(sprintf( self::LOG_FORMAT, $response->getStatusCode(), $request->getMethod(), (string) $request->getUri(), $error->getMessage() )); } } You could then use a delegator factory to create your logger listener and attach it to your error handler: namespace Acme; use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; use Zend\\Stratigility\\Middleware\\ErrorHandler; class LoggingErrorListenerDelegatorFactory { /** * @param ContainerInterface $container * @param string $name * @param callable $callback * @return ErrorHandler */ public function __invoke(ContainerInterface $container, $name, callable $callback) { $listener = new LoggingErrorListener($container->get(LoggerInterface::class)); $errorHandler = $callback(); $errorHandler->attachListener($listener); return $errorHandler; } } Handling more specific error types You could also write more specific error handlers. As an example, you might want to catch UnauthorizedException instances specifically, and display a login page: function ($request, DelegateInterface $delegate) use ($renderer) { try { $response = $delegate->process($request); return $response; } catch (UnauthorizedException $e) { } return new HtmlResponse( $renderer->render('error::unauthorized'), 401 ); } You could then push this into a middleware pipe only when it's needed: $app->get('/dashboard', [ $unauthorizedHandlerMiddleware, $middlewareThatChecksForAuthorization, $middlewareBehindAuthorizationWall, ], 'dashboard'); Default delegates Zend\\Expressive\\Application manages an internal middleware pipeline; when you call $delegate->process() , Application is popping off the next middleware in the queue and dispatching it. What happens when that queue is exhausted? That situation indicates an error condition: no middleware was capable of returning a response. This could either mean a problem with the request (HTTP 400 \"Bad Request\" status) or inability to route the request (HTTP 404 \"Not Found\" status). In order to report that information, Zend\\Expressive\\Application composes a \"default delegate\": a delegate it will invoke once the queue is exhausted and no response returned. By default, it uses a custom implementation, Zend\\Expressive\\Delegate\\NotFoundDelegate , which will report a 404 response, optionally using a composed template renderer to do so. We provide a factory, Zend\\Expressive\\Container\\NotFoundDelegateFactory , for creating an instance, and this should be mapped to the Zend\\Expressive\\Delegate\\NotFoundDelegate service, and aliased to the Zend\\Expressive\\Delegate\\DefaultDelegate service: use Zend\\Expressive\\Container; use Zend\\Expressive\\Delegate; return [ 'dependencies' => [ 'aliases' => [ 'Zend\\Expressive\\Delegate\\DefaultDelegate' => Delegate\\NotFoundDelegate::class, ], 'factories' => [ Delegate\\NotFoundDelegate::class => Container\\NotFoundDelegateFactory::class, ], ], ]; The factory will consume the following services: Zend\\Expressive\\Template\\TemplateRendererInterface (optional): if present, the renderer will be used to render a template for use as the response content. config (optional): if present, it will use the $config['zend-expressive']['error_handler']['template_404'] value as the template to use when rendering; if not provided, defaults to error::404 . If you wish to provide an alternate response status or use a canned response, you should provide your own default delegate, and expose it via the Zend\\Expressive\\Delegate\\DefaultDelegate service. Page not found Error handlers work at the outermost layer, and are used to catch exceptions and errors in your application. At the innermost layer of your application, you should ensure you have middleware that is guaranteed to return a response; this will prevent the default delegate from needing to execute by ensuring that the middleware queue never fully depletes. This in turn allows you to fully craft what sort of response is returned. Generally speaking, reaching the innermost middleware layer indicates that no middleware was capable of handling the request, and thus an HTTP 404 Not Found condition. To simplify such responses, we provide Zend\\Expressive\\Middleware\\NotFoundHandler , with an accompanying Zend\\Expressive\\Container\\NotFoundHandlerFactory . This middleware composes and proxies to the NotFoundDelegate detailed in the previous section, and, as such, requires that that service be present. use Zend\\Expressive\\Container; use Zend\\Expressive\\Delegate; use Zend\\Expressive\\Middleware; return [ 'factories' => [ Delegate\\NotFoundDelegate::class => Container\\NotFoundDelegateFactory::class, Middleware\\NotFoundHandler::class => Container\\NotFoundHandlerFactory::class, ], ]; When registered, you should then pipe it as the innermost layer of your application: // A basic application: $app->pipe(ErrorHandler::class); $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); $app->pipe(NotFoundHandler::class);","title":"Error Handling"},{"location":"v2/features/error-handling/#error-handling","text":"We recommend that your code raise exceptions for conditions where it cannot gracefully recover. Additionally, we recommend that you have a reasonable PHP error_reporting setting that includes warnings and fatal errors: error_reporting(E_ALL & ~E_USER_DEPRECATED & ~E_DEPRECATED & ~E_STRICT & ~E_NOTICE); If you follow these guidelines, you can then write or use middleware that does the following: sets an error handler that converts PHP errors to ErrorException instances. wraps execution of the delegate ( $delegate->process() ) with a try/catch block. As an example: function ($request, DelegateInterface $delegate) { set_error_handler(function ($errno, $errstr, $errfile, $errline) { if (! (error_reporting() & $errno)) { // Error is not in mask return; } throw new ErrorException($errstr, 0, $errno, $errfile, $errline); }); try { $response = $delegate->process($request); return $response; } catch (Throwable $e) { } catch (Exception $e) { } restore_error_handler(); $response = new TextResponse(sprintf( \"[%d] %s\\n\\n%s\", $e->getCode(), $e->getMessage(), $e->getTraceAsString() ), 500); } You would then pipe this as the outermost (or close to outermost) layer of your application: $app->pipe($errorMiddleware); So that you do not need to do this, we provide an error handler for you, via zend-stratigility: Zend\\Stratigility\\Middleware\\ErrorHandler . This implementation allows you to both: provide a response generator, invoked when an error is caught; and register listeners to trigger when errors are caught. We provide the factory Zend\\Expressive\\Container\\ErrorHandlerFactory for generating the instance; it should be mapped to the service Zend\\Stratigility\\Middleware\\ErrorHandler . We provide two error response generators for you: Zend\\Expressive\\Middleware\\ErrorResponseGenerator , which optionally will accept a Zend\\Expressive\\Template\\TemplateRendererInterface instance, and a template name. When present, these will be used to generate response content; otherwise, a plain text response is generated that notes the request method and URI. Zend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator , which uses whoops to present detailed exception and request information; this implementation is intended for development purposes. Each also has an accompanying factory for generating the instance: Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory Map the service Zend\\Expressive\\Middleware\\ErrorResponseGenerator to one of these two factories in your configuration: use Zend\\Expressive\\Container; use Zend\\Expressive\\Middleware; use Zend\\Stratigility\\Middleware\\ErrorHandler; return [ 'dependencies' => [ 'factories' => [ ErrorHandler::class => Container\\ErrorHandlerFactory::class, Middleware\\ErrorResponseGenerator::class => Container\\ErrorResponseGeneratorFactory::class, ], ], ];","title":"Error Handling"},{"location":"v2/features/error-handling/#listening-for-errors","text":"When errors occur, you may want to listen for them in order to provide features such as logging. Zend\\Stratigility\\Middleware\\ErrorHandler provides the ability to do so via its attachListener() method. This method accepts a callable with the following signature: function ( Throwable|Exception $error, ServerRequestInterface $request, ResponseInterface $response ) : void The response provided is the response returned by your error response generator, allowing the listener the ability to introspect the generated response as well. As an example, you could create a logging listener as follows: namespace Acme; use Exception; use Psr\\Log\\LoggerInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Throwable; class LoggingErrorListener { /** * Log format for messages: * * STATUS [METHOD] path: message */ const LOG_FORMAT = '%d [%s] %s: %s'; private $logger; public function __construct(LoggerInterface $logger) { $this->logger = $logger; } public function __invoke($error, ServerRequestInterface $request, ResponseInterface $response) { $this->logger->error(sprintf( self::LOG_FORMAT, $response->getStatusCode(), $request->getMethod(), (string) $request->getUri(), $error->getMessage() )); } } You could then use a delegator factory to create your logger listener and attach it to your error handler: namespace Acme; use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; use Zend\\Stratigility\\Middleware\\ErrorHandler; class LoggingErrorListenerDelegatorFactory { /** * @param ContainerInterface $container * @param string $name * @param callable $callback * @return ErrorHandler */ public function __invoke(ContainerInterface $container, $name, callable $callback) { $listener = new LoggingErrorListener($container->get(LoggerInterface::class)); $errorHandler = $callback(); $errorHandler->attachListener($listener); return $errorHandler; } }","title":"Listening for errors"},{"location":"v2/features/error-handling/#handling-more-specific-error-types","text":"You could also write more specific error handlers. As an example, you might want to catch UnauthorizedException instances specifically, and display a login page: function ($request, DelegateInterface $delegate) use ($renderer) { try { $response = $delegate->process($request); return $response; } catch (UnauthorizedException $e) { } return new HtmlResponse( $renderer->render('error::unauthorized'), 401 ); } You could then push this into a middleware pipe only when it's needed: $app->get('/dashboard', [ $unauthorizedHandlerMiddleware, $middlewareThatChecksForAuthorization, $middlewareBehindAuthorizationWall, ], 'dashboard');","title":"Handling more specific error types"},{"location":"v2/features/error-handling/#default-delegates","text":"Zend\\Expressive\\Application manages an internal middleware pipeline; when you call $delegate->process() , Application is popping off the next middleware in the queue and dispatching it. What happens when that queue is exhausted? That situation indicates an error condition: no middleware was capable of returning a response. This could either mean a problem with the request (HTTP 400 \"Bad Request\" status) or inability to route the request (HTTP 404 \"Not Found\" status). In order to report that information, Zend\\Expressive\\Application composes a \"default delegate\": a delegate it will invoke once the queue is exhausted and no response returned. By default, it uses a custom implementation, Zend\\Expressive\\Delegate\\NotFoundDelegate , which will report a 404 response, optionally using a composed template renderer to do so. We provide a factory, Zend\\Expressive\\Container\\NotFoundDelegateFactory , for creating an instance, and this should be mapped to the Zend\\Expressive\\Delegate\\NotFoundDelegate service, and aliased to the Zend\\Expressive\\Delegate\\DefaultDelegate service: use Zend\\Expressive\\Container; use Zend\\Expressive\\Delegate; return [ 'dependencies' => [ 'aliases' => [ 'Zend\\Expressive\\Delegate\\DefaultDelegate' => Delegate\\NotFoundDelegate::class, ], 'factories' => [ Delegate\\NotFoundDelegate::class => Container\\NotFoundDelegateFactory::class, ], ], ]; The factory will consume the following services: Zend\\Expressive\\Template\\TemplateRendererInterface (optional): if present, the renderer will be used to render a template for use as the response content. config (optional): if present, it will use the $config['zend-expressive']['error_handler']['template_404'] value as the template to use when rendering; if not provided, defaults to error::404 . If you wish to provide an alternate response status or use a canned response, you should provide your own default delegate, and expose it via the Zend\\Expressive\\Delegate\\DefaultDelegate service.","title":"Default delegates"},{"location":"v2/features/error-handling/#page-not-found","text":"Error handlers work at the outermost layer, and are used to catch exceptions and errors in your application. At the innermost layer of your application, you should ensure you have middleware that is guaranteed to return a response; this will prevent the default delegate from needing to execute by ensuring that the middleware queue never fully depletes. This in turn allows you to fully craft what sort of response is returned. Generally speaking, reaching the innermost middleware layer indicates that no middleware was capable of handling the request, and thus an HTTP 404 Not Found condition. To simplify such responses, we provide Zend\\Expressive\\Middleware\\NotFoundHandler , with an accompanying Zend\\Expressive\\Container\\NotFoundHandlerFactory . This middleware composes and proxies to the NotFoundDelegate detailed in the previous section, and, as such, requires that that service be present. use Zend\\Expressive\\Container; use Zend\\Expressive\\Delegate; use Zend\\Expressive\\Middleware; return [ 'factories' => [ Delegate\\NotFoundDelegate::class => Container\\NotFoundDelegateFactory::class, Middleware\\NotFoundHandler::class => Container\\NotFoundHandlerFactory::class, ], ]; When registered, you should then pipe it as the innermost layer of your application: // A basic application: $app->pipe(ErrorHandler::class); $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); $app->pipe(NotFoundHandler::class);","title":"Page not found"},{"location":"v2/features/middleware-types/","text":"Middleware Types Expressive allows you to compose applications out of pipeline and routed middleware. Pipeline middleware is middleware that defines the workflow of your application. These generally run on every execution of the application, and include such aspects as: Error handling Locale detection Session setup Authentication and authorization Routed middleware is middleware that responds only to specific URI paths and HTTP methods. As an example, you might want middleware that only responds to HTTP POST requests to the path /users . Expressive allows you to define middleware using any of the following: http-interop/http-middleware instances. Callable middleware that implements the http-interop/http-middleware signature. Callable \"double-pass\" middleware (as used in Expressive 1.X, and supported in Expressive 2.X). Service names resolving to one of the above middleware types. Middleware pipelines expressed as arrays of the above middleware types. http-interop/http-middleware The http-interop/http-middleware project is the basis for the proposed PSR-15 specification, which covers HTTP Server Middleware that consumes PSR-7 HTTP messages. The project defines two interfaces, Interop\\Http\\ServerMiddleware\\MiddlewareInterface and Interop\\Http\\ServerMiddleware\\DelegateInterface . Expressive accepts middleware that implements the MiddlewareInterface . As an example: use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; class SomeMiddleware implements MiddlewareInterface { public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // do something and return a response, or // delegate to another handler capable of // returning a response via: // // return $delegate->process($request); } } If you are using PHP 7 or above, you could also implement such middleware via an anonymous class. Callable http-middleware Sometimes you may not want to create a class for one-off middleware. As such, Expressive allows you to provide a PHP callable that uses the same signature as Interop\\Http\\ServerMiddleware\\MiddlewareInterface : use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; function (ServerRequestInterface $request, DelegateInterface $delegate) { // do something and return a response, or // delegate to another handler capable of // returning a response via: // // return $delegate->process($request); } One note: the $request argument does not require a typehint, and examples throughout the manual will omit the typehint when demonstrating callable middleware. Double-pass middleware Expressive 1.X was based on Stratigility 1.X, which allowed middleware with the following signature: <?php use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; function( ServerRequestInterface $request, ResponseInterface $response, callable $next ) { // Process the request and return a response, // or delegate to another process to handle // the request via: // // return $next($request, $response); } This middleware is called \"double-pass\" due to the fact that it requires both the request and response arguments. In such middleware, no typehints are required , but they are encouraged . Additionally, we encourage users to never use the provided $response argument, but instead create a concrete response to return, or manipulate the response returned by $next ; this prevents a number of potential error conditions that may otherwise occur due to incomplete or mutated response state. This middleware is still supported in Expressive 2.X, but we encourage users to adopt http-interop/http-middleware signatures, as we will be deprecating double-pass middleware eventually. Service-based middleware We encourage the use of a dependency injection container for providing your middleware. As such, Expressive also allows you to use service names for both pipeline and routed middleware. Generally, service names will be the specific middleware class names, but can be any valid string that resolves to a service. When Expressive is provided a service name for middleware, it internally decorates the middleware in a Zend\\Expressive\\Middleware\\LazyLoadingMiddleware instance, allowing it to be loaded only when dispatched. Middleware pipelines Expressive allows any pipeline or routed middleware to be self-contained middleware pipelines . To prevent the need for instantiating a Zend\\Stratigility\\MiddlewarePipe or Zend\\Expressive\\Application instance when defining the pipeline, Expressive allows you to provide an array of middleware: // Pipeline middleware: $app->pipe([ FirstMiddleware::class, SecondMiddleware::class, ]); // Routed middleware: $app->get([ FirstMiddleware::class, SecondMiddleware::class, ]); The values in these arrays may be any valid middleware type as defined in this chapter.","title":"Middleware Types"},{"location":"v2/features/middleware-types/#middleware-types","text":"Expressive allows you to compose applications out of pipeline and routed middleware. Pipeline middleware is middleware that defines the workflow of your application. These generally run on every execution of the application, and include such aspects as: Error handling Locale detection Session setup Authentication and authorization Routed middleware is middleware that responds only to specific URI paths and HTTP methods. As an example, you might want middleware that only responds to HTTP POST requests to the path /users . Expressive allows you to define middleware using any of the following: http-interop/http-middleware instances. Callable middleware that implements the http-interop/http-middleware signature. Callable \"double-pass\" middleware (as used in Expressive 1.X, and supported in Expressive 2.X). Service names resolving to one of the above middleware types. Middleware pipelines expressed as arrays of the above middleware types.","title":"Middleware Types"},{"location":"v2/features/middleware-types/#http-interophttp-middleware","text":"The http-interop/http-middleware project is the basis for the proposed PSR-15 specification, which covers HTTP Server Middleware that consumes PSR-7 HTTP messages. The project defines two interfaces, Interop\\Http\\ServerMiddleware\\MiddlewareInterface and Interop\\Http\\ServerMiddleware\\DelegateInterface . Expressive accepts middleware that implements the MiddlewareInterface . As an example: use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; class SomeMiddleware implements MiddlewareInterface { public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // do something and return a response, or // delegate to another handler capable of // returning a response via: // // return $delegate->process($request); } } If you are using PHP 7 or above, you could also implement such middleware via an anonymous class.","title":"http-interop/http-middleware"},{"location":"v2/features/middleware-types/#callable-http-middleware","text":"Sometimes you may not want to create a class for one-off middleware. As such, Expressive allows you to provide a PHP callable that uses the same signature as Interop\\Http\\ServerMiddleware\\MiddlewareInterface : use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; function (ServerRequestInterface $request, DelegateInterface $delegate) { // do something and return a response, or // delegate to another handler capable of // returning a response via: // // return $delegate->process($request); } One note: the $request argument does not require a typehint, and examples throughout the manual will omit the typehint when demonstrating callable middleware.","title":"Callable http-middleware"},{"location":"v2/features/middleware-types/#double-pass-middleware","text":"Expressive 1.X was based on Stratigility 1.X, which allowed middleware with the following signature: <?php use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; function( ServerRequestInterface $request, ResponseInterface $response, callable $next ) { // Process the request and return a response, // or delegate to another process to handle // the request via: // // return $next($request, $response); } This middleware is called \"double-pass\" due to the fact that it requires both the request and response arguments. In such middleware, no typehints are required , but they are encouraged . Additionally, we encourage users to never use the provided $response argument, but instead create a concrete response to return, or manipulate the response returned by $next ; this prevents a number of potential error conditions that may otherwise occur due to incomplete or mutated response state. This middleware is still supported in Expressive 2.X, but we encourage users to adopt http-interop/http-middleware signatures, as we will be deprecating double-pass middleware eventually.","title":"Double-pass middleware"},{"location":"v2/features/middleware-types/#service-based-middleware","text":"We encourage the use of a dependency injection container for providing your middleware. As such, Expressive also allows you to use service names for both pipeline and routed middleware. Generally, service names will be the specific middleware class names, but can be any valid string that resolves to a service. When Expressive is provided a service name for middleware, it internally decorates the middleware in a Zend\\Expressive\\Middleware\\LazyLoadingMiddleware instance, allowing it to be loaded only when dispatched.","title":"Service-based middleware"},{"location":"v2/features/middleware-types/#middleware-pipelines","text":"Expressive allows any pipeline or routed middleware to be self-contained middleware pipelines . To prevent the need for instantiating a Zend\\Stratigility\\MiddlewarePipe or Zend\\Expressive\\Application instance when defining the pipeline, Expressive allows you to provide an array of middleware: // Pipeline middleware: $app->pipe([ FirstMiddleware::class, SecondMiddleware::class, ]); // Routed middleware: $app->get([ FirstMiddleware::class, SecondMiddleware::class, ]); The values in these arrays may be any valid middleware type as defined in this chapter.","title":"Middleware pipelines"},{"location":"v2/features/modular-applications/","text":"Modular applications Zend Framework 2+ applications have a concept of modules , independent units that can provide configuration, services, and hooks into its MVC lifecycle. This functionality is provided by zend-modulemanager. Expressive provides similar functionality by incorporating two packages within the default skeleton application: zendframework/zend-config-aggregator , which provides features for aggregating configuration from a variety of sources, including: PHP files globbed from the filesystem that return an array of configuration. zend-config -compatible configuration files globbed from the filesystem. Configuration provider classes; these are invokable classes which return an array of configuration. zendframework/zend-component-installer , a Composer plugin that looks for an extra.zf.config-provider entry in a package to install, and, if found, adds an entry for that provider to the config/config.php file (if it uses zend-config-aggregator). These features allow you to install packages via composer and expose their configuration \u2014 which may include dependency information \u2014 to your application. Making your application modular When using the Expressive installer via the skeleton application, the first question asked is the installation type, which includes the options: Minimal (no default middleware, templates, or assets; configuration only) Flat (flat source code structure; default selection) Modular (modular source code structure; recommended) We recommend choosing the \"Modular\" option from the outset. If you do not, you can still create and use modules in your application; however, the initial \"App\" module will not be modular. Module structure Expressive does not force you to use any particular structure for your module; its only requirement is to expose default configuration using a \"config provider\", which is simply an invokable class that returns a configuration array. We generally recommend that a module have a PSR-4 structure, and that the module contain a src/ directory at the minimum, along with directories for other module-specific content, such as templates, tests, and assets: src/ Acme/ src/ ConfigProvider.php Container/ VerifyUserFactory.php Helper/ AuthorizationHelper.php Middleware/ VerifyUser.php templates/ verify-user.php test/ Helper/ AuthorizationHelperTest.php Middleware/ VerifyUserTest.php If you use the above structure, you would then add an entry in your composer.json file to provide autoloading: \"autoload\": { \"psr-4\": { \"Acme\\\\\": \"src/Acme/src/\" } } Don't forget to execute composer dump-autoload after making the change! Creating and enabling a module The only requirement for creating a module is that you define a \"config provider\", which is simply an invokable class that returns a configuration array. Generally, a config provider will return dependency information, and module-specific configuration: namespace Acme; class ConfigProvider { public function __invoke() { return [ 'dependencies' => $this->getDependencies(), 'acme' => [ 'some-setting' => 'default value', ], 'templates' => [ 'paths' => [ 'acme' => [__DIR__ . '/../templates'], ], ] ]; } public function getDependencies() { return [ 'invokables' => [ Helper\\AuthorizationHelper::class => Helper\\AuthorizationHelper::class, ], 'factories' => [ Middleware\\VerifyUser::class => Container\\VerifyUserFactory::class, ], ]; } } You would then add the config provider to the top (or towards the top) of your config/config.php : $aggregator = new ConfigAggregator([ Acme\\ConfigProvider::class, /* ... */ This approach allows your config/autoload/* files to take precedence over the module configuration, allowing you to override the values. Caching configuration In order to provide configuration caching, two things must occur: First, you must define a config_cache_enabled key in your configuration somewhere. Second, you must pass a second argument to the ConfigManager , the location of the cache file to use. The config_cache_enabled key can be defined in any of your configuration providers, including the autoloaded configuration files. We recommend defining them in two locations: config/autoload/global.php should define the value to true , as the production setting. config/autoload/local.php should also define the setting, and use a value appropriate to the current environment. In development, for instance, this would be false . // config/autoload/global.php return [ 'config_cache_enabled' => true, /* ... */ ]; // config/autoload/local.php return [ 'config_cache_enabled' => false, // <- development! /* ... */ ]; You would then alter your config/config.php file to add the second argument. The following example builds on the previous, and demonstrates having the AppConfig entry enabled. The configuration will be cached to data/config-cache.php in the application root: $configManager = new ConfigManager([ App\\AppConfig::class, new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'), ], 'data/config-cache.php'); When the configuration cache path is present, if the config_cache_enabled flag is enabled, then configuration will be read from the cached configuration, instead of parsing and merging the various configuration sources. Final notes This approach may look simple, but it is flexible and powerful: You pass a list of config providers to the ConfigAggregator constructor. Configuration is merged in the same order as it is passed, with later entries having precedence. You can override module configuration using *.global.php and *.local.php files. If cached config is found, ConfigAggregator does not iterate over provider list. For more details, please refer to the zend-config-aggregator documentation .","title":"Modular Applications"},{"location":"v2/features/modular-applications/#modular-applications","text":"Zend Framework 2+ applications have a concept of modules , independent units that can provide configuration, services, and hooks into its MVC lifecycle. This functionality is provided by zend-modulemanager. Expressive provides similar functionality by incorporating two packages within the default skeleton application: zendframework/zend-config-aggregator , which provides features for aggregating configuration from a variety of sources, including: PHP files globbed from the filesystem that return an array of configuration. zend-config -compatible configuration files globbed from the filesystem. Configuration provider classes; these are invokable classes which return an array of configuration. zendframework/zend-component-installer , a Composer plugin that looks for an extra.zf.config-provider entry in a package to install, and, if found, adds an entry for that provider to the config/config.php file (if it uses zend-config-aggregator). These features allow you to install packages via composer and expose their configuration \u2014 which may include dependency information \u2014 to your application.","title":"Modular applications"},{"location":"v2/features/modular-applications/#making-your-application-modular","text":"When using the Expressive installer via the skeleton application, the first question asked is the installation type, which includes the options: Minimal (no default middleware, templates, or assets; configuration only) Flat (flat source code structure; default selection) Modular (modular source code structure; recommended) We recommend choosing the \"Modular\" option from the outset. If you do not, you can still create and use modules in your application; however, the initial \"App\" module will not be modular.","title":"Making your application modular"},{"location":"v2/features/modular-applications/#module-structure","text":"Expressive does not force you to use any particular structure for your module; its only requirement is to expose default configuration using a \"config provider\", which is simply an invokable class that returns a configuration array. We generally recommend that a module have a PSR-4 structure, and that the module contain a src/ directory at the minimum, along with directories for other module-specific content, such as templates, tests, and assets: src/ Acme/ src/ ConfigProvider.php Container/ VerifyUserFactory.php Helper/ AuthorizationHelper.php Middleware/ VerifyUser.php templates/ verify-user.php test/ Helper/ AuthorizationHelperTest.php Middleware/ VerifyUserTest.php If you use the above structure, you would then add an entry in your composer.json file to provide autoloading: \"autoload\": { \"psr-4\": { \"Acme\\\\\": \"src/Acme/src/\" } } Don't forget to execute composer dump-autoload after making the change!","title":"Module structure"},{"location":"v2/features/modular-applications/#creating-and-enabling-a-module","text":"The only requirement for creating a module is that you define a \"config provider\", which is simply an invokable class that returns a configuration array. Generally, a config provider will return dependency information, and module-specific configuration: namespace Acme; class ConfigProvider { public function __invoke() { return [ 'dependencies' => $this->getDependencies(), 'acme' => [ 'some-setting' => 'default value', ], 'templates' => [ 'paths' => [ 'acme' => [__DIR__ . '/../templates'], ], ] ]; } public function getDependencies() { return [ 'invokables' => [ Helper\\AuthorizationHelper::class => Helper\\AuthorizationHelper::class, ], 'factories' => [ Middleware\\VerifyUser::class => Container\\VerifyUserFactory::class, ], ]; } } You would then add the config provider to the top (or towards the top) of your config/config.php : $aggregator = new ConfigAggregator([ Acme\\ConfigProvider::class, /* ... */ This approach allows your config/autoload/* files to take precedence over the module configuration, allowing you to override the values.","title":"Creating and enabling a module"},{"location":"v2/features/modular-applications/#caching-configuration","text":"In order to provide configuration caching, two things must occur: First, you must define a config_cache_enabled key in your configuration somewhere. Second, you must pass a second argument to the ConfigManager , the location of the cache file to use. The config_cache_enabled key can be defined in any of your configuration providers, including the autoloaded configuration files. We recommend defining them in two locations: config/autoload/global.php should define the value to true , as the production setting. config/autoload/local.php should also define the setting, and use a value appropriate to the current environment. In development, for instance, this would be false . // config/autoload/global.php return [ 'config_cache_enabled' => true, /* ... */ ]; // config/autoload/local.php return [ 'config_cache_enabled' => false, // <- development! /* ... */ ]; You would then alter your config/config.php file to add the second argument. The following example builds on the previous, and demonstrates having the AppConfig entry enabled. The configuration will be cached to data/config-cache.php in the application root: $configManager = new ConfigManager([ App\\AppConfig::class, new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'), ], 'data/config-cache.php'); When the configuration cache path is present, if the config_cache_enabled flag is enabled, then configuration will be read from the cached configuration, instead of parsing and merging the various configuration sources.","title":"Caching configuration"},{"location":"v2/features/modular-applications/#final-notes","text":"This approach may look simple, but it is flexible and powerful: You pass a list of config providers to the ConfigAggregator constructor. Configuration is merged in the same order as it is passed, with later entries having precedence. You can override module configuration using *.global.php and *.local.php files. If cached config is found, ConfigAggregator does not iterate over provider list. For more details, please refer to the zend-config-aggregator documentation .","title":"Final notes"},{"location":"v2/features/container/aura-di/","text":"Using Aura.Di Aura.Di provides a serializable dependency injection container with the following features: constructor and setter injection. inheritance of constructor parameter and setter method values from parent classes. inheritance of setter method values from interfaces and traits. lazy-loaded instances, services, includes/requires, and values. instance factories. optional auto-resolution of typehinted constructor parameter values. Installing Aura.Di Aura.Di implements PSR-11 as of version 3. $ composer require aura/di Configuration Aura.Di can help you to organize your code better with ContainerConfig classes and two step configuration . In this example, we'll put that in config/container.php : <?php use Aura\\Di\\ContainerBuilder; $containerBuilder = new ContainerBuilder(); // Use the builder to create and configure a container using an array of // ContainerConfig classes. Make sure the classes can be autoloaded! return $containerBuilder->newConfiguredInstance([ 'Application\\Config\\Common', ]); The bare minimum ContainerConfig code needed to make zend-expressive work is: <?php // In src/Config/Common.php: namespace Application\\Config; use Aura\\Di\\Container; use Aura\\Di\\ContainerConfig; use Aura\\Router\\Generator; use Aura\\Router\\RouteCollection; use Aura\\Router\\RouteFactory; use Aura\\Router\\Router; use Zend\\Escaper\\Escaper; use Zend\\Expressive\\Application; use Zend\\Expressive\\Container as ExpressiveContainer; use Zend\\Expressive\\Delegate; use Zend\\Expressive\\Middleware; use Zend\\Expressive\\Plates\\PlatesRenderer; use Zend\\Expressive\\Router\\AuraRouter; use Zend\\Expressive\\Router\\Route; use Zend\\Expressive\\Router\\RouterInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class Common extends ContainerConfig { public function define(Container $di) { $di->params[RouteCollection::class] = array( 'route_factory' => $di->lazyNew(RouteFactory::class), ); $di->params[Router::class] = array( 'routes' => $di->lazyNew(RouteCollection::class), 'generator' => $di->lazyNew(Generator::class), ); $di->params[AuraRouter::class]['router'] = $di->lazyNew(Router::class); $di->set(RouterInterface::class, $di->lazyNew(AuraRouter::class)); $di->set(Container\\NotFoundDelegateFactory::class, $di->lazyNew(ExpressiveContainer\\NotFoundDelegateFactory::class)); $di->set(Delegate\\NotFoundDelegate::class, $di->lazyGetCall(ExpressiveContainer\\NotFoundDelegateFactory::class, '__invoke', $di)); $di->set('Zend\\Expressive\\Delegate\\DefaultDelegate', $di->lazyGetCall(ExpressiveContainer\\NotFoundDelegateFactory::class, '__invoke', $di)); $di->set(Container\\ApplicationFactory::class, $di->lazyNew(ExpressiveContainer\\ApplicationFactory::class)); $di->set(Application::class, $di->lazyGetCall(ExpressiveContainer\\ApplicationFactory::class, '__invoke', $di)); // Not Found handler $di->set(Middleware\\NotFoundHandler::class, $di->lazyGetCall(ExpressiveContainer\\NotFoundHandlerFactory::class, '__invoke', $di)); // Templating // In most cases, you can instantiate the template renderer you want to use // without using a factory: $di->set(TemplateRendererInterface::class, $di->lazyNew(PlatesRenderer::class)); // These next two can be added in any environment; they won't be used unless // you add the WhoopsErrorResponseGenerator as the ErrorResponseGenerator implementation: $di->set(ExpressiveContainer\\WhoopsFactory::class, $di->lazyNew(ExpressiveContainer\\WhoopsFactory::class)); $di->set('Zend\\Expressive\\Whoops', $di->lazyGetCall(ExpressiveContainer\\WhoopsFactory::class, '__invoke', $di)); $di->set(ExpressiveContainer\\WhoopsPageHandlerFactory::class, $di->lazyNew(ExpressiveContainer\\WhoopsPageHandlerFactory::class)); $di->set('Zend\\Expressive\\WhoopsPageHandler', $di->lazyGetCall(ExpressiveContainer\\WhoopsPageHandlerFactory::class, '__invoke', $di)); // Error Handling $di->set('Zend\\Stratigility\\Middleware\\ErrorHandler', $di->lazyGetCall(ExpressiveContainer\\ErrorHandlerFactory::class, '__invoke', $di)); // If in development: $di->set(ExpressiveContainer\\WhoopsErrorResponseGeneratorFactory::class, $di->lazyNew(ExpressiveContainer\\WhoopsErrorResponseGeneratorFactory::class)); $di->set(Middleware\\ErrorResponseGenerator::class, $di->lazyGetCall(ExpressiveContainer\\WhoopsErrorResponseGeneratorFactory::class, '__invoke', $di)); // If in production: // $di->set(Middleware\\ErrorResponseGenerator::class, $di->lazyGetCall(Container\\ErrorResponseGeneratorFactory::class, '__invoke', $di)); } public function modify(Container $di) { /* $router = $di->get(RouterInterface::class); $router->addRoute(new Route('/hello/{name}', function ($request, $response, $next) { $escaper = new Escaper(); $name = $request->getAttribute('name', 'World'); $response->getBody()->write('Hello ' . $escaper->escapeHtml($name)); return $response; }, Route::HTTP_METHOD_ANY, 'hello')); */ } } Your bootstrap (typically public/index.php ) will then look like this: chdir(dirname(__DIR__)); require 'vendor/autoload.php'; $container = require 'config/container.php'; $app = $container->get(Zend\\Expressive\\Application::class); require 'config/pipeline.php'; require 'config/routes.php'; $app->run();","title":"Using Aura.Di"},{"location":"v2/features/container/aura-di/#using-auradi","text":"Aura.Di provides a serializable dependency injection container with the following features: constructor and setter injection. inheritance of constructor parameter and setter method values from parent classes. inheritance of setter method values from interfaces and traits. lazy-loaded instances, services, includes/requires, and values. instance factories. optional auto-resolution of typehinted constructor parameter values.","title":"Using Aura.Di"},{"location":"v2/features/container/aura-di/#installing-auradi","text":"Aura.Di implements PSR-11 as of version 3. $ composer require aura/di","title":"Installing Aura.Di"},{"location":"v2/features/container/aura-di/#configuration","text":"Aura.Di can help you to organize your code better with ContainerConfig classes and two step configuration . In this example, we'll put that in config/container.php : <?php use Aura\\Di\\ContainerBuilder; $containerBuilder = new ContainerBuilder(); // Use the builder to create and configure a container using an array of // ContainerConfig classes. Make sure the classes can be autoloaded! return $containerBuilder->newConfiguredInstance([ 'Application\\Config\\Common', ]); The bare minimum ContainerConfig code needed to make zend-expressive work is: <?php // In src/Config/Common.php: namespace Application\\Config; use Aura\\Di\\Container; use Aura\\Di\\ContainerConfig; use Aura\\Router\\Generator; use Aura\\Router\\RouteCollection; use Aura\\Router\\RouteFactory; use Aura\\Router\\Router; use Zend\\Escaper\\Escaper; use Zend\\Expressive\\Application; use Zend\\Expressive\\Container as ExpressiveContainer; use Zend\\Expressive\\Delegate; use Zend\\Expressive\\Middleware; use Zend\\Expressive\\Plates\\PlatesRenderer; use Zend\\Expressive\\Router\\AuraRouter; use Zend\\Expressive\\Router\\Route; use Zend\\Expressive\\Router\\RouterInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class Common extends ContainerConfig { public function define(Container $di) { $di->params[RouteCollection::class] = array( 'route_factory' => $di->lazyNew(RouteFactory::class), ); $di->params[Router::class] = array( 'routes' => $di->lazyNew(RouteCollection::class), 'generator' => $di->lazyNew(Generator::class), ); $di->params[AuraRouter::class]['router'] = $di->lazyNew(Router::class); $di->set(RouterInterface::class, $di->lazyNew(AuraRouter::class)); $di->set(Container\\NotFoundDelegateFactory::class, $di->lazyNew(ExpressiveContainer\\NotFoundDelegateFactory::class)); $di->set(Delegate\\NotFoundDelegate::class, $di->lazyGetCall(ExpressiveContainer\\NotFoundDelegateFactory::class, '__invoke', $di)); $di->set('Zend\\Expressive\\Delegate\\DefaultDelegate', $di->lazyGetCall(ExpressiveContainer\\NotFoundDelegateFactory::class, '__invoke', $di)); $di->set(Container\\ApplicationFactory::class, $di->lazyNew(ExpressiveContainer\\ApplicationFactory::class)); $di->set(Application::class, $di->lazyGetCall(ExpressiveContainer\\ApplicationFactory::class, '__invoke', $di)); // Not Found handler $di->set(Middleware\\NotFoundHandler::class, $di->lazyGetCall(ExpressiveContainer\\NotFoundHandlerFactory::class, '__invoke', $di)); // Templating // In most cases, you can instantiate the template renderer you want to use // without using a factory: $di->set(TemplateRendererInterface::class, $di->lazyNew(PlatesRenderer::class)); // These next two can be added in any environment; they won't be used unless // you add the WhoopsErrorResponseGenerator as the ErrorResponseGenerator implementation: $di->set(ExpressiveContainer\\WhoopsFactory::class, $di->lazyNew(ExpressiveContainer\\WhoopsFactory::class)); $di->set('Zend\\Expressive\\Whoops', $di->lazyGetCall(ExpressiveContainer\\WhoopsFactory::class, '__invoke', $di)); $di->set(ExpressiveContainer\\WhoopsPageHandlerFactory::class, $di->lazyNew(ExpressiveContainer\\WhoopsPageHandlerFactory::class)); $di->set('Zend\\Expressive\\WhoopsPageHandler', $di->lazyGetCall(ExpressiveContainer\\WhoopsPageHandlerFactory::class, '__invoke', $di)); // Error Handling $di->set('Zend\\Stratigility\\Middleware\\ErrorHandler', $di->lazyGetCall(ExpressiveContainer\\ErrorHandlerFactory::class, '__invoke', $di)); // If in development: $di->set(ExpressiveContainer\\WhoopsErrorResponseGeneratorFactory::class, $di->lazyNew(ExpressiveContainer\\WhoopsErrorResponseGeneratorFactory::class)); $di->set(Middleware\\ErrorResponseGenerator::class, $di->lazyGetCall(ExpressiveContainer\\WhoopsErrorResponseGeneratorFactory::class, '__invoke', $di)); // If in production: // $di->set(Middleware\\ErrorResponseGenerator::class, $di->lazyGetCall(Container\\ErrorResponseGeneratorFactory::class, '__invoke', $di)); } public function modify(Container $di) { /* $router = $di->get(RouterInterface::class); $router->addRoute(new Route('/hello/{name}', function ($request, $response, $next) { $escaper = new Escaper(); $name = $request->getAttribute('name', 'World'); $response->getBody()->write('Hello ' . $escaper->escapeHtml($name)); return $response; }, Route::HTTP_METHOD_ANY, 'hello')); */ } } Your bootstrap (typically public/index.php ) will then look like this: chdir(dirname(__DIR__)); require 'vendor/autoload.php'; $container = require 'config/container.php'; $app = $container->get(Zend\\Expressive\\Application::class); require 'config/pipeline.php'; require 'config/routes.php'; $app->run();","title":"Configuration"},{"location":"v2/features/container/delegator-factories/","text":"Delegator Factories Expressive supports the concept of delegator factories , which allow decoration of services created by your dependency injection container, across all dependency injection containers supported by Expressive. Delegator factories accept the following arguments: The container itself; The name of the service whose creation is being decorated; A callback that will produce the service being decorated. As an example, let's say we have a UserRepository class that composes some sort of event manager. We might want to attach listeners to that event manager, but not wish to alter the basic creation logic for the repository itself. As such, we might write a delegator factory as follows: namespace Acme; use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; class UserRepositoryListenerDelegatorFactory { /** * @param ContainerInterface $container * @param string $name * @param callable $callback * @return UserRepository */ public function __invoke(ContainerInterface $container, $name, callable $callback) { $listener = new LoggerListener($container->get(LoggerInterface::class)); $repository = $callback(); $repository->getEventManager()->attach($listener); return $repository; } } To notify the container about this delegator factory, we would add the following configuration to our application: 'dependencies' => [ 'delegators' => [ Acme\\UserRepository::class => [ Acme\\UserRepositoryListenerDelegatorFactory::class, ], ], ], Note that you specify delegator factories using the service name being decorated as the key, with an array of delegator factories as a value. You may attach multiple delegator factories to any given service , which can be a very powerful feature. At the time of writing, this feature works for each of the Aura.Di, Pimple, and zend-servicemanager container implementations. Delegator factories have been supported with Pimple and zend-servicemanager since the 1.X series.","title":"Delegator Factories"},{"location":"v2/features/container/delegator-factories/#delegator-factories","text":"Expressive supports the concept of delegator factories , which allow decoration of services created by your dependency injection container, across all dependency injection containers supported by Expressive. Delegator factories accept the following arguments: The container itself; The name of the service whose creation is being decorated; A callback that will produce the service being decorated. As an example, let's say we have a UserRepository class that composes some sort of event manager. We might want to attach listeners to that event manager, but not wish to alter the basic creation logic for the repository itself. As such, we might write a delegator factory as follows: namespace Acme; use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; class UserRepositoryListenerDelegatorFactory { /** * @param ContainerInterface $container * @param string $name * @param callable $callback * @return UserRepository */ public function __invoke(ContainerInterface $container, $name, callable $callback) { $listener = new LoggerListener($container->get(LoggerInterface::class)); $repository = $callback(); $repository->getEventManager()->attach($listener); return $repository; } } To notify the container about this delegator factory, we would add the following configuration to our application: 'dependencies' => [ 'delegators' => [ Acme\\UserRepository::class => [ Acme\\UserRepositoryListenerDelegatorFactory::class, ], ], ], Note that you specify delegator factories using the service name being decorated as the key, with an array of delegator factories as a value. You may attach multiple delegator factories to any given service , which can be a very powerful feature. At the time of writing, this feature works for each of the Aura.Di, Pimple, and zend-servicemanager container implementations. Delegator factories have been supported with Pimple and zend-servicemanager since the 1.X series.","title":"Delegator Factories"},{"location":"v2/features/container/factories/","text":"Provided Factories Expressive provides several factories compatible with PSR-11 Container to facilitate setting up common dependencies. The following is a list of provided containers, what they will create, the suggested service name, and any additional dependencies they may require. All factories, unless noted otherwise, are in the Zend\\Expressive\\Container namespace, and define an __invoke() method that accepts an Psr\\Container\\ContainerInterface instance as the sole argument. ApplicationFactory Provides : Zend\\Expressive\\Application Suggested Name : Zend\\Expressive\\Application Requires : no additional services are required. Optional : Zend\\Expressive\\Router\\RouterInterface . When provided, the service will be used to construct the Application instance; otherwise, an FastRoute router implementation will be used. Zend\\Expressive\\Delegate\\DefaultDelegate . This should return an Interop\\Http\\ServerMiddleware\\DelegateInterface instance to process when the middleware pipeline is exhausted without returning a response; by default, this will be a Zend\\Expressive\\Delegate\\NotFoundDelegate instance. Zend\\Diactoros\\Response\\EmitterInterface . If none is provided, an instance of Zend\\Expressive\\Emitter\\EmitterStack composing a Zend\\Diactoros\\Response\\SapiEmitter instance will be used. config , an array or ArrayAccess instance. This may be used to seed the application instance with pipeline middleware and/or routed middleware (see more below). Additionally, the container instance itself is injected into the Application instance. When the config service is present, the factory can utilize several keys in order to seed the Application instance: programmatic_pipeline (bool) (Since 1.1.0): when enabled, middleware_pipeline and routes configuration are ignored, and the factory will assume that these are injected programmatically elsewhere. raise_throwables (bool) (Since 1.1.0; obsolete as of 2.0.0): when enabled, this flag will prevent the Stratigility middleware dispatcher from catching exceptions, and instead allow them to bubble outwards. middleware_pipeline can be used to seed the middleware pipeline: ```php 'middleware_pipeline' => [ // An array of middleware to register. [ / ... / ], // Expressive 1.0: Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, // Expressive 1.1 and above (above constants will still work, though): Zend\\Expressive\\Application::ROUTING_MIDDLEWARE, Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE, [ /* ... */ ], ], ``` Each item of the array, other than the entries for routing and dispatch middleware, must be an array itself, with the following structure: ```php [ // required: 'middleware' => 'Name of middleware service, valid middleware, or an array of these', // optional: 'path' => '/path/to/match', 'priority' => 1, // Integer // optional under Expressive 1.X; ignored under 2.X: 'error' => false, // boolean ], ``` The middleware key itself is the middleware to execute, and must be a service name resolving to valid middleware, middleware instances (either http-interop middleware or callable double-pass middleware), or an array of these values. If an array is provided, the specified middleware will be composed into a Zend\\Stratigility\\MiddlewarePipe instance. If the path key is present, that key will be used to segregate the middleware to a specific matched path (in other words, it will not execute if the path is not matched). The priority defaults to 1, and follows the semantics of SplPriorityQueue : higher integer values indicate higher priority (will execute earlier), while lower/negative integer values indicate lower priority (will execute last). Default priority is 1; use granular priority values to specify the order in which middleware should be piped to the application. You can specify keys for each middleware specification. These will be ignored by the factory, but can be useful when merging several configurations into one for the application. Under Expressive 1.X, if the error key is present and boolean true , then the middleware will be registered as error middleware. (This is necessary due to the fact that the factory defines a callable wrapper around middleware to enable lazy-loading of middleware.) We recommend not using this feature; see the chapter on error handling for details. routes is used to define routed middleware. The value must be an array, consisting of arrays defining each middleware: php 'routes' => [ [ 'path' => '/path/to/match', 'middleware' => 'Middleware service name, valid middleware, or array of these values', 'allowed_methods' => ['GET', 'POST', 'PATCH'], 'options' => [ 'stuff' => 'to', 'pass' => 'to', 'the' => 'underlying router', ], ], // etc. ], Each route requires : - `path`: the path to match. Format will be based on the router you choose for your project. - `middleware`: a service name resolving to valid middleware, valid middleware (either http-interop middleware or callable double-pass middleware), or an array of such values (which will be composed into a `Zend\\Stratigility\\MiddlewarePipe` instance); this middleware will be dispatched when the route matches. Optionally, the route definition may provide: - `allowed_methods`: an array of allowed HTTP methods. If not provided, the application assumes any method is allowed. - `name`: if not provided, the path will be used as the route name (and, if specific HTTP methods are allowed, a list of those). - `options`: a key/value set of additional options to pass to the underlying router implementation for the given route. (Typical use cases include passing constraints or default values.) ErrorHandlerFactory Provides : Zend\\Stratigility\\Middleware\\ErrorHandler Suggested Name : Zend\\Stratigility\\Middleware\\ErrorHandler Requires : no additional services are required. Optional : Zend\\Expressive\\Middleware\\ErrorResponseGenerator . If not provided, the error handler will not compose an error response generator, making it largely useless other than to provide an empty response. ErrorResponseGeneratorFactory Provides : Zend\\Expressive\\Middleware\\ErrorResponseGenerator Suggested Name : Zend\\Stratigility\\Middleware\\ErrorResponseGenerator Requires : no additional services are required. Optional : Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the error response generator will provide a plain text response instead of a templated one. config , an array or ArrayAccess instance. This will be used to seed the ErrorResponseGenerator instance with a template name to use for errors (see more below), and/or a \"debug\" flag value. When the config service is present, the factory can utilize two values: debug , a flag indicating whether or not to provide debug information when creating an error response. zend-expressive.error_handler.template_error , a name of an alternate template to use (instead of the default represented in the Zend\\Expressive\\Middleware\\ErrorResponseGenerator::TEMPLATE_DEFAULT constant). As an example: 'debug' => true, 'zend-expressive' => [ 'error_handler' => [ 'template_error' => 'name of error template', ], ], NotFoundDelegateFactory Provides : Zend\\Expressive\\Delegate\\NotFoundDelegate Suggested Name : Zend\\Expressive\\Delegate\\NotFoundDelegate , and aliased to Zend\\Expressive\\Delegate\\DefaultDelegate . Requires : no additional services are required. Optional : Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the delegate will provide a plain text response instead of a templated one. config , an array or ArrayAccess instance. This will be used to seed the NotFoundDelegate instance with a template name to use. When the config service is present, the factory can utilize two values: zend-expressive.error_handler.template_404 , a name of an alternate template to use (instead of the default represented in the Zend\\Expressive\\Delegate\\NotFoundDelegate::TEMPLATE_DEFAULT constant). As an example: 'zend-expressive' => [ 'error_handler' => [ 'template_404' => 'name of 404 template', ], ], NotFoundHandlerFactory Provides : Zend\\Expressive\\Middleware\\NotFoundHandler Suggested Name : Zend\\Expressive\\Middleware\\NotFoundHandler Requires : Zend\\Expressive\\Delegate\\DefaultDelegate WhoopsErrorResponseGeneratorFactory Provides : Zend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator Suggested Name : Zend\\Expressive\\Middleware\\ErrorResponseGenerator Requires : Zend\\Expressive\\Whoops (see WhoopsFactory , below) WhoopsFactory Provides : Whoops\\Run Suggested Name : Zend\\Expressive\\Whoops Requires : Zend\\Expressive\\WhoopsPageHandler Optional : config , an array or ArrayAccess instance. This will be used to seed additional page handlers, specifically the JsonResponseHandler (see more below). This factory creates and configures a Whoops\\Run instance so that it will work properly with Zend\\Expressive\\Application ; this includes disabling immediate write-to-output, disabling immediate quit, etc. The PrettyPageHandler returned for the Zend\\Expressive\\WhoopsPageHandler service will be injected. It consumes the following config structure: 'whoops' => [ 'json_exceptions' => [ 'display' => true, 'show_trace' => true, 'ajax_only' => true, ], ], If no whoops top-level key is present in the configuration, a default instance with no JsonResponseHandler composed will be created. WhoopsPageHandlerFactory Provides : Whoops\\Handler\\PrettyPageHandler Suggested Name : Zend\\Expressive\\WhoopsPageHandler Optional : config , an array or ArrayAccess instance. This will be used to further configure the PrettyPageHandler instance, specifically with editor configuration (for linking files such that they open in the configured editor). It consumes the following config structure: 'whoops' => [ 'editor' => 'editor name, editor service name, or callable', ], The editor value must be a known editor name (see the Whoops documentation for pre-configured editor types), a callable, or a service name to use. PlatesRendererFactory Provides : Zend\\Expressive\\Plates\\PlatesRenderer FactoryName : Zend\\Expressive\\Plates\\PlatesRendererFactory Suggested Name : Zend\\Expressive\\Template\\TemplateRendererInterface Requires : no additional services are required. Optional : config , an array or ArrayAccess instance. This will be used to further configure the Plates instance, specifically with the filename extension to use, and paths to inject. It consumes the following config structure: 'templates' => [ 'extension' => 'file extension used by templates; defaults to html', 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ] One note: Due to a limitation in the Plates engine, you can only map one path per namespace when using Plates. TwigRendererFactory Provides : Zend\\Expressive\\Twig\\TwigRenderer FactoryName : Zend\\Expressive\\Twig\\TwigRendererFactory Suggested Name : Zend\\Expressive\\Template\\TemplateRendererInterface Requires : no additional services are required. Optional : Zend\\Expressive\\Router\\RouterInterface ; if found, it will be used to seed a Zend\\Expressive\\Twig\\TwigExtension instance for purposes of rendering application URLs. config , an array or ArrayAccess instance. This will be used to further configure the Twig instance, specifically with the filename extension, paths to assets (and default asset version to use), and template paths to inject. It consumes the following config structure: 'debug' => boolean, 'templates' => [ 'cache_dir' => 'path to cached templates', 'assets_url' => 'base URL for assets', 'assets_version' => 'base version for assets', 'extension' => 'file extension used by templates; defaults to html.twig', 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ] When debug is true, it disables caching, enables debug mode, enables strict variables, and enables auto reloading. The assets_* values are used to seed the TwigExtension instance (assuming the router was found). ZendViewRendererFactory Provides : Zend\\Expressive\\ZendView\\ZendViewRenderer FactoryName : Zend\\Expressive\\ZendView\\ZendViewRendererFactory Suggested Name : Zend\\Expressive\\Template\\TemplateRendererInterface Requires : no additional services are required. Zend\\Expressive\\Router\\RouterInterface , in order to inject the custom url helper implementation. Optional : config , an array or ArrayAccess instance. This will be used to further configure the ZendView instance, specifically with the layout template name, entries for a TemplateMapResolver , and and template paths to inject. Zend\\View\\HelperPluginManager ; if present, will be used to inject the PhpRenderer instance. It consumes the following config structure: 'templates' => [ 'layout' => 'name of layout view to use, if any', 'map' => [ // template => filename pairs ], 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ] When creating the PhpRenderer instance, it will inject it with a Zend\\View\\HelperPluginManager instance (either pulled from the container, or instantiated directly). It injects the helper plugin manager with custom url and serverurl helpers, Zend\\Expressive\\ZendView\\UrlHelper and Zend\\Expressive\\ZendView\\ServerUrlHelper , respetively.","title":"Container Factories"},{"location":"v2/features/container/factories/#provided-factories","text":"Expressive provides several factories compatible with PSR-11 Container to facilitate setting up common dependencies. The following is a list of provided containers, what they will create, the suggested service name, and any additional dependencies they may require. All factories, unless noted otherwise, are in the Zend\\Expressive\\Container namespace, and define an __invoke() method that accepts an Psr\\Container\\ContainerInterface instance as the sole argument.","title":"Provided Factories"},{"location":"v2/features/container/factories/#applicationfactory","text":"Provides : Zend\\Expressive\\Application Suggested Name : Zend\\Expressive\\Application Requires : no additional services are required. Optional : Zend\\Expressive\\Router\\RouterInterface . When provided, the service will be used to construct the Application instance; otherwise, an FastRoute router implementation will be used. Zend\\Expressive\\Delegate\\DefaultDelegate . This should return an Interop\\Http\\ServerMiddleware\\DelegateInterface instance to process when the middleware pipeline is exhausted without returning a response; by default, this will be a Zend\\Expressive\\Delegate\\NotFoundDelegate instance. Zend\\Diactoros\\Response\\EmitterInterface . If none is provided, an instance of Zend\\Expressive\\Emitter\\EmitterStack composing a Zend\\Diactoros\\Response\\SapiEmitter instance will be used. config , an array or ArrayAccess instance. This may be used to seed the application instance with pipeline middleware and/or routed middleware (see more below). Additionally, the container instance itself is injected into the Application instance. When the config service is present, the factory can utilize several keys in order to seed the Application instance: programmatic_pipeline (bool) (Since 1.1.0): when enabled, middleware_pipeline and routes configuration are ignored, and the factory will assume that these are injected programmatically elsewhere. raise_throwables (bool) (Since 1.1.0; obsolete as of 2.0.0): when enabled, this flag will prevent the Stratigility middleware dispatcher from catching exceptions, and instead allow them to bubble outwards. middleware_pipeline can be used to seed the middleware pipeline: ```php 'middleware_pipeline' => [ // An array of middleware to register. [ / ... / ], // Expressive 1.0: Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, // Expressive 1.1 and above (above constants will still work, though): Zend\\Expressive\\Application::ROUTING_MIDDLEWARE, Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE, [ /* ... */ ], ], ``` Each item of the array, other than the entries for routing and dispatch middleware, must be an array itself, with the following structure: ```php [ // required: 'middleware' => 'Name of middleware service, valid middleware, or an array of these', // optional: 'path' => '/path/to/match', 'priority' => 1, // Integer // optional under Expressive 1.X; ignored under 2.X: 'error' => false, // boolean ], ``` The middleware key itself is the middleware to execute, and must be a service name resolving to valid middleware, middleware instances (either http-interop middleware or callable double-pass middleware), or an array of these values. If an array is provided, the specified middleware will be composed into a Zend\\Stratigility\\MiddlewarePipe instance. If the path key is present, that key will be used to segregate the middleware to a specific matched path (in other words, it will not execute if the path is not matched). The priority defaults to 1, and follows the semantics of SplPriorityQueue : higher integer values indicate higher priority (will execute earlier), while lower/negative integer values indicate lower priority (will execute last). Default priority is 1; use granular priority values to specify the order in which middleware should be piped to the application. You can specify keys for each middleware specification. These will be ignored by the factory, but can be useful when merging several configurations into one for the application. Under Expressive 1.X, if the error key is present and boolean true , then the middleware will be registered as error middleware. (This is necessary due to the fact that the factory defines a callable wrapper around middleware to enable lazy-loading of middleware.) We recommend not using this feature; see the chapter on error handling for details. routes is used to define routed middleware. The value must be an array, consisting of arrays defining each middleware: php 'routes' => [ [ 'path' => '/path/to/match', 'middleware' => 'Middleware service name, valid middleware, or array of these values', 'allowed_methods' => ['GET', 'POST', 'PATCH'], 'options' => [ 'stuff' => 'to', 'pass' => 'to', 'the' => 'underlying router', ], ], // etc. ], Each route requires : - `path`: the path to match. Format will be based on the router you choose for your project. - `middleware`: a service name resolving to valid middleware, valid middleware (either http-interop middleware or callable double-pass middleware), or an array of such values (which will be composed into a `Zend\\Stratigility\\MiddlewarePipe` instance); this middleware will be dispatched when the route matches. Optionally, the route definition may provide: - `allowed_methods`: an array of allowed HTTP methods. If not provided, the application assumes any method is allowed. - `name`: if not provided, the path will be used as the route name (and, if specific HTTP methods are allowed, a list of those). - `options`: a key/value set of additional options to pass to the underlying router implementation for the given route. (Typical use cases include passing constraints or default values.)","title":"ApplicationFactory"},{"location":"v2/features/container/factories/#errorhandlerfactory","text":"Provides : Zend\\Stratigility\\Middleware\\ErrorHandler Suggested Name : Zend\\Stratigility\\Middleware\\ErrorHandler Requires : no additional services are required. Optional : Zend\\Expressive\\Middleware\\ErrorResponseGenerator . If not provided, the error handler will not compose an error response generator, making it largely useless other than to provide an empty response.","title":"ErrorHandlerFactory"},{"location":"v2/features/container/factories/#errorresponsegeneratorfactory","text":"Provides : Zend\\Expressive\\Middleware\\ErrorResponseGenerator Suggested Name : Zend\\Stratigility\\Middleware\\ErrorResponseGenerator Requires : no additional services are required. Optional : Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the error response generator will provide a plain text response instead of a templated one. config , an array or ArrayAccess instance. This will be used to seed the ErrorResponseGenerator instance with a template name to use for errors (see more below), and/or a \"debug\" flag value. When the config service is present, the factory can utilize two values: debug , a flag indicating whether or not to provide debug information when creating an error response. zend-expressive.error_handler.template_error , a name of an alternate template to use (instead of the default represented in the Zend\\Expressive\\Middleware\\ErrorResponseGenerator::TEMPLATE_DEFAULT constant). As an example: 'debug' => true, 'zend-expressive' => [ 'error_handler' => [ 'template_error' => 'name of error template', ], ],","title":"ErrorResponseGeneratorFactory"},{"location":"v2/features/container/factories/#notfounddelegatefactory","text":"Provides : Zend\\Expressive\\Delegate\\NotFoundDelegate Suggested Name : Zend\\Expressive\\Delegate\\NotFoundDelegate , and aliased to Zend\\Expressive\\Delegate\\DefaultDelegate . Requires : no additional services are required. Optional : Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the delegate will provide a plain text response instead of a templated one. config , an array or ArrayAccess instance. This will be used to seed the NotFoundDelegate instance with a template name to use. When the config service is present, the factory can utilize two values: zend-expressive.error_handler.template_404 , a name of an alternate template to use (instead of the default represented in the Zend\\Expressive\\Delegate\\NotFoundDelegate::TEMPLATE_DEFAULT constant). As an example: 'zend-expressive' => [ 'error_handler' => [ 'template_404' => 'name of 404 template', ], ],","title":"NotFoundDelegateFactory"},{"location":"v2/features/container/factories/#notfoundhandlerfactory","text":"Provides : Zend\\Expressive\\Middleware\\NotFoundHandler Suggested Name : Zend\\Expressive\\Middleware\\NotFoundHandler Requires : Zend\\Expressive\\Delegate\\DefaultDelegate","title":"NotFoundHandlerFactory"},{"location":"v2/features/container/factories/#whoopserrorresponsegeneratorfactory","text":"Provides : Zend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator Suggested Name : Zend\\Expressive\\Middleware\\ErrorResponseGenerator Requires : Zend\\Expressive\\Whoops (see WhoopsFactory , below)","title":"WhoopsErrorResponseGeneratorFactory"},{"location":"v2/features/container/factories/#whoopsfactory","text":"Provides : Whoops\\Run Suggested Name : Zend\\Expressive\\Whoops Requires : Zend\\Expressive\\WhoopsPageHandler Optional : config , an array or ArrayAccess instance. This will be used to seed additional page handlers, specifically the JsonResponseHandler (see more below). This factory creates and configures a Whoops\\Run instance so that it will work properly with Zend\\Expressive\\Application ; this includes disabling immediate write-to-output, disabling immediate quit, etc. The PrettyPageHandler returned for the Zend\\Expressive\\WhoopsPageHandler service will be injected. It consumes the following config structure: 'whoops' => [ 'json_exceptions' => [ 'display' => true, 'show_trace' => true, 'ajax_only' => true, ], ], If no whoops top-level key is present in the configuration, a default instance with no JsonResponseHandler composed will be created.","title":"WhoopsFactory"},{"location":"v2/features/container/factories/#whoopspagehandlerfactory","text":"Provides : Whoops\\Handler\\PrettyPageHandler Suggested Name : Zend\\Expressive\\WhoopsPageHandler Optional : config , an array or ArrayAccess instance. This will be used to further configure the PrettyPageHandler instance, specifically with editor configuration (for linking files such that they open in the configured editor). It consumes the following config structure: 'whoops' => [ 'editor' => 'editor name, editor service name, or callable', ], The editor value must be a known editor name (see the Whoops documentation for pre-configured editor types), a callable, or a service name to use.","title":"WhoopsPageHandlerFactory"},{"location":"v2/features/container/factories/#platesrendererfactory","text":"Provides : Zend\\Expressive\\Plates\\PlatesRenderer FactoryName : Zend\\Expressive\\Plates\\PlatesRendererFactory Suggested Name : Zend\\Expressive\\Template\\TemplateRendererInterface Requires : no additional services are required. Optional : config , an array or ArrayAccess instance. This will be used to further configure the Plates instance, specifically with the filename extension to use, and paths to inject. It consumes the following config structure: 'templates' => [ 'extension' => 'file extension used by templates; defaults to html', 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ] One note: Due to a limitation in the Plates engine, you can only map one path per namespace when using Plates.","title":"PlatesRendererFactory"},{"location":"v2/features/container/factories/#twigrendererfactory","text":"Provides : Zend\\Expressive\\Twig\\TwigRenderer FactoryName : Zend\\Expressive\\Twig\\TwigRendererFactory Suggested Name : Zend\\Expressive\\Template\\TemplateRendererInterface Requires : no additional services are required. Optional : Zend\\Expressive\\Router\\RouterInterface ; if found, it will be used to seed a Zend\\Expressive\\Twig\\TwigExtension instance for purposes of rendering application URLs. config , an array or ArrayAccess instance. This will be used to further configure the Twig instance, specifically with the filename extension, paths to assets (and default asset version to use), and template paths to inject. It consumes the following config structure: 'debug' => boolean, 'templates' => [ 'cache_dir' => 'path to cached templates', 'assets_url' => 'base URL for assets', 'assets_version' => 'base version for assets', 'extension' => 'file extension used by templates; defaults to html.twig', 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ] When debug is true, it disables caching, enables debug mode, enables strict variables, and enables auto reloading. The assets_* values are used to seed the TwigExtension instance (assuming the router was found).","title":"TwigRendererFactory"},{"location":"v2/features/container/factories/#zendviewrendererfactory","text":"Provides : Zend\\Expressive\\ZendView\\ZendViewRenderer FactoryName : Zend\\Expressive\\ZendView\\ZendViewRendererFactory Suggested Name : Zend\\Expressive\\Template\\TemplateRendererInterface Requires : no additional services are required. Zend\\Expressive\\Router\\RouterInterface , in order to inject the custom url helper implementation. Optional : config , an array or ArrayAccess instance. This will be used to further configure the ZendView instance, specifically with the layout template name, entries for a TemplateMapResolver , and and template paths to inject. Zend\\View\\HelperPluginManager ; if present, will be used to inject the PhpRenderer instance. It consumes the following config structure: 'templates' => [ 'layout' => 'name of layout view to use, if any', 'map' => [ // template => filename pairs ], 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ] When creating the PhpRenderer instance, it will inject it with a Zend\\View\\HelperPluginManager instance (either pulled from the container, or instantiated directly). It injects the helper plugin manager with custom url and serverurl helpers, Zend\\Expressive\\ZendView\\UrlHelper and Zend\\Expressive\\ZendView\\ServerUrlHelper , respetively.","title":"ZendViewRendererFactory"},{"location":"v2/features/container/intro/","text":"Containers Expressive promotes and advocates the usage of Dependency Injection / Inversion of Control (also referred to as DI \u2014 or DIC \u2014 and IoC, respectively) containers when writing your applications. These should be used for the following: Defining application dependencies: routers, template engines, error handlers, even the Application instance itself. Defining middleware and related dependencies. The Application instance itself stores a container, from which it fetches middleware when ready to dispatch it; this encourages the idea of defining middleware-specific dependencies, and factories for ensuring they are injected. To facilitate this and allow you as a developer to choose the container you prefer, zend-expressive typehints against PSR-11 Container , and throughout this manual, we attempt to show using a variety of containers in examples. At this time, we document support for the following specific containers: zend-servicemanager pimple-interop aura.di Service Names We recommend using fully-qualified class names whenever possible as service names, with one exception: in cases where a service provides an implementation of an interface used for typehints, use the interface name. Following these practices encourages the following: Consumers have a reasonable idea of what the service should return. Using interface names as service names promotes re-use and substitution. In a few cases, we define \"virtual service\" names. These are cases where there is no clear typehint to follow (e.g., most middleware only uses callable as a typehint, or where we want to imply specific configuration is necessary (e.g., Whoops requires specific configuration to work correctly with Expressive, and thus we do not want a generic service name for it). We try to keep these to a minimum, however.","title":"Introduction"},{"location":"v2/features/container/intro/#containers","text":"Expressive promotes and advocates the usage of Dependency Injection / Inversion of Control (also referred to as DI \u2014 or DIC \u2014 and IoC, respectively) containers when writing your applications. These should be used for the following: Defining application dependencies: routers, template engines, error handlers, even the Application instance itself. Defining middleware and related dependencies. The Application instance itself stores a container, from which it fetches middleware when ready to dispatch it; this encourages the idea of defining middleware-specific dependencies, and factories for ensuring they are injected. To facilitate this and allow you as a developer to choose the container you prefer, zend-expressive typehints against PSR-11 Container , and throughout this manual, we attempt to show using a variety of containers in examples. At this time, we document support for the following specific containers: zend-servicemanager pimple-interop aura.di","title":"Containers"},{"location":"v2/features/container/pimple/","text":"Using Pimple Pimple is a widely used code-driven dependency injection container provided as a standalone component by SensioLabs. It features: combined parameter and service storage. ability to define factories for specific classes. lazy-loading via factories. Pimple only supports programmatic creation at this time. Installing Pimple Pimple does not currently (as of v3) implement PSR-11 Container ; as such, you need to install the xtreamwayz/pimple-container-interop project, which provides a PSR-11 container wrapper around Pimple v3: $ composer require xtreamwayz/pimple-container-interop Configuring Pimple To configure Pimple, instantiate it, and then add the factories desired. We recommend doing this in a dedicated script that returns the Pimple instance; in this example, we'll have that in config/container.php . use Xtreamwayz\\Pimple\\Container as Pimple; use Zend\\Expressive\\Container; use Zend\\Expressive\\Plates\\PlatesRenderer; use Zend\\Expressive\\Router; use Zend\\Expressive\\Template\\TemplateRendererInterface; $container = new Pimple(); // Application and configuration $container['config'] = include 'config/config.php'; $container['Zend\\Expressive\\Application'] = new Container\\ApplicationFactory; // Routing // In most cases, you can instantiate the router you want to use without using a // factory: $container['Zend\\Expressive\\Router\\RouterInterface'] = function ($container) { return new Router\\Aura(); }; // We'll provide a default delegate: $delegateFactory = new Container\\NotFoundDelegateFactory(); $container['Zend\\Expressive\\Delegate\\DefaultDelegate'] = $delegateFactory; $container[Zend\\Expressive\\Delegate\\NotFoundDelegate::class] = $delegateFactory; // We'll provide a not found handler: $container[Zend\\Expressive\\Middleware\\NotFoundHandler::class] = new Container\\NotFoundHandlerFactory(); // Templating // In most cases, you can instantiate the template renderer you want to use // without using a factory: $container[TemplateRendererInterface::class] = function ($container) { return new PlatesRenderer(); }; // These next two can be added in any environment; they won't be used unless // you add the WhoopsErrorResponseGenerator as the ErrorResponseGenerator // implementation $container['Zend\\Expressive\\Whoops'] = new Container\\WhoopsFactory(); $container['Zend\\Expressive\\WhoopsPageHandler'] = new Container\\WhoopsPageHandlerFactory(); // Error Handling // - In all environments: $container['Zend\\Expressive\\Middleware\\ErrorHandler'] = new Container\\ErrorHandlerFactory(); // If in development: $container[Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class] = new Container\\WhoopsErrorResponseGeneratorFactory(); // If in production: $container[Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class] = new Container\\ErrorResponseGeneratorFactory(); return $container; Your bootstrap (typically public/index.php ) will then look like this: chdir(dirname(__DIR__)); $container = require 'config/container.php'; $app = $container->get(Zend\\Expressive\\Application::class); require 'config/pipeline.php'; require 'config/routes.php'; // All versions: $app->run(); Environments In the example above, we provide two alternate definitions for the service Zend\\Expressive\\Middleware\\ErrorResponseGenerator , one for development and one for production. You will need to add logic to your file to determine which definition to provide; this could be accomplished via an environment variable.","title":"Using Pimple"},{"location":"v2/features/container/pimple/#using-pimple","text":"Pimple is a widely used code-driven dependency injection container provided as a standalone component by SensioLabs. It features: combined parameter and service storage. ability to define factories for specific classes. lazy-loading via factories. Pimple only supports programmatic creation at this time.","title":"Using Pimple"},{"location":"v2/features/container/pimple/#installing-pimple","text":"Pimple does not currently (as of v3) implement PSR-11 Container ; as such, you need to install the xtreamwayz/pimple-container-interop project, which provides a PSR-11 container wrapper around Pimple v3: $ composer require xtreamwayz/pimple-container-interop","title":"Installing Pimple"},{"location":"v2/features/container/pimple/#configuring-pimple","text":"To configure Pimple, instantiate it, and then add the factories desired. We recommend doing this in a dedicated script that returns the Pimple instance; in this example, we'll have that in config/container.php . use Xtreamwayz\\Pimple\\Container as Pimple; use Zend\\Expressive\\Container; use Zend\\Expressive\\Plates\\PlatesRenderer; use Zend\\Expressive\\Router; use Zend\\Expressive\\Template\\TemplateRendererInterface; $container = new Pimple(); // Application and configuration $container['config'] = include 'config/config.php'; $container['Zend\\Expressive\\Application'] = new Container\\ApplicationFactory; // Routing // In most cases, you can instantiate the router you want to use without using a // factory: $container['Zend\\Expressive\\Router\\RouterInterface'] = function ($container) { return new Router\\Aura(); }; // We'll provide a default delegate: $delegateFactory = new Container\\NotFoundDelegateFactory(); $container['Zend\\Expressive\\Delegate\\DefaultDelegate'] = $delegateFactory; $container[Zend\\Expressive\\Delegate\\NotFoundDelegate::class] = $delegateFactory; // We'll provide a not found handler: $container[Zend\\Expressive\\Middleware\\NotFoundHandler::class] = new Container\\NotFoundHandlerFactory(); // Templating // In most cases, you can instantiate the template renderer you want to use // without using a factory: $container[TemplateRendererInterface::class] = function ($container) { return new PlatesRenderer(); }; // These next two can be added in any environment; they won't be used unless // you add the WhoopsErrorResponseGenerator as the ErrorResponseGenerator // implementation $container['Zend\\Expressive\\Whoops'] = new Container\\WhoopsFactory(); $container['Zend\\Expressive\\WhoopsPageHandler'] = new Container\\WhoopsPageHandlerFactory(); // Error Handling // - In all environments: $container['Zend\\Expressive\\Middleware\\ErrorHandler'] = new Container\\ErrorHandlerFactory(); // If in development: $container[Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class] = new Container\\WhoopsErrorResponseGeneratorFactory(); // If in production: $container[Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class] = new Container\\ErrorResponseGeneratorFactory(); return $container; Your bootstrap (typically public/index.php ) will then look like this: chdir(dirname(__DIR__)); $container = require 'config/container.php'; $app = $container->get(Zend\\Expressive\\Application::class); require 'config/pipeline.php'; require 'config/routes.php'; // All versions: $app->run();","title":"Configuring Pimple"},{"location":"v2/features/container/zend-servicemanager/","text":"Using zend-servicemanager zend-servicemanager is a code-driven dependency injection container provided as a standalone component by Zend Framework. It features: lazy-loading of invokable (constructor-less) classes. ability to define factories for specific classes. ability to define generalized factories for classes with identical construction patterns (aka abstract factories ). ability to create lazy-loading proxies. ability to intercept before or after instantiation to alter the construction workflow (aka delegator factories ). interface injection (via initializers ). zend-servicemanager may either be created and populated programmatically, or via configuration. Configuration uses the following structure: [ 'services' => [ 'service name' => $serviceInstance, ], 'invokables' => [ 'service name' => 'class to instantiate', ], 'factories' => [ 'service name' => 'callable, Zend\\ServiceManager\\FactoryInterface instance, or name of factory class returning the service', ], 'abstract_factories' => [ 'class name of Zend\\ServiceManager\\AbstractFactoryInterface implementation', ], 'delegators' => [ 'service name' => [ 'class name of Zend\\ServiceManager\\DelegatorFactoryInterface implementation', ], ], 'lazy_services' => [ 'class_map' => [ 'service name' => 'Class\\Name\\Of\\Service', ], ], 'initializers' => [ 'callable, Zend\\ServiceManager\\InitializerInterface implementation, or name of initializer class', ], ] Read more about zend-servicemanager in its documentation . Installing zend-servicemanager To use zend-servicemanager with zend-expressive, you can install it via composer: $ composer require zendframework/zend-servicemanager Configuring zend-servicemanager You can configure zend-servicemanager either programmatically or via configuration. We'll show you both methods. Programmatically To use zend-servicemanager programatically, you'll need to create a Zend\\ServiceManager\\ServiceManager instance, and then start populating it. For this example, we'll assume your application configuration (used by several factories to configure instances) is in config/config.php , and that that file returns an array. We'll create a config/container.php file that creates and returns a Zend\\ServiceManager\\ServiceManager instance as follows: use Zend\\ServiceManager\\ServiceManager; $container = new ServiceManager(); // Application and configuration $container->setService('config', include 'config/config.php'); $container->setFactory( Zend\\Expressive\\Application::class, Zend\\Expressive\\Container\\ApplicationFactory::class ); // Routing // In most cases, you can instantiate the router you want to use without using a // factory: $container->setInvokableClass( Zend\\Expressive\\Router\\RouterInterface::class, Zend\\Expressive\\Router\\AuraRouter::class ); // Templating // In most cases, you can instantiate the template renderer you want to use // without using a factory: $container->setInvokableClass( Zend\\Expressive\\Template\\TemplateRendererInterface::class, Zend\\Expressive\\Plates\\PlatesRenderer::class ); // These next two can be added in any environment; they won't be used unless // you add the WhoopsErrorResponseGenerator as the ErrorResponseGenerator // implementation: $container->setFactory( 'Zend\\Expressive\\Whoops', Zend\\Expressive\\Container\\WhoopsFactory::class ); $container->setFactory( 'Zend\\Expressive\\WhoopsPageHandler', Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class ); // Error Handling // All environments: $container->setFactory( Zend\\Expressive\\Middleware\\ErrorHandler::class, Zend\\Expressive\\Container\\ErrorHandlerFactory::class ); // If in development: $container->setFactory( Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class, Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class ); // If in production: $container->setFactory( Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class, Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class ); return $container; Your bootstrap (typically public/index.php ) will then look like this: chdir(dirname(__DIR__)); require 'vendor/autoload.php'; $container = require 'config/container.php'; $app = $container->get(\\Zend\\Expressive\\Application::class); require 'config/pipeline.php'; require 'config/routes.php'; // All versions: $app->run(); Configuration-Driven Container Alternately, you can use a configuration file to define the container. As before, we'll define our configuration in config/config.php , and our config/container.php file will still return our service manager instance; we'll define the service configuration in config/dependencies.php : return [ 'services' => [ 'config' => include __DIR__ . '/config.php', ], 'aliases' => [ 'Zend\\Expressive\\Delegate\\DefaultDelegate' => 'Zend\\Expressive\\Delegate\\NotFoundDelegate', ], 'invokables' => [ Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\AuraRouter::class, Zend\\Expressive\\Template\\TemplateRendererInterface::class => 'Zend\\Expressive\\Plates\\PlatesRenderer::class ], 'factories' => [ Zend\\Expressive\\Application::class => Zend\\Expressive\\Container\\ApplicationFactory::class, 'Zend\\Expressive\\Whoops' => Zend\\Expressive\\Container\\WhoopsFactory::class, 'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class, Zend\\Stratigility\\Middleware\\ErrorHandler::class => Zend\\Expressive\\Container\\ErrorHandlerFactory::class, Zend\\Expressive\\Delegate\\NotFoundDelegate::class => Zend\\Expressive\\Container\\NotFoundDelegateFactory::class, Zend\\Expressive\\Middleware\\NotFoundHandler::class => Zend\\Expressive\\Container\\NotFoundHandlerFactory::class, ], ]; config/container.php becomes: use Zend\\ServiceManager\\Config; use Zend\\ServiceManager\\ServiceManager; return new ServiceManager(new Config(include 'config/dependencies.php')); There is one problem, however: you may want to vary error handling strategies based on whether or not you're in production: You have two choices on how to approach this: Selectively inject the factory in the bootstrap. Define the final handler service in an environment specific file and use file globbing to merge files. In the first case, you would change the config/container.php example to look like this: use Zend\\ServiceManager\\Config; use Zend\\ServiceManager\\ServiceManager; $container = new ServiceManager(new Config(include 'config/container.php')); switch ($variableOrConstantIndicatingEnvironment) { case 'development': $container->setFactory( Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class, Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class ); break; case 'production': default: $container->setFactory( Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class, Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class ); } return $container; In the second case, you will need to install zend-config: $ composer require zendframework/zend-config Then, create the directory config/autoload/ , and create two files, dependencies.global.php and dependencies.local.php . In your .gitignore , add an entry for config/autoload/*local.php to ensure \"local\" (environment-specific) files are excluded from the repository. config/dependencies.php will look like this: use Zend\\Config\\Factory as ConfigFactory; return ConfigFactory::fromFiles( glob('config/autoload/dependencies.{global,local}.php', GLOB_BRACE) ); config/autoload/dependencies.global.php will look like this: return [ 'services' => [ 'config' => include __DIR__ . '/config.php', ], 'aliases' => [ 'Zend\\Expressive\\Delegate\\DefaultDelegate' => Zend\\Expressive\\Delegate\\NotFoundDelegate::class, ], 'invokables' => [ Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\AuraRouter::class, Zend\\Expressive\\Template\\TemplateRendererInterface::class => 'Zend\\Expressive\\Plates\\PlatesRenderer::class ], 'factories' => [ Zend\\Expressive\\Application::class => Zend\\Expressive\\Container\\ApplicationFactory::class, 'Zend\\Expressive\\Whoops' => Zend\\Expressive\\Container\\WhoopsFactory::class, 'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class, Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class => Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class, Zend\\Stratigility\\Middleware\\ErrorHandler::class => Zend\\Expressive\\Container\\ErrorHandlerFactory::class, 'Zend\\Expressive\\Delegate\\NotFoundDelegate' => Zend\\Expressive\\Container\\NotFoundDelegateFactory::class, Zend\\Expressive\\Middleware\\NotFoundHandler::class => Zend\\Expressive\\Container\\NotFoundHandlerFactory::class, ], ]; config/autoload/dependencies.local.php on your development machine can look like this: return [ 'factories' => [ 'Zend\\Expressive\\Whoops' => Zend\\Expressive\\Container\\WhoopsFactory::class, 'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class, Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class => 'Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class, ], ]; Using the above approach allows you to keep the bootstrap file minimal and agnostic of environment. (Note: you can take a similar approach with the application configuration.)","title":"Using zend-servicemanager"},{"location":"v2/features/container/zend-servicemanager/#using-zend-servicemanager","text":"zend-servicemanager is a code-driven dependency injection container provided as a standalone component by Zend Framework. It features: lazy-loading of invokable (constructor-less) classes. ability to define factories for specific classes. ability to define generalized factories for classes with identical construction patterns (aka abstract factories ). ability to create lazy-loading proxies. ability to intercept before or after instantiation to alter the construction workflow (aka delegator factories ). interface injection (via initializers ). zend-servicemanager may either be created and populated programmatically, or via configuration. Configuration uses the following structure: [ 'services' => [ 'service name' => $serviceInstance, ], 'invokables' => [ 'service name' => 'class to instantiate', ], 'factories' => [ 'service name' => 'callable, Zend\\ServiceManager\\FactoryInterface instance, or name of factory class returning the service', ], 'abstract_factories' => [ 'class name of Zend\\ServiceManager\\AbstractFactoryInterface implementation', ], 'delegators' => [ 'service name' => [ 'class name of Zend\\ServiceManager\\DelegatorFactoryInterface implementation', ], ], 'lazy_services' => [ 'class_map' => [ 'service name' => 'Class\\Name\\Of\\Service', ], ], 'initializers' => [ 'callable, Zend\\ServiceManager\\InitializerInterface implementation, or name of initializer class', ], ] Read more about zend-servicemanager in its documentation .","title":"Using zend-servicemanager"},{"location":"v2/features/container/zend-servicemanager/#installing-zend-servicemanager","text":"To use zend-servicemanager with zend-expressive, you can install it via composer: $ composer require zendframework/zend-servicemanager","title":"Installing zend-servicemanager"},{"location":"v2/features/container/zend-servicemanager/#configuring-zend-servicemanager","text":"You can configure zend-servicemanager either programmatically or via configuration. We'll show you both methods.","title":"Configuring zend-servicemanager"},{"location":"v2/features/helpers/body-parse/","text":"Body Parsing Middleware Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware provides generic PSR-7 middleware for parsing the request body into parameters, and returning a new request instance that composes them. The subcomponent provides a strategy pattern around matching the request Content-Type , and then parsing it, giving you a flexible approach that can grow with your accepted content types. By default, this middleware will detect the following content types: application/x-www-form-urlencoded (standard web-based forms, without file uploads) application/json , application/*+json (JSON payloads) Registering the middleware You can register it programmatically: $app->pipe(BodyParamsMiddleware::class); Alternately, register it via configuration, if using configuration-based applications: // config/autoload/middleware-pipeline.global.php use Zend\\Expressive\\Helper; return [ 'dependencies' => [ 'invokables' => [ Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class, /* ... */ ], 'factories' => [ /* ... */ ], ], 'middleware_pipeline' => [ ['middleware' => Helper\\BodyParams\\BodyParamsMiddleware::class, 'priority' => 100], /* ... */ 'routing' => [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Helper\\UrlHelperMiddleware::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], /* ... */ ], ]; Since body parsing does not necessarily need to happen for every request, you can also choose to incorporate it in route-specific middleware pipelines: $app->post('/login', [ BodyParamsMiddleware::class, LoginMiddleware::class, ]); If using a configuration-based application: // config/autoload/routes.global.php use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware; return [ 'dependencies' => [ 'invokables' => [ Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class, /* ... */ ], 'factories' => [ /* ... */ ], ], 'routes' => [ [ 'name' => 'contact:process', 'path' => '/contact/process', 'middleware' => [ BodyParamsMiddleware::class, Contact\\Process::class, ], 'allowed_methods' => ['POST'], ] ], ]; Using route-based middleware pipelines has the advantage of ensuring that the body parsing middleware only executes for routes that require the processing. While the middleware has some checks to ensure it only triggers for HTTP methods that accept bodies, those checks are still overhead that you might want to avoid; the above strategy of using the middleware only with specific routes can accomplish that. Strategies If you want to intercept and parse other payload types, you can add strategies to the middleware. Strategies implement Zend\\Expressive\\Helper\\BodyParams\\StrategyInterface : namespace Zend\\Expressive\\Helper\\BodyParams; use Psr\\Http\\Message\\ServerRequestInterface; interface StrategyInterface { /** * Match the content type to the strategy criteria. * * @param string $contentType * @return bool Whether or not the strategy matches. */ public function match($contentType); /** * Parse the body content and return a new response. * * @param ServerRequestInterface $request * @return ServerRequestInterface */ public function parse(ServerRequestInterface $request); } You then register them with the middleware using the addStrategy() method: $bodyParams->addStrategy(new MyCustomBodyParamsStrategy()); To automate the registration, we recommend writing a factory for the BodyParamsMiddleware , and replacing the invokables registration with a registration in the factories section of the middleware-pipeline.config.php file: use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware; class MyCustomBodyParamsStrategyFactory { public function __invoke($container) { $bodyParams = new BodyParamsMiddleware(); $bodyParams->addStrategy(new MyCustomBodyParamsStrategy()); return $bodyParams; } } // In config/autoload/middleware-pipeline.config.php: use Zend\\Expressive\\Helper; return [ 'dependencies' => [ 'invokables' => [ // Remove this line: Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class, /* ... */ ], 'factories' => [ // Add this line: Helper\\BodyParams\\BodyParamsMiddleware::class => MyCustomBodyParamsStrategyFactory::class, /* ... */ ], ], ]; Removing the default strategies By default, BodyParamsMiddleware composes the following strategies: Zend\\Expressive\\Helper\\BodyParams\\FormUrlEncodedStrategy Zend\\Expressive\\Helper\\BodyParams\\JsonStrategy These provide the most basic approaches to parsing the request body. They operate in the order they do to ensure the most common content type \u2014 application/x-www-form-urlencoded \u2014 matches first, as the middleware delegates parsing to the first match. If you do not want to use these default strategies, you can clear them from the middleware using clearStrategies() : $bodyParamsMiddleware->clearStrategies(); Note: if you do this, all strategies will be removed! As such, we recommend doing this only immediately before registering any custom strategies you might be using.","title":"Body Parsing Middleware"},{"location":"v2/features/helpers/body-parse/#body-parsing-middleware","text":"Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware provides generic PSR-7 middleware for parsing the request body into parameters, and returning a new request instance that composes them. The subcomponent provides a strategy pattern around matching the request Content-Type , and then parsing it, giving you a flexible approach that can grow with your accepted content types. By default, this middleware will detect the following content types: application/x-www-form-urlencoded (standard web-based forms, without file uploads) application/json , application/*+json (JSON payloads)","title":"Body Parsing Middleware"},{"location":"v2/features/helpers/body-parse/#registering-the-middleware","text":"You can register it programmatically: $app->pipe(BodyParamsMiddleware::class); Alternately, register it via configuration, if using configuration-based applications: // config/autoload/middleware-pipeline.global.php use Zend\\Expressive\\Helper; return [ 'dependencies' => [ 'invokables' => [ Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class, /* ... */ ], 'factories' => [ /* ... */ ], ], 'middleware_pipeline' => [ ['middleware' => Helper\\BodyParams\\BodyParamsMiddleware::class, 'priority' => 100], /* ... */ 'routing' => [ 'middleware' => [ Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE, Helper\\UrlHelperMiddleware::class, Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], /* ... */ ], ]; Since body parsing does not necessarily need to happen for every request, you can also choose to incorporate it in route-specific middleware pipelines: $app->post('/login', [ BodyParamsMiddleware::class, LoginMiddleware::class, ]); If using a configuration-based application: // config/autoload/routes.global.php use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware; return [ 'dependencies' => [ 'invokables' => [ Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class, /* ... */ ], 'factories' => [ /* ... */ ], ], 'routes' => [ [ 'name' => 'contact:process', 'path' => '/contact/process', 'middleware' => [ BodyParamsMiddleware::class, Contact\\Process::class, ], 'allowed_methods' => ['POST'], ] ], ]; Using route-based middleware pipelines has the advantage of ensuring that the body parsing middleware only executes for routes that require the processing. While the middleware has some checks to ensure it only triggers for HTTP methods that accept bodies, those checks are still overhead that you might want to avoid; the above strategy of using the middleware only with specific routes can accomplish that.","title":"Registering the middleware"},{"location":"v2/features/helpers/body-parse/#strategies","text":"If you want to intercept and parse other payload types, you can add strategies to the middleware. Strategies implement Zend\\Expressive\\Helper\\BodyParams\\StrategyInterface : namespace Zend\\Expressive\\Helper\\BodyParams; use Psr\\Http\\Message\\ServerRequestInterface; interface StrategyInterface { /** * Match the content type to the strategy criteria. * * @param string $contentType * @return bool Whether or not the strategy matches. */ public function match($contentType); /** * Parse the body content and return a new response. * * @param ServerRequestInterface $request * @return ServerRequestInterface */ public function parse(ServerRequestInterface $request); } You then register them with the middleware using the addStrategy() method: $bodyParams->addStrategy(new MyCustomBodyParamsStrategy()); To automate the registration, we recommend writing a factory for the BodyParamsMiddleware , and replacing the invokables registration with a registration in the factories section of the middleware-pipeline.config.php file: use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware; class MyCustomBodyParamsStrategyFactory { public function __invoke($container) { $bodyParams = new BodyParamsMiddleware(); $bodyParams->addStrategy(new MyCustomBodyParamsStrategy()); return $bodyParams; } } // In config/autoload/middleware-pipeline.config.php: use Zend\\Expressive\\Helper; return [ 'dependencies' => [ 'invokables' => [ // Remove this line: Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class, /* ... */ ], 'factories' => [ // Add this line: Helper\\BodyParams\\BodyParamsMiddleware::class => MyCustomBodyParamsStrategyFactory::class, /* ... */ ], ], ];","title":"Strategies"},{"location":"v2/features/helpers/body-parse/#removing-the-default-strategies","text":"By default, BodyParamsMiddleware composes the following strategies: Zend\\Expressive\\Helper\\BodyParams\\FormUrlEncodedStrategy Zend\\Expressive\\Helper\\BodyParams\\JsonStrategy These provide the most basic approaches to parsing the request body. They operate in the order they do to ensure the most common content type \u2014 application/x-www-form-urlencoded \u2014 matches first, as the middleware delegates parsing to the first match. If you do not want to use these default strategies, you can clear them from the middleware using clearStrategies() : $bodyParamsMiddleware->clearStrategies(); Note: if you do this, all strategies will be removed! As such, we recommend doing this only immediately before registering any custom strategies you might be using.","title":"Removing the default strategies"},{"location":"v2/features/helpers/content-length/","text":"Content-Length Middleware Available since zend-expressive-helpers version 4.1.0. In some cases, you may want to include an explicit Content-Length response header, without having to inject it manually. To facilitate this, we provide Zend\\Expressive\\Helper\\ContentLengthMiddleware . When to use this middleware In most cases, you do not need to provide an explicit Content-Length value in your responses. While the HTTP/1.1 specification indicates the header SHOULD be provided, most clients will not degrade to HTTP/1.0 if the header is omitted. The one exception that has been reported is when working with New Relic , which requires valid Content-Length headers for some of its analytics; in such cases, enabling this middleware will fix those situations. This middleware delegates the request, and operates on the returned response. It will return a new response with the Content-Length header injected under the following conditions: No Content-Length header is already present AND the body size is non-null. To register it in your application, you will need to do two things: register the middleware with the container, and register the middleware in either your application pipeline, or within routed middleware. To add it to your container, add the following configuration: // In a `config/autoload/*.global.php` file, or a `ConfigProvider` class: use Zend\\Expressive\\Helper; return [ 'dependencies' => [ 'invokables' => [ Helper\\ContentLengthMiddleware::class => Helper\\ContentLengthMiddleware::class, ], ], ]; To register it as pipeline middleware to execute on any request: // In `config/pipeline.php`: use Zend\\Expressive\\Helper; $app->pipe(Helper\\ContentLengthMiddleware::class); To register it within a routed middleware pipeline: // In `config/routes.php`: use Zend\\Expressive\\Helper; $app->get('/download/tarball', [ Helper\\ContentLengthMiddleware::class, Download\\Tarball::class, ], 'download-tar'); Caveats One caveat to note is that if you use this middleware, but also write directly to the output buffer (e.g., via a var_dump , or if display_errors is on and an uncaught error or exception occurs), the output will not appear as you expect. Generally in such situations, the contents of the output buffer will appear, up to the specified Content-Length value. This can lead to truncated error content and/or truncated application content. We recommend that if you use this feature, you also use a PHP error and/or exception handler that logs errors in order to prevent truncated output.","title":"Content-Length Middleware"},{"location":"v2/features/helpers/content-length/#content-length-middleware","text":"Available since zend-expressive-helpers version 4.1.0. In some cases, you may want to include an explicit Content-Length response header, without having to inject it manually. To facilitate this, we provide Zend\\Expressive\\Helper\\ContentLengthMiddleware .","title":"Content-Length Middleware"},{"location":"v2/features/helpers/content-length/#caveats","text":"One caveat to note is that if you use this middleware, but also write directly to the output buffer (e.g., via a var_dump , or if display_errors is on and an uncaught error or exception occurs), the output will not appear as you expect. Generally in such situations, the contents of the output buffer will appear, up to the specified Content-Length value. This can lead to truncated error content and/or truncated application content. We recommend that if you use this feature, you also use a PHP error and/or exception handler that logs errors in order to prevent truncated output.","title":"Caveats"},{"location":"v2/features/helpers/intro/","text":"Helpers Some tasks and features will be common to many if not all applications. For those, Expressive provides helpers . These are typically utility classes that may integrate features or simply provide standalone benefits. Currently, these include: Body Parsing Middleware Content-Length Middleware (since zend-expressive-helpers 4.1.0) UrlHelper ServerUrlHelper Installation If you started your project using the Expressive skeleton package, the helpers are already installed. If not, you can install them as follows: $ composer require zendframework/zend-expressive-helpers","title":"Introduction"},{"location":"v2/features/helpers/intro/#helpers","text":"Some tasks and features will be common to many if not all applications. For those, Expressive provides helpers . These are typically utility classes that may integrate features or simply provide standalone benefits. Currently, these include: Body Parsing Middleware Content-Length Middleware (since zend-expressive-helpers 4.1.0) UrlHelper ServerUrlHelper","title":"Helpers"},{"location":"v2/features/helpers/intro/#installation","text":"If you started your project using the Expressive skeleton package, the helpers are already installed. If not, you can install them as follows: $ composer require zendframework/zend-expressive-helpers","title":"Installation"},{"location":"v2/features/helpers/server-url-helper/","text":"ServerUrlHelper Zend\\Expressive\\Helper\\ServerUrlHelper provides the ability to generate a full URI by passing only the path to the helper; it will then use that path with the current Psr\\Http\\Message\\UriInterface instance provided to it in order to generate a fully qualified URI. Usage When you have an instance, use either its generate() method, or call the instance as an invokable: // Using the generate() method: $url = $helper->generate('/foo'); // is equivalent to invocation: $url = $helper('/foo'); The helper is particularly useful when used in conjunction with the UrlHelper , as you can then create fully qualified URIs for use with headers, API hypermedia links, etc.: $url = $serverUrl($url('resource', ['id' => 'sha1'])); The signature for the ServerUrlHelper generate() and __invoke() methods is: function ($path = null) : string Where: $path , when provided, can be a string path to use to generate a URI. Creating an instance In order to use the helper, you will need to inject it with the current UriInterface from the request instance. To automate this, we provide Zend\\Expressive\\Helper\\ServerUrlMiddleware , which composes a ServerUrl instance, and, when invoked, injects it with the URI instance. As such, you will need to: Register the ServerUrlHelper as a service in your container. Register the ServerUrlMiddleware as a service in your container. Register the ServerUrlMiddleware as pipeline middleware, anytime before the routing middleware. The following examples demonstrate registering the services. use Zend\\Expressive\\Helper\\ServerUrlHelper; use Zend\\Expressive\\Helper\\ServerUrlMiddleware; use Zend\\Expressive\\Helper\\ServerUrlMiddlewareFactory; // zend-servicemanager: $services->setInvokableClass(ServerUrlHelper::class, ServerUrlHelper::class); $services->setFactory(ServerUrlMiddleware::class, ServerUrlMiddlewareFactory::class); // Pimple: $pimple[ServerUrlHelper::class] = function ($container) { return new ServerUrlHelper(); }; $pimple[ServerUrlMiddleware::class] = function ($container) { $factory = new ServerUrlMiddlewareFactory(); return $factory($container); }; // Aura.Di: $container->set(ServerUrlHelper::class, $container->lazyNew(ServerUrlHelper::class)); $container->set(ServerUrlMiddlewareFactory::class, $container->lazyNew(ServerUrlMiddlewareFactory::class)); $container->set( ServerUrlMiddleware::class, $container->lazyGetCall(ServerUrlMiddlewareFactory::class, '__invoke', $container) ); To register the ServerUrlMiddleware as pipeline middleware anytime before the routing middleware: use Zend\\Expressive\\Helper\\ServerUrlMiddleware; // Programmatically: $app->pipe(ServerUrlMiddleware::class); $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); // Or use configuration: // [ // 'middleware_pipeline' => [ // ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX], // /* ... */ // ], // ] The following dependency configuration will work for all three when using the Expressive skeleton: return [ 'dependencies' => [ 'invokables' => [ ServerUrlHelper::class => ServerUrlHelper::class, ], 'factories' => [ ServerUrlMiddleware::class => ServerUrlMiddlewareFactory::class, ], ], 'middleware_pipeline' => [ ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX], /* ... */ ], ]; Skeleton configures helpers If you started your project using the Expressive skeleton package, the ServerUrlHelper and ServerUrlMiddleware factories are already registered for you, as is the ServerUrlMiddleware pipeline middleware. Using the helper in middleware Compose the helper in your middleware (or elsewhere), and then use it to generate URI paths: use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Expressive\\Helper\\ServerUrlHelper; class FooMiddleware implements MiddlewareInterface { private $helper; public function __construct(ServerUrlHelper $helper) { $this->helper = $helper; } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { $response = $delegate->process($request); return $response->withHeader( 'Link', $this->helper->generate() . '; rel=\"self\"' ); } }","title":"ServerUrlHelper"},{"location":"v2/features/helpers/server-url-helper/#serverurlhelper","text":"Zend\\Expressive\\Helper\\ServerUrlHelper provides the ability to generate a full URI by passing only the path to the helper; it will then use that path with the current Psr\\Http\\Message\\UriInterface instance provided to it in order to generate a fully qualified URI.","title":"ServerUrlHelper"},{"location":"v2/features/helpers/server-url-helper/#usage","text":"When you have an instance, use either its generate() method, or call the instance as an invokable: // Using the generate() method: $url = $helper->generate('/foo'); // is equivalent to invocation: $url = $helper('/foo'); The helper is particularly useful when used in conjunction with the UrlHelper , as you can then create fully qualified URIs for use with headers, API hypermedia links, etc.: $url = $serverUrl($url('resource', ['id' => 'sha1'])); The signature for the ServerUrlHelper generate() and __invoke() methods is: function ($path = null) : string Where: $path , when provided, can be a string path to use to generate a URI.","title":"Usage"},{"location":"v2/features/helpers/server-url-helper/#creating-an-instance","text":"In order to use the helper, you will need to inject it with the current UriInterface from the request instance. To automate this, we provide Zend\\Expressive\\Helper\\ServerUrlMiddleware , which composes a ServerUrl instance, and, when invoked, injects it with the URI instance. As such, you will need to: Register the ServerUrlHelper as a service in your container. Register the ServerUrlMiddleware as a service in your container. Register the ServerUrlMiddleware as pipeline middleware, anytime before the routing middleware. The following examples demonstrate registering the services. use Zend\\Expressive\\Helper\\ServerUrlHelper; use Zend\\Expressive\\Helper\\ServerUrlMiddleware; use Zend\\Expressive\\Helper\\ServerUrlMiddlewareFactory; // zend-servicemanager: $services->setInvokableClass(ServerUrlHelper::class, ServerUrlHelper::class); $services->setFactory(ServerUrlMiddleware::class, ServerUrlMiddlewareFactory::class); // Pimple: $pimple[ServerUrlHelper::class] = function ($container) { return new ServerUrlHelper(); }; $pimple[ServerUrlMiddleware::class] = function ($container) { $factory = new ServerUrlMiddlewareFactory(); return $factory($container); }; // Aura.Di: $container->set(ServerUrlHelper::class, $container->lazyNew(ServerUrlHelper::class)); $container->set(ServerUrlMiddlewareFactory::class, $container->lazyNew(ServerUrlMiddlewareFactory::class)); $container->set( ServerUrlMiddleware::class, $container->lazyGetCall(ServerUrlMiddlewareFactory::class, '__invoke', $container) ); To register the ServerUrlMiddleware as pipeline middleware anytime before the routing middleware: use Zend\\Expressive\\Helper\\ServerUrlMiddleware; // Programmatically: $app->pipe(ServerUrlMiddleware::class); $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); // Or use configuration: // [ // 'middleware_pipeline' => [ // ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX], // /* ... */ // ], // ] The following dependency configuration will work for all three when using the Expressive skeleton: return [ 'dependencies' => [ 'invokables' => [ ServerUrlHelper::class => ServerUrlHelper::class, ], 'factories' => [ ServerUrlMiddleware::class => ServerUrlMiddlewareFactory::class, ], ], 'middleware_pipeline' => [ ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX], /* ... */ ], ];","title":"Creating an instance"},{"location":"v2/features/helpers/server-url-helper/#using-the-helper-in-middleware","text":"Compose the helper in your middleware (or elsewhere), and then use it to generate URI paths: use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Expressive\\Helper\\ServerUrlHelper; class FooMiddleware implements MiddlewareInterface { private $helper; public function __construct(ServerUrlHelper $helper) { $this->helper = $helper; } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { $response = $delegate->process($request); return $response->withHeader( 'Link', $this->helper->generate() . '; rel=\"self\"' ); } }","title":"Using the helper in middleware"},{"location":"v2/features/helpers/url-helper/","text":"UrlHelper Zend\\Expressive\\Helper\\UrlHelper provides the ability to generate a URI path based on a given route defined in the Zend\\Expressive\\Router\\RouterInterface . If injected with a route result, and the route being used was also the one matched during routing, you can provide a subset of routing parameters, and any not provided will be pulled from those matched. Usage When you have an instance, use either its generate() method, or call the instance as an invokable: // Using the generate() method: $url = $helper->generate('resource', ['id' => 'sha1']); // is equivalent to invocation: $url = $helper('resource', ['id' => 'sha1']); The signature for both is: function ( $routeName, array $routeParams = [], $queryParams = [], $fragmentIdentifier = null, array $options = [] ) : string Where: $routeName is the name of a route defined in the composed router. You may omit this argument if you want to generate the path for the currently matched request. $routeParams is an array of substitutions to use for the provided route, with the following behavior: If a RouteResult is composed in the helper, and the $routeName matches it, the provided $params will be merged with any matched parameters, with those provided taking precedence. If a RouteResult is not composed, or if the composed result does not match the provided $routeName , then only the $params provided will be used for substitutions. If no $params are provided, and the $routeName matches the currently matched route, then any matched parameters found will be used. parameters found will be used. If no $params are provided, and the $routeName does not match the currently matched route, or if no route result is present, then no substitutions will be made. $queryParams is an array of query string arguments to include in the generated URI. $fragmentIdentifier is a string to use as the URI fragment. $options is an array of options to provide to the router for purposes of controlling URI generation. As an example, zend-router can consume \"translator\" and \"text_domain\" options in order to provide translated URIs. Each method will raise an exception if: No $routeName is provided, and no RouteResult is composed. No $routeName is provided, a RouteResult is composed, but that result represents a matching failure. The given $routeName is not defined in the router. Signature changes The signature listed above is current as of version 3.0.0 of zendframework/zend-expressive-helpers. Prior to that version, the helper only accepted the route name and route parameters. Creating an instance In order to use the helper, you will need to instantiate it with the current RouterInterface . The factory Zend\\Expressive\\Helper\\UrlHelperFactory has been provided for this purpose, and can be used trivially with most dependency injection containers implementing PSR-11 Container . Additionally, it is most useful when injected with the current results of routing, which requires registering middleware with the application that can inject the route result. The following steps should be followed to register and configure the helper: Register the UrlHelper as a service in your container, using the provided factory. Register the UrlHelperMiddleware as a service in your container, using the provided factory. Register the UrlHelperMiddleware as pipeline middleware, immediately following the routing middleware. Registering the helper service The following examples demonstrate programmatic registration of the UrlHelper service in your selected dependency injection container. use Zend\\Expressive\\Helper\\UrlHelper; use Zend\\Expressive\\Helper\\UrlHelperFactory; // zend-servicemanager: $services->setFactory(UrlHelper::class, UrlHelperFactory::class); // Pimple: $pimple[UrlHelper::class] = function ($container) { $factory = new UrlHelperFactory(); return $factory($container); }; // Aura.Di: $container->set(UrlHelperFactory::class, $container->lazyNew(UrlHelperFactory::class)); $container->set( UrlHelper::class, $container->lazyGetCall(UrlHelperFactory::class, '__invoke', $container) ); The following dependency configuration will work for all three when using the Expressive skeleton: return ['dependencies' => [ 'factories' => [ UrlHelper::class => UrlHelperFactory::class, ], ]] UrlHelperFactory requires RouterInterface The factory requires that a service named Zend\\Expressive\\Router\\RouterInterface is present, and will raise an exception if the service is not found. Registering the pipeline middleware To register the UrlHelperMiddleware as pipeline middleware following the routing middleware: use Zend\\Expressive\\Helper\\UrlHelperMiddleware; // Programmatically: $app->pipeRoutingMiddleware(); $app->pipe(UrlHelperMiddleware::class); $app->pipeDispatchMiddleware(); // Or use configuration: // [ // 'middleware_pipeline' => [ // /* ... */ // Zend\\Expressive\\Application::ROUTING_MIDDLEWARE, // ['middleware' => UrlHelperMiddleware::class], // Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE, // /* ... */ // ], // ] // // Alternately, create a nested middleware pipeline for the routing, UrlHelper, // and dispatch middleware: // [ // 'middleware_pipeline' => [ // /* ... */ // 'routing' => [ // 'middleware' => [ // Zend\\Expressive\\Application::ROUTING_MIDDLEWARE, // UrlHelperMiddleware::class // Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE, // ], // 'priority' => 1, // ], // /* ... */ // ], // ] The following dependency configuration will work for all three when using the Expressive skeleton: return [ 'dependencies' => [ 'factories' => [ UrlHelper::class => UrlHelperFactory::class, UrlHelperMiddleware::class => UrlHelperMiddlewareFactory::class, ], ], 'middleware_pipeline' => [ Zend\\Expressive\\Application::ROUTING_MIDDLEWARE, ['middleware' => UrlHelperMiddleware::class], Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE, ], ]; // OR: return [ 'dependencies' => [ 'factories' => [ UrlHelper::class => UrlHelperFactory::class, UrlHelperMiddleware::class => UrlHelperMiddlewareFactory::class, ], ], 'middleware_pipeline' => [ 'routing' => [ 'middleware' => [ Zend\\Expressive\\Application::ROUTING_MIDDLEWARE, UrlHelperMiddleware::class, Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], ], ]; Skeleton configures helpers If you started your project using the Expressive skeleton package, the UrlHelper and UrlHelperMiddleware factories are already registered for you, as is the UrlHelperMiddleware pipeline middleware. Using the helper in middleware Compose the helper in your middleware (or elsewhere), and then use it to generate URI paths: use Zend\\Expressive\\Helper\\UrlHelper; class FooMiddleware { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } public function __invoke($request, $response, callable $next) { $response = $response->withHeader( 'Link', $this->helper->generate('resource', ['id' => 'sha1']) ); return $next($request, $response); } } Base Path support If your application is running under a subdirectory, or if you are running pipeline middleware that is intercepting on a subpath, the paths generated by the router may not reflect the base path , and thus be invalid. To accommodate this, the UrlHelper supports injection of the base path; when present, it will be prepended to the path generated by the router. As an example, perhaps you have middleware running to intercept a language prefix in the URL; this middleware could then inject the UrlHelper with the detected language, before stripping it off the request URI instance to pass on to the router: use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Locale; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Expressive\\Helper\\UrlHelper; class LocaleMiddleware implements MiddlewareInterface { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { $uri = $request->getUri(); $path = $uri->getPath(); if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) { return $delegate->process($request); } $locale = $matches['locale']; Locale::setDefault(Locale::canonicalize($locale)); $this->helper->setBasePath($locale); return $delegate->process($request->withUri( $uri->withPath(substr($path, (strlen($locale) + 1))) )); } } (Note: if the base path injected is not prefixed with / , the helper will add the slash.) Paths generated by the UriHelper from this point forward will have the detected language prefix.","title":"UrlHelper"},{"location":"v2/features/helpers/url-helper/#urlhelper","text":"Zend\\Expressive\\Helper\\UrlHelper provides the ability to generate a URI path based on a given route defined in the Zend\\Expressive\\Router\\RouterInterface . If injected with a route result, and the route being used was also the one matched during routing, you can provide a subset of routing parameters, and any not provided will be pulled from those matched.","title":"UrlHelper"},{"location":"v2/features/helpers/url-helper/#usage","text":"When you have an instance, use either its generate() method, or call the instance as an invokable: // Using the generate() method: $url = $helper->generate('resource', ['id' => 'sha1']); // is equivalent to invocation: $url = $helper('resource', ['id' => 'sha1']); The signature for both is: function ( $routeName, array $routeParams = [], $queryParams = [], $fragmentIdentifier = null, array $options = [] ) : string Where: $routeName is the name of a route defined in the composed router. You may omit this argument if you want to generate the path for the currently matched request. $routeParams is an array of substitutions to use for the provided route, with the following behavior: If a RouteResult is composed in the helper, and the $routeName matches it, the provided $params will be merged with any matched parameters, with those provided taking precedence. If a RouteResult is not composed, or if the composed result does not match the provided $routeName , then only the $params provided will be used for substitutions. If no $params are provided, and the $routeName matches the currently matched route, then any matched parameters found will be used. parameters found will be used. If no $params are provided, and the $routeName does not match the currently matched route, or if no route result is present, then no substitutions will be made. $queryParams is an array of query string arguments to include in the generated URI. $fragmentIdentifier is a string to use as the URI fragment. $options is an array of options to provide to the router for purposes of controlling URI generation. As an example, zend-router can consume \"translator\" and \"text_domain\" options in order to provide translated URIs. Each method will raise an exception if: No $routeName is provided, and no RouteResult is composed. No $routeName is provided, a RouteResult is composed, but that result represents a matching failure. The given $routeName is not defined in the router.","title":"Usage"},{"location":"v2/features/helpers/url-helper/#creating-an-instance","text":"In order to use the helper, you will need to instantiate it with the current RouterInterface . The factory Zend\\Expressive\\Helper\\UrlHelperFactory has been provided for this purpose, and can be used trivially with most dependency injection containers implementing PSR-11 Container . Additionally, it is most useful when injected with the current results of routing, which requires registering middleware with the application that can inject the route result. The following steps should be followed to register and configure the helper: Register the UrlHelper as a service in your container, using the provided factory. Register the UrlHelperMiddleware as a service in your container, using the provided factory. Register the UrlHelperMiddleware as pipeline middleware, immediately following the routing middleware.","title":"Creating an instance"},{"location":"v2/features/helpers/url-helper/#using-the-helper-in-middleware","text":"Compose the helper in your middleware (or elsewhere), and then use it to generate URI paths: use Zend\\Expressive\\Helper\\UrlHelper; class FooMiddleware { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } public function __invoke($request, $response, callable $next) { $response = $response->withHeader( 'Link', $this->helper->generate('resource', ['id' => 'sha1']) ); return $next($request, $response); } }","title":"Using the helper in middleware"},{"location":"v2/features/helpers/url-helper/#base-path-support","text":"If your application is running under a subdirectory, or if you are running pipeline middleware that is intercepting on a subpath, the paths generated by the router may not reflect the base path , and thus be invalid. To accommodate this, the UrlHelper supports injection of the base path; when present, it will be prepended to the path generated by the router. As an example, perhaps you have middleware running to intercept a language prefix in the URL; this middleware could then inject the UrlHelper with the detected language, before stripping it off the request URI instance to pass on to the router: use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Locale; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Expressive\\Helper\\UrlHelper; class LocaleMiddleware implements MiddlewareInterface { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { $uri = $request->getUri(); $path = $uri->getPath(); if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) { return $delegate->process($request); } $locale = $matches['locale']; Locale::setDefault(Locale::canonicalize($locale)); $this->helper->setBasePath($locale); return $delegate->process($request->withUri( $uri->withPath(substr($path, (strlen($locale) + 1))) )); } } (Note: if the base path injected is not prefixed with / , the helper will add the slash.) Paths generated by the UriHelper from this point forward will have the detected language prefix.","title":"Base Path support"},{"location":"v2/features/middleware/implicit-methods-middleware/","text":"ImplicitHeadMiddleware and ImplicitOptionsMiddleware Expressive offers middleware for implicitly supporting HEAD and OPTIONS requests. The HTTP/1.1 specifications indicate that all server implementations must support HEAD requests for any given URI, and that they should support OPTIONS requests. To make this possible, we have added features to our routing layer, and middleware that can detect implicit support for these methods (i.e., the route was not registered explicitly with the method). Versions prior to 2.2 If you are using Expressive versions earlier than 2.2, you may define a Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware or Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware service under the invokables service configuration. However, starting in version 2.2, these classes are deprecated in favor of their equivalents that are now offered in the zend-expressive-router v2.4+ releases, under the namespace Zend\\Expressive\\Router\\Middleware . The documentation here has been updated to reflect usage under Expressive 2.2+. ImplicitHeadMiddleware Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware provides support for handling HEAD requests to routed middleware when the route does not expliclity allow for the method. It should be registered between the routing and dispatch middleware. To use it, it must first be registered with your container. The easiest way to do that is to register the zend-expressive-router ConfigProvider in your config/config.php : $aggregator = new ConfigAggregator([ \\Zend\\Expressive\\Router\\ConfigProvider::class, Alternately, add the following dependency configuration in one of your config/autoload/ configuration files or a ConfigProvider class: use Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware; use Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddlewareFactory; 'dependencies' => [ 'factories' => [ ImplicitHeadMiddleware::class => ImplicitHeadMiddlewareFactory::class, ], ], Within your application pipeline, add the middleware between the routing and dispatch middleware: $app->pipeRoutingMiddleware(); $app->pipe(ImplicitHeadMiddleware::class); // ... $app->pipeDispatchMiddleware(); (Note: if you used the expressive-pipeline-from-config tool to create your programmatic pipeline, or if you used the Expressive skeleton, this middleware is likely already in your pipeline, as is a dependency entry.) When in place, it will do the following: If the request method is HEAD , AND the request composes a RouteResult attribute, AND the route result composes a Route instance, AND the route returns true for the implicitHead() method, THEN the middleware will return a response. In all other cases, it returns the result of delegating to the next middleware layer. When implicitHead() is matched, one of two things may occur. First, if the route does not support the GET method, then the middleware returns the composed response (either the one injected at instantiation, or an empty instance). However, if GET is supported, it will dispatch the next layer, but with a GET request instead of HEAD ; additionally, it will inject the returned response with an empty response body before returning it. Detecting forwarded requests Since 2.1.0 When the next layer is dispatched, the request will have an additional attribute, Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware::FORWARDED_HTTP_METHOD_ATTRIBUTE , with a value of HEAD . As such, you can check for this value in order to vary the headers returned if desired. ImplicitOptionsMiddleware Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware provides support for handling OPTIONS requests to routed middleware when the route does not expliclity allow for the method. Like the ImplicitHeadMiddleware , it should be registered between the routing and dispatch middleware. To use it, it must first be registered with your container. The easiest way to do that is to register the zend-expressive-router ConfigProvider in your config/config.php : $aggregator = new ConfigAggregator([ \\Zend\\Expressive\\Router\\ConfigProvider::class, Alternately, add the following dependency configuration in one of your config/autoload/ configuration files or a ConfigProvider class: use Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware; use Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddlewareFactory; 'dependencies' => [ 'factories' => [ ImplicitOptionsMiddleware::class => ImplicitOptionsMiddlewareFactory::class, ], ], Within your application pipeline, add the middleware between the routing and dispatch middleware: $app->pipeRoutingMiddleware(); $app->pipe(ImplicitOptionsMiddleware::class); // ... $app->pipeDispatchMiddleware(); (Note: if you used the expressive-pipeline-from-config tool to create your programmatic pipeline, or if you used the Expressive skeleton, this middleware is likely already in your pipeline, as is a dependency entry.) When in place, it will do the following: If the request method is OPTIONS , AND the request composes a RouteResult attribute, AND the route result composes a Route instance, AND the route returns true for the implicitOptions() method, THEN the middleware will return a response with an Allow header indicating methods the route allows. In all other cases, it returns the result of delegating to the next middleware layer. One thing to note: the allowed methods reported by the route and/or route result, and returned via the Allow header, may vary based on router implementation. In most cases, it should be an aggregate of all routes using the same path specification; however, it could be only the methods supported explicitly by the matched route.","title":"Implicit HEAD and OPTIONS Middleware"},{"location":"v2/features/middleware/implicit-methods-middleware/#implicitheadmiddleware-and-implicitoptionsmiddleware","text":"Expressive offers middleware for implicitly supporting HEAD and OPTIONS requests. The HTTP/1.1 specifications indicate that all server implementations must support HEAD requests for any given URI, and that they should support OPTIONS requests. To make this possible, we have added features to our routing layer, and middleware that can detect implicit support for these methods (i.e., the route was not registered explicitly with the method).","title":"ImplicitHeadMiddleware and ImplicitOptionsMiddleware"},{"location":"v2/features/middleware/implicit-methods-middleware/#implicitheadmiddleware","text":"Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware provides support for handling HEAD requests to routed middleware when the route does not expliclity allow for the method. It should be registered between the routing and dispatch middleware. To use it, it must first be registered with your container. The easiest way to do that is to register the zend-expressive-router ConfigProvider in your config/config.php : $aggregator = new ConfigAggregator([ \\Zend\\Expressive\\Router\\ConfigProvider::class, Alternately, add the following dependency configuration in one of your config/autoload/ configuration files or a ConfigProvider class: use Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware; use Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddlewareFactory; 'dependencies' => [ 'factories' => [ ImplicitHeadMiddleware::class => ImplicitHeadMiddlewareFactory::class, ], ], Within your application pipeline, add the middleware between the routing and dispatch middleware: $app->pipeRoutingMiddleware(); $app->pipe(ImplicitHeadMiddleware::class); // ... $app->pipeDispatchMiddleware(); (Note: if you used the expressive-pipeline-from-config tool to create your programmatic pipeline, or if you used the Expressive skeleton, this middleware is likely already in your pipeline, as is a dependency entry.) When in place, it will do the following: If the request method is HEAD , AND the request composes a RouteResult attribute, AND the route result composes a Route instance, AND the route returns true for the implicitHead() method, THEN the middleware will return a response. In all other cases, it returns the result of delegating to the next middleware layer. When implicitHead() is matched, one of two things may occur. First, if the route does not support the GET method, then the middleware returns the composed response (either the one injected at instantiation, or an empty instance). However, if GET is supported, it will dispatch the next layer, but with a GET request instead of HEAD ; additionally, it will inject the returned response with an empty response body before returning it.","title":"ImplicitHeadMiddleware"},{"location":"v2/features/middleware/implicit-methods-middleware/#implicitoptionsmiddleware","text":"Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware provides support for handling OPTIONS requests to routed middleware when the route does not expliclity allow for the method. Like the ImplicitHeadMiddleware , it should be registered between the routing and dispatch middleware. To use it, it must first be registered with your container. The easiest way to do that is to register the zend-expressive-router ConfigProvider in your config/config.php : $aggregator = new ConfigAggregator([ \\Zend\\Expressive\\Router\\ConfigProvider::class, Alternately, add the following dependency configuration in one of your config/autoload/ configuration files or a ConfigProvider class: use Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware; use Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddlewareFactory; 'dependencies' => [ 'factories' => [ ImplicitOptionsMiddleware::class => ImplicitOptionsMiddlewareFactory::class, ], ], Within your application pipeline, add the middleware between the routing and dispatch middleware: $app->pipeRoutingMiddleware(); $app->pipe(ImplicitOptionsMiddleware::class); // ... $app->pipeDispatchMiddleware(); (Note: if you used the expressive-pipeline-from-config tool to create your programmatic pipeline, or if you used the Expressive skeleton, this middleware is likely already in your pipeline, as is a dependency entry.) When in place, it will do the following: If the request method is OPTIONS , AND the request composes a RouteResult attribute, AND the route result composes a Route instance, AND the route returns true for the implicitOptions() method, THEN the middleware will return a response with an Allow header indicating methods the route allows. In all other cases, it returns the result of delegating to the next middleware layer. One thing to note: the allowed methods reported by the route and/or route result, and returned via the Allow header, may vary based on router implementation. In most cases, it should be an aggregate of all routes using the same path specification; however, it could be only the methods supported explicitly by the matched route.","title":"ImplicitOptionsMiddleware"},{"location":"v2/features/router/aura/","text":"Using Aura.Router Aura.Router provides a plethora of methods for further configuring the router instance. One of the more useful configuration is to provide default specifications: A regular expression that applies the same for a given routing match: php // Parameters named \"id\" will only match digits by default: $router->addTokens([ 'id' => '\\d+', ]); A default parameter and/or its default value to always provide: php // mediatype defaults to \"application/xhtml+xml\" and will be available in all // requests: $router->addValues([ 'mediatype' => 'application/xhtml+xml', ]); Only match if secure (i.e., under HTTPS): php $router->setSecure(true); In order to specify these, you need access to the underlying Aura.Router instance, however, and the RouterInterface does not provide an accessor! The answer, then, is to use dependency injection. This can be done in two ways: programmatically, or via a factory to use in conjunction with your container instance. Installing Aura.Router To use Aura.Router, you will first need to install the Aura.Router integration: $ composer require zendframework/zend-expressive-aurarouter Quick Start At its simplest, you can instantiate a Zend\\Expressive\\Router\\AuraRouter instance with no arguments; it will create the underlying Aura.Router objects required and compose them for you: use Zend\\Expressive\\Router\\AuraRouter; $router = new AuraRouter(); Programmatic Creation If you need greater control over the Aura.Router setup and configuration, you can create the instances necessary and inject them into Zend\\Expressive\\Router\\AuraRouter during instantiation. <?php use Aura\\Router\\RouterFactory; use Zend\\Expressive\\AppFactory; use Zend\\Expressive\\Router\\AuraRouter as AuraBridge; $auraRouter = (new RouterFactory())->newInstance(); $auraRouter->setSecure(true); $auraRouter->addValues([ 'mediatype' => 'application/xhtml+xml', ]); $router = new AuraBridge($auraRouter); // First argument is the container to use, if not using the default; // second is the router. $app = AppFactory::create(null, $router); Piping the route middleware As a reminder, you will need to ensure that middleware is piped in the order in which it needs to be executed; please see the section on \"Controlling middleware execution order\" in the piping documentation . This is particularly salient when defining routes before injecting the router in the application instance! Factory-Driven Creation We recommend using an Inversion of Control container for your applications; as such, in this section we will demonstrate two strategies for creating your Aura.Router implementation. Basic Router If you don't need to provide any setup or configuration, you can simply instantiate and return an instance of Zend\\Expressive\\Router\\AuraRouter for the service name Zend\\Expressive\\Router\\RouterInterface . A factory would look like this: // in src/Application/Container/RouterFactory.php namespace Application\\Container; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Router\\AuraRouter; class RouterFactory { /** * @param ContainerInterface $container * @return AuraRouter */ public function __invoke(ContainerInterface $container) { return new AuraRouter(); } } You would register this with zend-servicemanager using: $container->setFactory( Zend\\Expressive\\Router\\RouterInterface::class, Application\\Container\\RouterFactory::class ); And in Pimple: $pimple[Zend\\Expressive\\Router\\RouterInterface::class] = new Application\\Container\\RouterFactory(); For zend-servicemanager, you can omit the factory entirely, and register the class as an invokable: $container->setInvokableClass( Zend\\Expressive\\Router\\RouterInterface::class, Zend\\Expressive\\Router\\AuraRouter::class ); Advanced Configuration If you want to provide custom setup or configuration, you can do so. In this example, we will be defining two factories: A factory to register as and generate an Aura\\Router\\Router instance. A factory registered as Zend\\Expressive\\Router\\RouterInterface , which creates and returns a Zend\\Expressive\\Router\\AuraRouter instance composing the Aura\\Router\\Router instance. Sound difficult? It's not; we've essentially done it above already! // in src/Application/Container/AuraRouterFactory.php: namespace Application\\Container; use Aura\\Router\\RouterFactory; use Psr\\Container\\ContainerInterface; class AuraRouterFactory { /** * @param ContainerInterface $container * @return \\Aura\\Router\\Router */ public function __invoke(ContainerInterface $container) { $router = (new RouterFactory())->newInstance(); $router->setSecure(true); $router->addValues([ 'mediatype' => 'application/xhtml+xml', ]); return $router; } } // in src/Application/Container/RouterFactory.php namespace Application\\Container; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Router\\AuraRouter as AuraBridge; class RouterFactory { /** * @param ContainerInterface $container * @return AuraBridge */ public function __invoke(ContainerInterface $container) { return new AuraBridge($container->get('Aura\\Router\\Router')); } } From here, you will need to register your factories with your IoC container. If you are using zend-servicemanager, this will look like: // Programmatically: use Zend\\ServiceManager\\ServiceManager; $container = new ServiceManager(); $container->addFactory( 'Aura\\Router\\Router', Application\\Container\\AuraRouterFactory::class ); $container->addFactory( Zend\\Expressive\\Router\\RouterInterface::class, 'Application\\Container\\RouterFactory' ); // Alternately, via configuration: return [ 'factories' => [ 'Aura\\Router\\Router' => Application\\Container\\AuraRouterFactory::class, Zend\\Expressive\\Router\\RouterInterface::class => 'Application\\Container\\RouterFactory::class, ], ]; For Pimple, configuration looks like: use Application\\Container\\AuraRouterFactory; use Application\\Container\\RouterFactory; use Interop\\Container\\Pimple\\PimpleInterop as Pimple; $container = new Pimple(); $container['Aura\\Router\\Router'] = new AuraRouterFactory(); $container[Zend\\Expressive\\Router\\RouterInterface::class] = new RouterFactory();","title":"Using Aura"},{"location":"v2/features/router/aura/#using-aurarouter","text":"Aura.Router provides a plethora of methods for further configuring the router instance. One of the more useful configuration is to provide default specifications: A regular expression that applies the same for a given routing match: php // Parameters named \"id\" will only match digits by default: $router->addTokens([ 'id' => '\\d+', ]); A default parameter and/or its default value to always provide: php // mediatype defaults to \"application/xhtml+xml\" and will be available in all // requests: $router->addValues([ 'mediatype' => 'application/xhtml+xml', ]); Only match if secure (i.e., under HTTPS): php $router->setSecure(true); In order to specify these, you need access to the underlying Aura.Router instance, however, and the RouterInterface does not provide an accessor! The answer, then, is to use dependency injection. This can be done in two ways: programmatically, or via a factory to use in conjunction with your container instance.","title":"Using Aura.Router"},{"location":"v2/features/router/aura/#installing-aurarouter","text":"To use Aura.Router, you will first need to install the Aura.Router integration: $ composer require zendframework/zend-expressive-aurarouter","title":"Installing Aura.Router"},{"location":"v2/features/router/aura/#quick-start","text":"At its simplest, you can instantiate a Zend\\Expressive\\Router\\AuraRouter instance with no arguments; it will create the underlying Aura.Router objects required and compose them for you: use Zend\\Expressive\\Router\\AuraRouter; $router = new AuraRouter();","title":"Quick Start"},{"location":"v2/features/router/aura/#programmatic-creation","text":"If you need greater control over the Aura.Router setup and configuration, you can create the instances necessary and inject them into Zend\\Expressive\\Router\\AuraRouter during instantiation. <?php use Aura\\Router\\RouterFactory; use Zend\\Expressive\\AppFactory; use Zend\\Expressive\\Router\\AuraRouter as AuraBridge; $auraRouter = (new RouterFactory())->newInstance(); $auraRouter->setSecure(true); $auraRouter->addValues([ 'mediatype' => 'application/xhtml+xml', ]); $router = new AuraBridge($auraRouter); // First argument is the container to use, if not using the default; // second is the router. $app = AppFactory::create(null, $router);","title":"Programmatic Creation"},{"location":"v2/features/router/aura/#factory-driven-creation","text":"We recommend using an Inversion of Control container for your applications; as such, in this section we will demonstrate two strategies for creating your Aura.Router implementation.","title":"Factory-Driven Creation"},{"location":"v2/features/router/fast-route/","text":"Using FastRoute FastRoute provides a number of different combinations for how to both parse routes and match incoming requests against them. Internally, we use the standard route parser ( FastRoute\\RouterParser\\Std ) to parse routes, a RouteCollector to collect them, and the \"Group Count Based\" dispatcher to match incoming requests against routes. If you wish to use a different combination \u2014 e.g., to use the Group Position Based route matcher \u2014 you will need to create your own instances and inject them into the Zend\\Expressive\\Router\\FastRouteRouter class, at instantiation. The FastRouteRouter bridge class accepts two arguments at instantiation: A FastRoute\\RouteCollector instance A callable that will return a FastRoute\\Dispatcher\\RegexBasedAbstract instance. Injection can be done either programmatically or via a factory to use in conjunction with your container instance. Installing FastRoute To use FastRoute, you will first need to install the FastRoute integration: $ composer require zendframework/zend-expressive-fastroute Quick Start At its simplest, you can instantiate a Zend\\Expressive\\Router\\FastRouteRouter instance with no arguments; it will create the underlying FastRoute objects required and compose them for you: use Zend\\Expressive\\Router\\FastRouteRouter; $router = new FastRouteRouter(); Programmatic Creation If you need greater control over the FastRoute setup and configuration, you can create the instances necessary and inject them into Zend\\Expressive\\Router\\FastRouteRouter during instantiation. To do so, you will need to setup your RouteCollector instance and/or optionally callable to return your RegexBasedAbstract instance manually, inject them in your Zend\\Expressive\\Router\\FastRouteRouter instance, and inject use that when creating your Application instance. <?php use FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher; use FastRoute\\RouteCollector; use FastRoute\\RouteGenerator; use FastRoute\\RouteParser\\Std as RouteParser; use Zend\\Expressive\\AppFactory; use Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge; $fastRoute = new RouteCollector( new RouteParser(), new RouteGenerator() ); $getDispatcher = function ($data) { return new FastRouteDispatcher($data); }; $router = new FastRouteBridge($fastRoute, $getDispatcher); // First argument is the container to use, if not using the default; // second is the router. $app = AppFactory::create(null, $router); Piping the route middleware As a reminder, you will need to ensure that middleware is piped in the order in which it needs to be executed; please see the section on \"Controlling middleware execution order\" in the piping documentation . This is particularly salient when defining routes before injecting the router in the application instance! Factory-Driven Creation We recommend using an Inversion of Control container for your applications; as such, in this section we will demonstrate two strategies for creating your FastRoute implementation. Basic Router If you don't need to provide any setup or configuration, you can simply instantiate and return an instance of Zend\\Expressive\\Router\\FastRouteRouter for the service name Zend\\Expressive\\Router\\RouterInterface . A factory would look like this: // in src/App/Container/RouterFactory.php namespace App\\Container; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Router\\FastRouteRouter; class RouterFactory { /** * @param ContainerInterface $container * @return FastRouteRouter */ public function __invoke(ContainerInterface $container) { return new FastRouteRouter(); } } You would register this with zend-servicemanager using: $container->setFactory( Zend\\Expressive\\Router\\RouterInterface::class, App\\Container\\RouterFactory::class ); And in Pimple: $pimple[Zend\\Expressive\\Router\\RouterInterface::class] = new App\\Container\\RouterFactory(); For zend-servicemanager, you can omit the factory entirely, and register the class as an invokable: $container->setInvokableClass( Zend\\Expressive\\Router\\RouterInterface::class, Zend\\Expressive\\Router\\FastRouteRouter::class ); Advanced Configuration If you want to provide custom setup or configuration, you can do so. In this example, we will be defining three factories: A factory to register as and generate a FastRoute\\RouteCollector instance. A factory to register as FastRoute\\DispatcherFactory and return a callable factory that returns a RegexBasedAbstract instance. A factory registered as Zend\\Expressive\\Router\\RouterInterface , which creates and returns a Zend\\Expressive\\Router\\FastRouteRouter instance composing the two services. Sound difficult? It's not; we've essentially done it above already! <?php // in src/App/Container/FastRouteCollectorFactory.php: namespace App\\Container; use FastRoute\\RouteCollector; use FastRoute\\RouteGenerator; use FastRoute\\RouteParser\\Std as RouteParser; use Psr\\Container\\ContainerInterface; class FastRouteCollectorFactory { /** * @param ContainerInterface $container * @return RouteCollector */ public function __invoke(ContainerInterface $container) { return new RouteCollector( new RouteParser(), new RouteGenerator() ); } } // in src/App/Container/FastRouteDispatcherFactory.php: namespace App\\Container; use FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher; use Psr\\Container\\ContainerInterface; class FastRouteDispatcherFactory { /** * @param ContainerInterface $container * @return callable */ public function __invoke(ContainerInterface $container) { return function ($data) { return new FastRouteDispatcher($data); }; } } // in src/App/Container/RouterFactory.php namespace App\\Container; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge; class RouterFactory { /** * @param ContainerInterface $container * @return FastRouteBridge */ public function __invoke(ContainerInterface $container) { return new FastRouteBridge( $container->get(FastRoute\\RouteCollector::class), $container->get(FastRoute\\DispatcherFactory::class) ); } } From here, you will need to register your factories with your IoC container. If you are using zend-servicemanager, this will look like: // Programmatically: use Zend\\ServiceManager\\ServiceManager; $container = new ServiceManager(); $container->addFactory( FastRoute\\RouteCollector::class, App\\Container\\FastRouteCollectorFactory::class ); $container->addFactory( FastRoute\\DispatcherFactory::class, App\\Container\\FastRouteDispatcherFactory::class ); $container->addFactory( Zend\\Expressive\\Router\\RouterInterface::class, App\\Container\\RouterFactory::class ); // Alternately, via configuration: return [ 'factories' => [ 'FastRoute\\RouteCollector' => App\\Container\\FastRouteCollectorFactory::class, 'FastRoute\\DispatcherFactory' => App\\Container\\FastRouteDispatcherFactory::class, Zend\\Expressive\\Router\\RouterInterface::class => App\\Container\\RouterFactory::class, ], ]; For Pimple, configuration looks like: use App\\Container\\FastRouteCollectorFactory; use App\\Container\\FastRouteDispatcherFactory; use App\\Container\\RouterFactory; use Interop\\Container\\Pimple\\PimpleInterop as Pimple; $container = new Pimple(); $container[FastRoute\\RouteCollector::class] = new FastRouteCollectorFactory(); $container[FastRoute\\RouteDispatcher::class] = new FastRouteDispatcherFactory(); $container[Zend\\Expressive\\Router\\RouterInterface::class] = new RouterFactory(); FastRoute caching support Since zend-expressive-fastroute 1.3.0. Starting from version 1.3.0, zend-expressive-fastroute comes with support for FastRoute native dispatch data caching. Enabling this feature requires changes to your configuration. Typically, router configuration occurs in config/autoload/routes.global.php ; as such, we will reference that file when indicating configuration changes. The changes required are: You will need to delegate creation of the router instance to a new factory. You will need to add a new configuration entry, $config['router']['fastroute'] . The options in this entry will be used by the factory to build the router instance in order to toggle caching support and to specify a custom cache file. As an example: // File config/autoload/routes.global.php return [ 'dependencies' => [ //.. 'invokables' => [ /* ... */ // Comment out or remove the following line: // Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouter::class, /* ... */ ], 'factories' => [ /* ... */ // Add this line; the specified factory now creates the router instance: Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouterFactory::class, /* ... */ ], ], // Add the following to enable caching support: 'router' => [ 'fastroute' => [ // Enable caching support: 'cache_enabled' => true, // Optional (but recommended) cache file path: 'cache_file' => 'data/cache/fastroute.php.cache', ], ], 'routes' => [ /* ... */ ], ] The FastRoute-specific caching options are as follows: cache_enabled (bool) is used to toggle caching support. It's advisable to enable caching in a production environment and leave it disabled for the development environment. Commenting or omitting this option is equivalent to having it set to false . We recommend enabling it in config/autoload/routes.global.php , and, in development, disabling it within config/autoload/routes.local.php or config/autoload/local.php . cache_file (string) is an optional parameter that represents the path of the dispatch data cache file. It can be provided as an absolute file path or as a path relative to the zend-expressive working directory. It defaults to data/cache/fastroute.php.cache , where data/cache/ is the cache directory defined within the zend-expressive skeleton application. An explicit absolute file path is recommended since the php include construct will skip searching the include_path and the current directory. If you choose a custom path, make sure that the directory exists and is writable by the owner of the PHP process. As with any other zend-expressive cached configuration, you will need to purge this file in order to enable any newly added route when FastRoute caching is enabled.","title":"Using FastRoute"},{"location":"v2/features/router/fast-route/#using-fastroute","text":"FastRoute provides a number of different combinations for how to both parse routes and match incoming requests against them. Internally, we use the standard route parser ( FastRoute\\RouterParser\\Std ) to parse routes, a RouteCollector to collect them, and the \"Group Count Based\" dispatcher to match incoming requests against routes. If you wish to use a different combination \u2014 e.g., to use the Group Position Based route matcher \u2014 you will need to create your own instances and inject them into the Zend\\Expressive\\Router\\FastRouteRouter class, at instantiation. The FastRouteRouter bridge class accepts two arguments at instantiation: A FastRoute\\RouteCollector instance A callable that will return a FastRoute\\Dispatcher\\RegexBasedAbstract instance. Injection can be done either programmatically or via a factory to use in conjunction with your container instance.","title":"Using FastRoute"},{"location":"v2/features/router/fast-route/#installing-fastroute","text":"To use FastRoute, you will first need to install the FastRoute integration: $ composer require zendframework/zend-expressive-fastroute","title":"Installing FastRoute"},{"location":"v2/features/router/fast-route/#quick-start","text":"At its simplest, you can instantiate a Zend\\Expressive\\Router\\FastRouteRouter instance with no arguments; it will create the underlying FastRoute objects required and compose them for you: use Zend\\Expressive\\Router\\FastRouteRouter; $router = new FastRouteRouter();","title":"Quick Start"},{"location":"v2/features/router/fast-route/#programmatic-creation","text":"If you need greater control over the FastRoute setup and configuration, you can create the instances necessary and inject them into Zend\\Expressive\\Router\\FastRouteRouter during instantiation. To do so, you will need to setup your RouteCollector instance and/or optionally callable to return your RegexBasedAbstract instance manually, inject them in your Zend\\Expressive\\Router\\FastRouteRouter instance, and inject use that when creating your Application instance. <?php use FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher; use FastRoute\\RouteCollector; use FastRoute\\RouteGenerator; use FastRoute\\RouteParser\\Std as RouteParser; use Zend\\Expressive\\AppFactory; use Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge; $fastRoute = new RouteCollector( new RouteParser(), new RouteGenerator() ); $getDispatcher = function ($data) { return new FastRouteDispatcher($data); }; $router = new FastRouteBridge($fastRoute, $getDispatcher); // First argument is the container to use, if not using the default; // second is the router. $app = AppFactory::create(null, $router);","title":"Programmatic Creation"},{"location":"v2/features/router/fast-route/#factory-driven-creation","text":"We recommend using an Inversion of Control container for your applications; as such, in this section we will demonstrate two strategies for creating your FastRoute implementation.","title":"Factory-Driven Creation"},{"location":"v2/features/router/interface/","text":"Routing Interface Expressive defines Zend\\Expressive\\Router\\RouterInterface , which can be injected into and consumed by Zend\\Expressive\\Application in order to provide dynamic routing capabilities to middleware. The interface serves as an abstraction to allow routers with varying capabilities to be used with an application. The interface is defined as follows: namespace Zend\\Expressive\\Router; use Psr\\Http\\Message\\ServerRequestInterface as Request; interface RouterInterface { /** * Add a route. * * This method adds a route against which the underlying implementation may * match. Implementations MUST aggregate route instances, but MUST NOT use * the details to inject the underlying router until `match()` and/or * `generateUri()` is called. This is required to allow consumers to * modify route instances before matching (e.g., to provide route options, * inject a name, etc.). * * The method MUST raise Exception\\RuntimeException if called after either `match()` * or `generateUri()` have already been called, to ensure integrity of the * router between invocations of either of those methods. * * @param Route $route * @throws Exception\\RuntimeException when called after match() or * generateUri() have been called. */ public function addRoute(Route $route); /** * Match a request against the known routes. * * Implementations will aggregate required information from the provided * request instance, and pass them to the underlying router implementation; * when done, they will then marshal a `RouteResult` instance indicating * the results of the matching operation and return it to the caller. * * @param Request $request * @return RouteResult */ public function match(Request $request); /** * Generate a URI from the named route. * * Takes the named route and any substitutions, and attempts to generate a * URI from it. * * @see https://github.com/auraphp/Aura.Router#generating-a-route-path * @see http://framework.zend.com/manual/current/en/modules/zend.mvc.routing.html * @param string $name * @param array $substitutions * @param array $options * @return string * @throws Exception\\RuntimeException if unable to generate the given URI. */ public function generateUri($name, array $substitutions = [], array $options = []); } Developers may create and use their own implementations. We recommend registering your implementation as the service Zend\\Expressive\\Router\\RouterInterface in your container to ensure other factories provided by zend-expressive will receive your custom service. Implementors should also read the following sections detailing the Route and RouteResult classes, to ensure that their implementations interoperate correctly. Routes Routes are defined via Zend\\Expressive\\Router\\Route , and aggregate the following information: Path to match. Middleware to use when the route is matched. This may be a callable or a service name resolving to middleware. HTTP methods allowed for the route; if none are provided, all are assumed. Optionally, a name by which to reference the route. The Route class has the following signature: namespace Zend\\Expressive\\Router; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; class Route { const HTTP_METHOD_ANY = 0xff; const HTTP_METHOD_SEPARATOR = ':'; /** * @param string $path Path to match. * @param string|callable|MiddlewareInterface $middleware Middleware to use * when this route is matched. * @param int|array Allowed HTTP methods; defaults to HTTP_METHOD_ANY. * @param string|null $name the route name * @throws Exception\\InvalidArgumentException for invalid path type. * @throws Exception\\InvalidArgumentException for invalid middleware type. * @throws Exception\\InvalidArgumentException for any invalid HTTP method names. */ public function __construct($path, $middleware, $methods = self::HTTP_METHOD_ANY, $name = null); /** * @return string */ public function getPath(); /** * Set the route name. * * @param string $name */ public function setName($name); /** * @return string */ public function getName(); /** * @return string|callable|MiddlewareInterface */ public function getMiddleware(); /** * @return int|string[] Returns HTTP_METHOD_ANY or array of allowed methods. */ public function getAllowedMethods(); /** * Indicate whether the specified method is allowed by the route. * * @param string $method HTTP method to test. * @return bool */ public function allowsMethod($method); /** * @param array $options */ public function setOptions(array $options); /** * @return array */ public function getOptions(); } Typically, developers will use Zend\\Expressive\\Application::route() (or one of the HTTP-specific routing methods) to create routes, and will not need to interact with Route instances. However, that method can also accept Route instances, allowing more flexibility in defining and configuring them; additionally, when working with RouteResult instances, you may pull the Route instance from that in order to obtain data about the matched route. Matching and RouteResults Internally, Zend\\Expressive\\Application calls on RouterInterface::match() , passing it the current request instance. This allows implementations to pull what they may need from the request in order to perform their routing logic; for example, they may need the request method, the URI path, the value of the HTTPS server variable, etc. Implementations are expected to return a Zend\\Expressive\\Router\\RouteResult instance, which the routing middleware then uses to determine if routing succeeded. In the event of success, it will pull any matched parameters from the result and inject them as request attributes, and then pull the matched middleware and execute it. In the case of failure, it will determine if the failure was due to inability to match, or usage of a disallowed HTTP method; in the former case, it proceeds to the next middleware in the stack, and in the latter, returns a 405 response. The RouteResult signature is as follows: namespace Zend\\Expressive\\Router; class RouteResult { /** * Create an instance representing a route success from a Route instance. * * This method should be used for generating an instance indicating a route * success. * * @param Route $route * @param array $params Parameters associated with the matched route. * @return static */ public static function fromRoute(Route $route, array $params = []); /** * Create an instance representing a route failure. * * @param null|int|array $methods HTTP methods allowed for the current URI, if any * @return static */ public static function fromRouteFailure($methods = null); /** * Does the result represent successful routing? * * @return bool */ public function isSuccess(); /** * Retrieve the matched route, if possible. * * If this result represents a failure, return false; otherwise, return the * matched route instance. * * @return Route */ public function getMatchedRoute(); /** * Retrieve the matched route name, if possible. * * If this result represents a failure, return false; otherwise, return the * matched route name. * * @return string */ public function getMatchedRouteName(); /** * Retrieve the matched middleware, if possible. * * @return false|callable|string Returns false if the result represents a * failure; otherwise, a callable or a string service name. */ public function getMatchedMiddleware(); /** * Returns the matched params. * * Guaranteed to return an array, even if it is simply empty. * * @return array */ public function getMatchedParams(); /** * Is this a routing failure result? * * @return bool */ public function isFailure(); /** * Does the result represent failure to route due to HTTP method? * * @return bool */ public function isMethodFailure(); /** * Retrieve the allowed methods for the route failure. * * @return string[] HTTP methods allowed */ public function getAllowedMethods(); } Typically, only those implementing routers will interact with this class.","title":"Routing Interface"},{"location":"v2/features/router/interface/#routing-interface","text":"Expressive defines Zend\\Expressive\\Router\\RouterInterface , which can be injected into and consumed by Zend\\Expressive\\Application in order to provide dynamic routing capabilities to middleware. The interface serves as an abstraction to allow routers with varying capabilities to be used with an application. The interface is defined as follows: namespace Zend\\Expressive\\Router; use Psr\\Http\\Message\\ServerRequestInterface as Request; interface RouterInterface { /** * Add a route. * * This method adds a route against which the underlying implementation may * match. Implementations MUST aggregate route instances, but MUST NOT use * the details to inject the underlying router until `match()` and/or * `generateUri()` is called. This is required to allow consumers to * modify route instances before matching (e.g., to provide route options, * inject a name, etc.). * * The method MUST raise Exception\\RuntimeException if called after either `match()` * or `generateUri()` have already been called, to ensure integrity of the * router between invocations of either of those methods. * * @param Route $route * @throws Exception\\RuntimeException when called after match() or * generateUri() have been called. */ public function addRoute(Route $route); /** * Match a request against the known routes. * * Implementations will aggregate required information from the provided * request instance, and pass them to the underlying router implementation; * when done, they will then marshal a `RouteResult` instance indicating * the results of the matching operation and return it to the caller. * * @param Request $request * @return RouteResult */ public function match(Request $request); /** * Generate a URI from the named route. * * Takes the named route and any substitutions, and attempts to generate a * URI from it. * * @see https://github.com/auraphp/Aura.Router#generating-a-route-path * @see http://framework.zend.com/manual/current/en/modules/zend.mvc.routing.html * @param string $name * @param array $substitutions * @param array $options * @return string * @throws Exception\\RuntimeException if unable to generate the given URI. */ public function generateUri($name, array $substitutions = [], array $options = []); } Developers may create and use their own implementations. We recommend registering your implementation as the service Zend\\Expressive\\Router\\RouterInterface in your container to ensure other factories provided by zend-expressive will receive your custom service. Implementors should also read the following sections detailing the Route and RouteResult classes, to ensure that their implementations interoperate correctly.","title":"Routing Interface"},{"location":"v2/features/router/interface/#routes","text":"Routes are defined via Zend\\Expressive\\Router\\Route , and aggregate the following information: Path to match. Middleware to use when the route is matched. This may be a callable or a service name resolving to middleware. HTTP methods allowed for the route; if none are provided, all are assumed. Optionally, a name by which to reference the route. The Route class has the following signature: namespace Zend\\Expressive\\Router; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; class Route { const HTTP_METHOD_ANY = 0xff; const HTTP_METHOD_SEPARATOR = ':'; /** * @param string $path Path to match. * @param string|callable|MiddlewareInterface $middleware Middleware to use * when this route is matched. * @param int|array Allowed HTTP methods; defaults to HTTP_METHOD_ANY. * @param string|null $name the route name * @throws Exception\\InvalidArgumentException for invalid path type. * @throws Exception\\InvalidArgumentException for invalid middleware type. * @throws Exception\\InvalidArgumentException for any invalid HTTP method names. */ public function __construct($path, $middleware, $methods = self::HTTP_METHOD_ANY, $name = null); /** * @return string */ public function getPath(); /** * Set the route name. * * @param string $name */ public function setName($name); /** * @return string */ public function getName(); /** * @return string|callable|MiddlewareInterface */ public function getMiddleware(); /** * @return int|string[] Returns HTTP_METHOD_ANY or array of allowed methods. */ public function getAllowedMethods(); /** * Indicate whether the specified method is allowed by the route. * * @param string $method HTTP method to test. * @return bool */ public function allowsMethod($method); /** * @param array $options */ public function setOptions(array $options); /** * @return array */ public function getOptions(); } Typically, developers will use Zend\\Expressive\\Application::route() (or one of the HTTP-specific routing methods) to create routes, and will not need to interact with Route instances. However, that method can also accept Route instances, allowing more flexibility in defining and configuring them; additionally, when working with RouteResult instances, you may pull the Route instance from that in order to obtain data about the matched route.","title":"Routes"},{"location":"v2/features/router/interface/#matching-and-routeresults","text":"Internally, Zend\\Expressive\\Application calls on RouterInterface::match() , passing it the current request instance. This allows implementations to pull what they may need from the request in order to perform their routing logic; for example, they may need the request method, the URI path, the value of the HTTPS server variable, etc. Implementations are expected to return a Zend\\Expressive\\Router\\RouteResult instance, which the routing middleware then uses to determine if routing succeeded. In the event of success, it will pull any matched parameters from the result and inject them as request attributes, and then pull the matched middleware and execute it. In the case of failure, it will determine if the failure was due to inability to match, or usage of a disallowed HTTP method; in the former case, it proceeds to the next middleware in the stack, and in the latter, returns a 405 response. The RouteResult signature is as follows: namespace Zend\\Expressive\\Router; class RouteResult { /** * Create an instance representing a route success from a Route instance. * * This method should be used for generating an instance indicating a route * success. * * @param Route $route * @param array $params Parameters associated with the matched route. * @return static */ public static function fromRoute(Route $route, array $params = []); /** * Create an instance representing a route failure. * * @param null|int|array $methods HTTP methods allowed for the current URI, if any * @return static */ public static function fromRouteFailure($methods = null); /** * Does the result represent successful routing? * * @return bool */ public function isSuccess(); /** * Retrieve the matched route, if possible. * * If this result represents a failure, return false; otherwise, return the * matched route instance. * * @return Route */ public function getMatchedRoute(); /** * Retrieve the matched route name, if possible. * * If this result represents a failure, return false; otherwise, return the * matched route name. * * @return string */ public function getMatchedRouteName(); /** * Retrieve the matched middleware, if possible. * * @return false|callable|string Returns false if the result represents a * failure; otherwise, a callable or a string service name. */ public function getMatchedMiddleware(); /** * Returns the matched params. * * Guaranteed to return an array, even if it is simply empty. * * @return array */ public function getMatchedParams(); /** * Is this a routing failure result? * * @return bool */ public function isFailure(); /** * Does the result represent failure to route due to HTTP method? * * @return bool */ public function isMethodFailure(); /** * Retrieve the allowed methods for the route failure. * * @return string[] HTTP methods allowed */ public function getAllowedMethods(); } Typically, only those implementing routers will interact with this class.","title":"Matching and RouteResults"},{"location":"v2/features/router/intro/","text":"Routing One fundamental feature of zend-expressive is that it provides mechanisms for implementing dynamic routing, a feature required in most modern web applications. As an example, you may want to allow matching both a resource, as well as individual items of that resource: /books might return a collection of books /books/zend-expressive might return the individual book identified by \"zend-expressive\". Expressive does not provide routing on its own; you must choose a routing adapter that implements Zend\\Expressive\\Router\\RouterInterface and provide it to the Application instance. This allows you to choose the router with the capabilities that best match your own needs, while still providing a common abstraction for defining and aggregating routes and their related middleware. Retrieving matched parameters Routing enables the ability to match dynamic path segments (or other criteria). Typically, you will want access to the values matched. The routing middleware injects any matched parameters as returned by the underlying router into the request as attributes . In the example above, let's assume the route was defined as /books/:id , where id is the name of the dynamic segment. This means that in the middleware invoked for this route, you can fetch the id attribute to discover what was matched: $id = $request->getAttribute('id'); Retrieving the matched route When routing is successful, the routing middleware injects a Zend\\Expressive\\Router\\RouteResult instance as a request attribute, using that class name as the attribute name. The RouteResult instance provides you access to the following: The matched Zend\\Expressive\\Router\\Route instance, via $result->getMatchedRoute() . The matched route name, via $result->getMatchedRouteName() (or via $result->getMatchedRoute()->getName() ). The matched middleware, via $result->getMatchedMiddleware() (or via $result->getMatchedRoute()->getMiddleware() ). Matched parameters, via $result->getMatchedParams() (as noted above, these are also each injected as discrete request attributes). Allowed HTTP methods, via $result->getAllowedMethods() . As an example, you could use middleware similar to the following to return a 403 response if routing was successful, but no Authorization header is present: use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Zend\\Diactoros\\Response\\EmptyResponse; use Zend\\Expressive\\Router\\RouteResult; function ($request, DelegateInterface $delegate) use ($routesRequiringAuthorization, $validator) { if (! ($result = $request->getAttribute(RouteResult::class, false))) { // No route matched; delegate to next middleware return $delegate->process($request); } if (! in_array($result->getMatchedRouteName(), $routesRequiringAuthorization, true)) { // Not a route requiring authorization return $delegate->process($request); } $header = $request->getHeaderLine('Authorization'); if (! $validator($header)) { return new EmptyResponse(403); } return $delegate->process($request); } Note that the first step is to determine if we have a RouteResult ; if we do not have one, we should either delegate to the next middleware, or return some sort of response (generally a 404). In the case of Expressive, a later middleware will generate the 404 response for us, so we can safely delegate. URI generation Because routers have knowledge of the various paths they can match, they are also typically used within applications to generate URIs to other application resources. Expressive provides this capability in the RouterInterface , either delegating to the underlying router implementations or providing a compatible implementation of its own. At it's most basic level, you call the generateUri() method with a route name and any substitutions you want to make: $uri = $router->generateUri('book', ['id' => 'zend-expressive']); Some routers may support providing options during URI generation. Starting in zend-expressive-router 2.0, which ships with Expressive starting with version 2.0, you may also pass a third argument to generateUri() , an array of router options: $uri = $router->generateUri('book', ['id' => 'zend-expressive'], [ 'translator' => $translator, 'text_domain' => $currentLocale, ]); Supported implementations Expressive currently ships with adapters for the following routers: Aura.Router FastRoute zend-mvc Router","title":"Introduction"},{"location":"v2/features/router/intro/#routing","text":"One fundamental feature of zend-expressive is that it provides mechanisms for implementing dynamic routing, a feature required in most modern web applications. As an example, you may want to allow matching both a resource, as well as individual items of that resource: /books might return a collection of books /books/zend-expressive might return the individual book identified by \"zend-expressive\". Expressive does not provide routing on its own; you must choose a routing adapter that implements Zend\\Expressive\\Router\\RouterInterface and provide it to the Application instance. This allows you to choose the router with the capabilities that best match your own needs, while still providing a common abstraction for defining and aggregating routes and their related middleware.","title":"Routing"},{"location":"v2/features/router/intro/#retrieving-matched-parameters","text":"Routing enables the ability to match dynamic path segments (or other criteria). Typically, you will want access to the values matched. The routing middleware injects any matched parameters as returned by the underlying router into the request as attributes . In the example above, let's assume the route was defined as /books/:id , where id is the name of the dynamic segment. This means that in the middleware invoked for this route, you can fetch the id attribute to discover what was matched: $id = $request->getAttribute('id');","title":"Retrieving matched parameters"},{"location":"v2/features/router/intro/#retrieving-the-matched-route","text":"When routing is successful, the routing middleware injects a Zend\\Expressive\\Router\\RouteResult instance as a request attribute, using that class name as the attribute name. The RouteResult instance provides you access to the following: The matched Zend\\Expressive\\Router\\Route instance, via $result->getMatchedRoute() . The matched route name, via $result->getMatchedRouteName() (or via $result->getMatchedRoute()->getName() ). The matched middleware, via $result->getMatchedMiddleware() (or via $result->getMatchedRoute()->getMiddleware() ). Matched parameters, via $result->getMatchedParams() (as noted above, these are also each injected as discrete request attributes). Allowed HTTP methods, via $result->getAllowedMethods() . As an example, you could use middleware similar to the following to return a 403 response if routing was successful, but no Authorization header is present: use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Zend\\Diactoros\\Response\\EmptyResponse; use Zend\\Expressive\\Router\\RouteResult; function ($request, DelegateInterface $delegate) use ($routesRequiringAuthorization, $validator) { if (! ($result = $request->getAttribute(RouteResult::class, false))) { // No route matched; delegate to next middleware return $delegate->process($request); } if (! in_array($result->getMatchedRouteName(), $routesRequiringAuthorization, true)) { // Not a route requiring authorization return $delegate->process($request); } $header = $request->getHeaderLine('Authorization'); if (! $validator($header)) { return new EmptyResponse(403); } return $delegate->process($request); } Note that the first step is to determine if we have a RouteResult ; if we do not have one, we should either delegate to the next middleware, or return some sort of response (generally a 404). In the case of Expressive, a later middleware will generate the 404 response for us, so we can safely delegate.","title":"Retrieving the matched route"},{"location":"v2/features/router/intro/#uri-generation","text":"Because routers have knowledge of the various paths they can match, they are also typically used within applications to generate URIs to other application resources. Expressive provides this capability in the RouterInterface , either delegating to the underlying router implementations or providing a compatible implementation of its own. At it's most basic level, you call the generateUri() method with a route name and any substitutions you want to make: $uri = $router->generateUri('book', ['id' => 'zend-expressive']); Some routers may support providing options during URI generation. Starting in zend-expressive-router 2.0, which ships with Expressive starting with version 2.0, you may also pass a third argument to generateUri() , an array of router options: $uri = $router->generateUri('book', ['id' => 'zend-expressive'], [ 'translator' => $translator, 'text_domain' => $currentLocale, ]);","title":"URI generation"},{"location":"v2/features/router/intro/#supported-implementations","text":"Expressive currently ships with adapters for the following routers: Aura.Router FastRoute zend-mvc Router","title":"Supported implementations"},{"location":"v2/features/router/piping/","text":"Routing vs Piping Expressive provides two mechanisms for adding middleware to your application: piping, which is a foundation feature of the underlying zend-stratigility implementation. routing, which is an additional feature provided by zend-expressive. Piping zend-stratigility provides a mechanism termed piping for composing middleware in an application. When you pipe middleware to the application, it is added to a queue, and dequeued in order until a middleware returns a response instance. If none ever returns a response instance, execution is delegated to a \"final handler\", which determines whether or not to return an error, and, if so, what kind of error to return. Stratigility also allows you to segregate piped middleware to specific paths. As an example: $app->pipe('/api', $apiMiddleware); will execute $apiMiddleware only if the path matches /api ; otherwise, it will skip over that middleware. This path segregation, however, is limited: it will only match literal paths. This is done purposefully, to provide excellent baseline performance, and to prevent feature creep in the library. Expressive uses and exposes piping to users, with one addition: middleware may be specified by service name, and zend-expressive will lazy-load the service only when the middleware is invoked . In order to accomplish the lazy-loading, zend-expressive wraps the calls to fetch and dispatch the middleware inside a Zend\\Expressive\\Middleware\\LazyLoadingMiddleware instance; as such, there is no overhead to utilizing service-based middleware until it is dispatched . Routing Routing is the process of discovering values from the incoming request based on defined criteria. That criteria might look like: /book/:id (ZF2) /book/{id} (Aura.Router) /book/{id:\\d+} (FastRoute) In each of the above, if the router determines that the request matches the criteria, it will indicate: the route that matched the id parameter was matched, and the value matched Most routers allow you to define arbitrarily complex rules, and many even allow you to define: default values for unmatched parameters criteria for evaluating a match (such as a regular expression) additional criteria to meet (such as SSL usage, allowed query string variables, etc.) As such, routing is more powerful than the literal path matching used when piping, but it is also more costly (though routers such as FastRoute largely make such performance issues moot). When to Pipe In Expressive, we recommend that you pipe middleware in the following circumstances: It should (potentially) run on every execution. Examples for such usage include: Logging requests Performing content negotiation Handling cookies Error handling. Application segregation. You can write re-usable middleware, potentially even based off of Expressive, that contains its own routing logic, and compose it such that it only executes if it matches a sub-path. When to Route Use routing when: Your middleware is reacting to a given path. You want to use dynamic routing. You want to restrict usage of middleware to specific HTTP methods. You want to be able to generate URIs to your middleware. The above cover most use cases; in other words, most middleware should be added to the application as routed middleware . Controlling middleware execution order As noted in the earlier section on piping, piped middleware is queued , meaning it has a FIFO (\"first in, first out\") execution order. Additionally, zend-expressive's routing and dispatch capabilities are themselves implemented as piped middleware. To ensure your middleware is piped correctly, keep in mind the following: If middleware should execute on every request , pipe it early. Pipe routing and dispatch middleware using their dedicated application methods (more on this below), optionally with middleware between them to further shape application flow. Pipe middleware guaranteed to return a response (such as a \"not found\" handler or similar) last . To use the shipped routing and dispatch middleware (likely a good idea!), use the dedicated application methods pipeRoutingMiddleware() and pipeDispatchMiddleware() ; Application contains logic to ensure neither of these are called more than once. As an example: $app->pipe(OriginalMessages::class); $app->pipe(ServerUrlMiddleware::class); $app->pipe(XClacksOverhead::class); $app->pipe(ErrorHandler::class); $app->pipeRoutingMiddleware(); $app->pipe(UrlHelperMiddleware::class); $app->pipe(AuthorizationCheck::class); $app->pipeDispatchMiddleware(); $app->pipe(NotFoundHandler::class);","title":"Routing vs Piping"},{"location":"v2/features/router/piping/#routing-vs-piping","text":"Expressive provides two mechanisms for adding middleware to your application: piping, which is a foundation feature of the underlying zend-stratigility implementation. routing, which is an additional feature provided by zend-expressive.","title":"Routing vs Piping"},{"location":"v2/features/router/piping/#piping","text":"zend-stratigility provides a mechanism termed piping for composing middleware in an application. When you pipe middleware to the application, it is added to a queue, and dequeued in order until a middleware returns a response instance. If none ever returns a response instance, execution is delegated to a \"final handler\", which determines whether or not to return an error, and, if so, what kind of error to return. Stratigility also allows you to segregate piped middleware to specific paths. As an example: $app->pipe('/api', $apiMiddleware); will execute $apiMiddleware only if the path matches /api ; otherwise, it will skip over that middleware. This path segregation, however, is limited: it will only match literal paths. This is done purposefully, to provide excellent baseline performance, and to prevent feature creep in the library. Expressive uses and exposes piping to users, with one addition: middleware may be specified by service name, and zend-expressive will lazy-load the service only when the middleware is invoked . In order to accomplish the lazy-loading, zend-expressive wraps the calls to fetch and dispatch the middleware inside a Zend\\Expressive\\Middleware\\LazyLoadingMiddleware instance; as such, there is no overhead to utilizing service-based middleware until it is dispatched .","title":"Piping"},{"location":"v2/features/router/piping/#routing","text":"Routing is the process of discovering values from the incoming request based on defined criteria. That criteria might look like: /book/:id (ZF2) /book/{id} (Aura.Router) /book/{id:\\d+} (FastRoute) In each of the above, if the router determines that the request matches the criteria, it will indicate: the route that matched the id parameter was matched, and the value matched Most routers allow you to define arbitrarily complex rules, and many even allow you to define: default values for unmatched parameters criteria for evaluating a match (such as a regular expression) additional criteria to meet (such as SSL usage, allowed query string variables, etc.) As such, routing is more powerful than the literal path matching used when piping, but it is also more costly (though routers such as FastRoute largely make such performance issues moot).","title":"Routing"},{"location":"v2/features/router/piping/#when-to-pipe","text":"In Expressive, we recommend that you pipe middleware in the following circumstances: It should (potentially) run on every execution. Examples for such usage include: Logging requests Performing content negotiation Handling cookies Error handling. Application segregation. You can write re-usable middleware, potentially even based off of Expressive, that contains its own routing logic, and compose it such that it only executes if it matches a sub-path.","title":"When to Pipe"},{"location":"v2/features/router/piping/#when-to-route","text":"Use routing when: Your middleware is reacting to a given path. You want to use dynamic routing. You want to restrict usage of middleware to specific HTTP methods. You want to be able to generate URIs to your middleware. The above cover most use cases; in other words, most middleware should be added to the application as routed middleware .","title":"When to Route"},{"location":"v2/features/router/piping/#controlling-middleware-execution-order","text":"As noted in the earlier section on piping, piped middleware is queued , meaning it has a FIFO (\"first in, first out\") execution order. Additionally, zend-expressive's routing and dispatch capabilities are themselves implemented as piped middleware. To ensure your middleware is piped correctly, keep in mind the following: If middleware should execute on every request , pipe it early. Pipe routing and dispatch middleware using their dedicated application methods (more on this below), optionally with middleware between them to further shape application flow. Pipe middleware guaranteed to return a response (such as a \"not found\" handler or similar) last . To use the shipped routing and dispatch middleware (likely a good idea!), use the dedicated application methods pipeRoutingMiddleware() and pipeDispatchMiddleware() ; Application contains logic to ensure neither of these are called more than once. As an example: $app->pipe(OriginalMessages::class); $app->pipe(ServerUrlMiddleware::class); $app->pipe(XClacksOverhead::class); $app->pipe(ErrorHandler::class); $app->pipeRoutingMiddleware(); $app->pipe(UrlHelperMiddleware::class); $app->pipe(AuthorizationCheck::class); $app->pipeDispatchMiddleware(); $app->pipe(NotFoundHandler::class);","title":"Controlling middleware execution order"},{"location":"v2/features/router/uri-generation/","text":"URI Generation One aspect of the Zend\\Expressive\\Router\\RouterInterface is that it provides a generateUri() method. This method accepts a route name, and optionally an associative array of substitutions to use in the generated URI (e.g., if the URI has any named placeholders). You may also pass router-specific options to use during URI generation as a third argument. Naming routes By default, routes use a combination of the path and HTTP methods supported as the name: If you call route() with no HTTP methods, the name is the literal path with no changes. php $app->route('/foo', $middleware); // \"foo\" If you call get() , post() , put() , patch() , or delete() , the name will be the literal path, followed by a caret ( ^ ), followed by the uppercase HTTP method name: php $app->get('/foo', $middleware); // \"foo^GET\" Alternately, these methods return a Route instance, and you can set the name on it: php $app->get('/foo', $middleware)->setName('foo'); // \"foo\" If you call route() and specify a list of HTTP methods accepted, the name will be the literal path, followed by a caret ( ^ ), followed by a colon ( : )-separated list of the uppercase HTTP method names, in the order in which they were added. php $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\" Like the HTTP-specific methods, route() also returns a Route instance, and you can set the name on it: php $route = $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\" $route->setName('foo'); // \"foo\" Clearly, this can become difficult to remember. As such, Expressive offers the ability to specify a custom string for the route name as an additional, optional argument to any of the above: $app->route('/foo', $middleware, 'foo'); // 'foo' $app->get('/foo/:id', $middleware, 'foo-item'); // 'foo-item' $app->route('/foo', $middleware, ['GET', 'POST'], 'foo-collection'); // 'foo-collection' As noted above, these methods also return Route instances, allowing you to set the name after-the-fact; this is particularly useful with the route() method, where you may want to omit the HTTP methods if any HTTP method is allowed: $app->route('/foo', $middleware)->setName('foo'); // 'foo' We recommend that if you plan on generating URIs for given routes, you provide a custom name. Generating URIs Once you know the name of a URI you wish to generate, you can do so from the router instance: $uri = $router->generateUri('foo-item', ['id' => 'bar']); // \"/foo/bar\" You can omit the second argument if no substitutions are necessary. Compose the router For this to work, you'll need to compose the router instance in any class that requires the URI generation facility. Inject the Zend\\Expressive\\Router\\RouterInterface service in these situations.","title":"URI Generation"},{"location":"v2/features/router/uri-generation/#uri-generation","text":"One aspect of the Zend\\Expressive\\Router\\RouterInterface is that it provides a generateUri() method. This method accepts a route name, and optionally an associative array of substitutions to use in the generated URI (e.g., if the URI has any named placeholders). You may also pass router-specific options to use during URI generation as a third argument.","title":"URI Generation"},{"location":"v2/features/router/uri-generation/#naming-routes","text":"By default, routes use a combination of the path and HTTP methods supported as the name: If you call route() with no HTTP methods, the name is the literal path with no changes. php $app->route('/foo', $middleware); // \"foo\" If you call get() , post() , put() , patch() , or delete() , the name will be the literal path, followed by a caret ( ^ ), followed by the uppercase HTTP method name: php $app->get('/foo', $middleware); // \"foo^GET\" Alternately, these methods return a Route instance, and you can set the name on it: php $app->get('/foo', $middleware)->setName('foo'); // \"foo\" If you call route() and specify a list of HTTP methods accepted, the name will be the literal path, followed by a caret ( ^ ), followed by a colon ( : )-separated list of the uppercase HTTP method names, in the order in which they were added. php $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\" Like the HTTP-specific methods, route() also returns a Route instance, and you can set the name on it: php $route = $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\" $route->setName('foo'); // \"foo\" Clearly, this can become difficult to remember. As such, Expressive offers the ability to specify a custom string for the route name as an additional, optional argument to any of the above: $app->route('/foo', $middleware, 'foo'); // 'foo' $app->get('/foo/:id', $middleware, 'foo-item'); // 'foo-item' $app->route('/foo', $middleware, ['GET', 'POST'], 'foo-collection'); // 'foo-collection' As noted above, these methods also return Route instances, allowing you to set the name after-the-fact; this is particularly useful with the route() method, where you may want to omit the HTTP methods if any HTTP method is allowed: $app->route('/foo', $middleware)->setName('foo'); // 'foo' We recommend that if you plan on generating URIs for given routes, you provide a custom name.","title":"Naming routes"},{"location":"v2/features/router/uri-generation/#generating-uris","text":"Once you know the name of a URI you wish to generate, you can do so from the router instance: $uri = $router->generateUri('foo-item', ['id' => 'bar']); // \"/foo/bar\" You can omit the second argument if no substitutions are necessary.","title":"Generating URIs"},{"location":"v2/features/router/zf2/","text":"Using the ZF2 Router zend-router provides several router implementations used for ZF2+ applications; the default is Zend\\Router\\Http\\TreeRouteStack , which can compose a number of different routes of differing types in order to perform routing. The ZF2 bridge we provide, Zend\\Expressive\\Router\\ZendRouter , uses the TreeRouteStack , and injects Segment routes to it; these are in turn injected with Method routes, and a special \"method not allowed\" route at negative priority to enable us to distinguish between failure to match the path and failure to match the HTTP method. If you instantiate it with no arguments, it will create an empty TreeRouteStack . Thus, the simplest way to start with this router is: use Zend\\Expressive\\AppFactory; use Zend\\Expressive\\Router\\ZendRouter; $app = AppFactory::create(null, new ZendRouter()); The TreeRouteStack offers some unique features: Route \"prototypes\". These are essentially like child routes that must also match in order for a given route to match. These are useful for implementing functionality such as ensuring the request comes in over HTTPS, or over a specific subdomain. Base URL functionality. If a base URL is injected, comparisons will be relative to that URL. This is mostly unnecessary with Stratigility-based middleware, but could solve some edge cases. To specify these, you need access to the underlying TreeRouteStack instance, however, and the RouterInterface does not provide an accessor! The answer, then, is to use dependency injection. This can be done in two ways: programmatically, or via a factory to use in conjunction with your container instance. Installing the ZF2 Router To use the ZF2 router, you will need to install the zend-mvc router integration: $ composer require zendframework/zend-expressive-zendrouter Quick Start At its simplest, you can instantiate a Zend\\Expressive\\Router\\ZendRouter instance with no arguments; it will create the underlying zend-mvc routing objects required and compose them for you: use Zend\\Expressive\\Router\\ZendRouter; $router = new ZendRouter(); Programmatic Creation If you need greater control over the zend-mvc router setup and configuration, you can create the instances necessary and inject them into Zend\\Expressive\\Router\\ZendRouter during instantiation. use Zend\\Expressive\\AppFactory; use Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge; use Zend\\Router\\Http\\TreeRouteStack; $zendRouter = new TreeRouteStack(); $zendRouter->addPrototypes(/* ... */); $zendRouter->setBaseUrl(/* ... */); $router = new Zf2Bridge($zendRouter); // First argument is the container to use, if not using the default; // second is the router. $app = AppFactory::create(null, $router); Piping the route middleware As a reminder, you will need to ensure that middleware is piped in the order in which it needs to be executed; please see the section on \"Controlling middleware execution order\" in the piping documentation . This is particularly salient when defining routes before injecting the router in the application instance! Factory-Driven Creation We recommend using an Inversion of Control container for your applications; as such, in this section we will demonstrate two strategies for creating your zend-mvc router implementation. Basic Router If you don't need to provide any setup or configuration, you can simply instantiate and return an instance of Zend\\Expressive\\Router\\ZendRouter for the service name Zend\\Expressive\\Router\\RouterInterface . A factory would look like this: // in src/App/Container/RouterFactory.php namespace App\\Container; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Router\\ZendRouter; class RouterFactory { /** * @param ContainerInterface $container * @return ZendRouter */ public function __invoke(ContainerInterface $container) { return new ZendRouter(); } } You would register this with zend-servicemanager using: $container->setFactory( Zend\\Expressive\\Router\\RouterInterface::class, App\\Container\\RouterFactory::class ); And in Pimple: $pimple[Zend\\Expressive\\Router\\RouterInterface::class] = new Application\\Container\\RouterFactory(); For zend-servicemanager, you can omit the factory entirely, and register the class as an invokable: $container->setInvokableClass( Zend\\Expressive\\Router\\RouterInterface::class, Zend\\Expressive\\Router\\ZendRouter::class ); Advanced Configuration If you want to provide custom setup or configuration, you can do so. In this example, we will be defining two factories: A factory to register as and generate an Zend\\Router\\Http\\TreeRouteStack instance. A factory registered as Zend\\Expressive\\Router\\RouterInterface , which creates and returns a Zend\\Expressive\\Router\\ZendRouter instance composing the Zend\\Mvc\\Router\\Http\\TreeRouteStack instance. Sound difficult? It's not; we've essentially done it above already! // in src/App/Container/TreeRouteStackFactory.php: namespace App\\Container; use Psr\\Container\\ContainerInterface; use Zend\\Http\\Router\\TreeRouteStack; class TreeRouteStackFactory { /** * @param ContainerInterface $container * @return TreeRouteStack */ public function __invoke(ContainerInterface $container) { $router = new TreeRouteStack(); $router->addPrototypes(/* ... */); $router->setBaseUrl(/* ... */); return $router; } } // in src/App/Container/RouterFactory.php namespace App\\Container; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge; class RouterFactory { /** * @param ContainerInterface $container * @return Zf2Bridge */ public function __invoke(ContainerInterface $container) { return new Zf2Bridge($container->get(Zend\\Mvc\\Router\\Http\\TreeRouteStack::class)); } } From here, you will need to register your factories with your IoC container. If you are using zend-servicemanager, this will look like: // Programmatically: use Zend\\ServiceManager\\ServiceManager; $container = new ServiceManager(); $container->addFactory( Zend\\Router\\Http\\TreeRouteStack::class, App\\Container\\TreeRouteStackFactory::class ); $container->addFactory( Zend\\Expressive\\Router\\RouterInterface::class, App\\Container\\RouterFactory::class ); // Alternately, via configuration: return [ 'factories' => [ Zend\\Router\\Http\\TreeRouteStack::class => App\\Container\\TreeRouteStackFactory::class, Zend\\Expressive\\Router\\RouterInterface::class => App\\Container\\RouterFactory::class, ], ]; For Pimple, configuration looks like: use Application\\Container\\TreeRouteStackFactory; use Application\\Container\\ZfRouterFactory; use Interop\\Container\\Pimple\\PimpleInterop; $container = new PimpleInterop(); $container[Zend\\Router\\Http\\TreeRouteStackFactory::class] = new TreeRouteStackFactory(); $container[Zend\\Expressive\\Router\\RouterInterface::class] = new RouterFactory();","title":"Using the ZF2 Router"},{"location":"v2/features/router/zf2/#using-the-zf2-router","text":"zend-router provides several router implementations used for ZF2+ applications; the default is Zend\\Router\\Http\\TreeRouteStack , which can compose a number of different routes of differing types in order to perform routing. The ZF2 bridge we provide, Zend\\Expressive\\Router\\ZendRouter , uses the TreeRouteStack , and injects Segment routes to it; these are in turn injected with Method routes, and a special \"method not allowed\" route at negative priority to enable us to distinguish between failure to match the path and failure to match the HTTP method. If you instantiate it with no arguments, it will create an empty TreeRouteStack . Thus, the simplest way to start with this router is: use Zend\\Expressive\\AppFactory; use Zend\\Expressive\\Router\\ZendRouter; $app = AppFactory::create(null, new ZendRouter()); The TreeRouteStack offers some unique features: Route \"prototypes\". These are essentially like child routes that must also match in order for a given route to match. These are useful for implementing functionality such as ensuring the request comes in over HTTPS, or over a specific subdomain. Base URL functionality. If a base URL is injected, comparisons will be relative to that URL. This is mostly unnecessary with Stratigility-based middleware, but could solve some edge cases. To specify these, you need access to the underlying TreeRouteStack instance, however, and the RouterInterface does not provide an accessor! The answer, then, is to use dependency injection. This can be done in two ways: programmatically, or via a factory to use in conjunction with your container instance.","title":"Using the ZF2 Router"},{"location":"v2/features/router/zf2/#installing-the-zf2-router","text":"To use the ZF2 router, you will need to install the zend-mvc router integration: $ composer require zendframework/zend-expressive-zendrouter","title":"Installing the ZF2 Router"},{"location":"v2/features/router/zf2/#quick-start","text":"At its simplest, you can instantiate a Zend\\Expressive\\Router\\ZendRouter instance with no arguments; it will create the underlying zend-mvc routing objects required and compose them for you: use Zend\\Expressive\\Router\\ZendRouter; $router = new ZendRouter();","title":"Quick Start"},{"location":"v2/features/router/zf2/#programmatic-creation","text":"If you need greater control over the zend-mvc router setup and configuration, you can create the instances necessary and inject them into Zend\\Expressive\\Router\\ZendRouter during instantiation. use Zend\\Expressive\\AppFactory; use Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge; use Zend\\Router\\Http\\TreeRouteStack; $zendRouter = new TreeRouteStack(); $zendRouter->addPrototypes(/* ... */); $zendRouter->setBaseUrl(/* ... */); $router = new Zf2Bridge($zendRouter); // First argument is the container to use, if not using the default; // second is the router. $app = AppFactory::create(null, $router);","title":"Programmatic Creation"},{"location":"v2/features/router/zf2/#factory-driven-creation","text":"We recommend using an Inversion of Control container for your applications; as such, in this section we will demonstrate two strategies for creating your zend-mvc router implementation.","title":"Factory-Driven Creation"},{"location":"v2/features/template/interface/","text":"The Template Renderer Interface Expressive defines Zend\\Expressive\\Template\\TemplateRendererInterface , which can be injected into middleware in order to create templated response bodies. The interface is defined as follows: namespace Zend\\Expressive\\Template; interface TemplateRendererInterface { /** * Render a template, optionally with parameters. * * Implementations MUST support the `namespace::template` naming convention, * and allow omitting the filename extension. * * @param string $name * @param array|object $params * @return string */ public function render($name, $params = []); /** * Add a template path to the engine. * * Adds a template path, with optional namespace the templates in that path * provide. * * @param string $path * @param string $namespace */ public function addPath($path, $namespace = null); /** * Retrieve configured paths from the engine. * * @return TemplatePath[] */ public function getPaths(); /** * Add a default parameter to use with a template. * * Use this method to provide a default parameter to use when a template is * rendered. The parameter may be overridden by providing it when calling * `render()`, or by calling this method again with a null value. * * The parameter will be specific to the template name provided. To make * the parameter available to any template, pass the TEMPLATE_ALL constant * for the template name. * * If the default parameter existed previously, subsequent invocations with * the same template name and parameter name will overwrite. * * @param string $templateName Name of template to which the param applies; * use TEMPLATE_ALL to apply to all templates. * @param string $param Param name. * @param mixed $value */ public function addDefaultParam($templateName, $param, $value); } Namespaces Unfortunately, namespace syntax varies between different template engine implementations. As an example: Plates uses the syntax namespace::template . Twig uses the syntax @namespace/template . zend-view does not natively support namespaces, though custom resolvers can provide the functionality. To make different engines compatible, we require implementations to support the syntax namespace::template (where namespace:: is optional) when rendering. Additionally, we require that engines allow omitting the filename suffix. When using a TemplateRendererInterface implementation, feel free to use namespaced templates, and to omit the filename suffix; this will make your code portable and allow it to use alternate template engines. Paths Most template engines and implementations will require that you specify one or more paths to templates; these are then used when resolving a template name to the actual template. You may use the addPath() method to do so: $renderer->addPath('templates'); Template engines adapted for zend-expressive are also required to allow namespacing templates; when adding a path, you specify the template namespace that it fulfills, and the engine will only return a template from that path if the namespace provided matches the namespace for the path. // Resolves to a path registered with the namespace \"error\"; // this example is specific to the Plates engine. $content = $renderer->render('error::404'); You can provide a namespace when registering a path via an optional second argument: // Registers the \"error\" namespace to the path \"templates/error/\" $renderer->addPath('templates/error/', 'error'); Rendering To render a template, call the render() method. This method requires the name of a template as the first argument: $content = $renderer->render('foo'); You can specify a namespaced template using the syntax namespace::template ; the template segment of the template name may use additional directory separators when necessary. One key reason to use templates is to dynamically provide data to inject in the template. You may do so by passing either an associative array or an object as the second argument to render() : $content = $renderer->render('message', [ 'greeting' => 'Hello', 'recipient' => 'World', ]); It is up to the underlying template engine to determine how to perform the injections. Default params The TemplateRendererInterface defines the method addDefaultParam() . This method can be used to specify default parameters to use when rendering a template. The signature is: public function addDefaultParam($templateName, $param, $value) If you want a parameter to be used for every template, you can specify the constant TemplateRendererInterface::TEMPLATE_ALL for the $templateName parameter. When rendering, parameters are considered in the following order, with later items having precedence over earlier ones: Default parameters specified for all templates. Default parameters specified for the template specified at rendering. Parameters specified when rendering. As an example, if we did the following: $renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'foo', 'bar'); $renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'bar', 'baz'); $renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'baz', 'bat'); $renderer->addDefaultParam('example', 'foo', 'template default foo'); $renderer->addDefaultParam('example', 'bar', 'template default bar'); $content = $renderer->render('example', [ 'foo' => 'override', ]); Then we can expect the following substitutions will occur when rendering: References to the \"foo\" variable will contain \"override\". References to the \"bar\" variable will contain \"template default bar\". References to the \"baz\" variable will contain \"bat\". Support for default params The support for default params will often be renderer-specific. The reason is because the render() signature does not specify a type for $params , in order to allow passing alternative arguments such as view models. In such cases, the implementation will indicate its behavior when default parameters are specified, but a given $params argument does not support it. At the time of writing, each of the Plates, Twig, and zend-view implementations support the feature.","title":"Template Renderer Interface"},{"location":"v2/features/template/interface/#the-template-renderer-interface","text":"Expressive defines Zend\\Expressive\\Template\\TemplateRendererInterface , which can be injected into middleware in order to create templated response bodies. The interface is defined as follows: namespace Zend\\Expressive\\Template; interface TemplateRendererInterface { /** * Render a template, optionally with parameters. * * Implementations MUST support the `namespace::template` naming convention, * and allow omitting the filename extension. * * @param string $name * @param array|object $params * @return string */ public function render($name, $params = []); /** * Add a template path to the engine. * * Adds a template path, with optional namespace the templates in that path * provide. * * @param string $path * @param string $namespace */ public function addPath($path, $namespace = null); /** * Retrieve configured paths from the engine. * * @return TemplatePath[] */ public function getPaths(); /** * Add a default parameter to use with a template. * * Use this method to provide a default parameter to use when a template is * rendered. The parameter may be overridden by providing it when calling * `render()`, or by calling this method again with a null value. * * The parameter will be specific to the template name provided. To make * the parameter available to any template, pass the TEMPLATE_ALL constant * for the template name. * * If the default parameter existed previously, subsequent invocations with * the same template name and parameter name will overwrite. * * @param string $templateName Name of template to which the param applies; * use TEMPLATE_ALL to apply to all templates. * @param string $param Param name. * @param mixed $value */ public function addDefaultParam($templateName, $param, $value); }","title":"The Template Renderer Interface"},{"location":"v2/features/template/interface/#paths","text":"Most template engines and implementations will require that you specify one or more paths to templates; these are then used when resolving a template name to the actual template. You may use the addPath() method to do so: $renderer->addPath('templates'); Template engines adapted for zend-expressive are also required to allow namespacing templates; when adding a path, you specify the template namespace that it fulfills, and the engine will only return a template from that path if the namespace provided matches the namespace for the path. // Resolves to a path registered with the namespace \"error\"; // this example is specific to the Plates engine. $content = $renderer->render('error::404'); You can provide a namespace when registering a path via an optional second argument: // Registers the \"error\" namespace to the path \"templates/error/\" $renderer->addPath('templates/error/', 'error');","title":"Paths"},{"location":"v2/features/template/interface/#rendering","text":"To render a template, call the render() method. This method requires the name of a template as the first argument: $content = $renderer->render('foo'); You can specify a namespaced template using the syntax namespace::template ; the template segment of the template name may use additional directory separators when necessary. One key reason to use templates is to dynamically provide data to inject in the template. You may do so by passing either an associative array or an object as the second argument to render() : $content = $renderer->render('message', [ 'greeting' => 'Hello', 'recipient' => 'World', ]); It is up to the underlying template engine to determine how to perform the injections.","title":"Rendering"},{"location":"v2/features/template/intro/","text":"Templating By default, no middleware in Expressive is templated. We do not even provide a default templating engine, as the choice of templating engine is often very specific to the project and/or organization. We do, however, provide abstraction for templating via the interface Zend\\Expressive\\Template\\TemplateRendererInterface , which allows you to write middleware that is engine-agnostic. For Expressive, this means: All adapters MUST support template namespacing. Namespaces MUST be referenced using the notation namespace::template when rendering. Adapters MUST allow rendering templates that omit the extension; they will, of course, resolve to whatever default extension they require (or as configured). Adapters SHOULD allow passing an extension in the template name, but how that is handled is left up to the adapter. Adapters SHOULD abstract layout capabilities. Many templating systems provide this out of the box, or similar, compatible features such as template inheritance. This should be transparent to end-users; they should be able to simply render a template and assume it has the full content to return. In this documentation, we'll detail the features of this interface, the various implementations we provide, and how you can configure, inject, and consume templating in your middleware. We currently support: Plates Twig zend-view Each has an associated container factory; details are found in the factories documentation .","title":"Introduction"},{"location":"v2/features/template/intro/#templating","text":"By default, no middleware in Expressive is templated. We do not even provide a default templating engine, as the choice of templating engine is often very specific to the project and/or organization. We do, however, provide abstraction for templating via the interface Zend\\Expressive\\Template\\TemplateRendererInterface , which allows you to write middleware that is engine-agnostic. For Expressive, this means: All adapters MUST support template namespacing. Namespaces MUST be referenced using the notation namespace::template when rendering. Adapters MUST allow rendering templates that omit the extension; they will, of course, resolve to whatever default extension they require (or as configured). Adapters SHOULD allow passing an extension in the template name, but how that is handled is left up to the adapter. Adapters SHOULD abstract layout capabilities. Many templating systems provide this out of the box, or similar, compatible features such as template inheritance. This should be transparent to end-users; they should be able to simply render a template and assume it has the full content to return. In this documentation, we'll detail the features of this interface, the various implementations we provide, and how you can configure, inject, and consume templating in your middleware. We currently support: Plates Twig zend-view Each has an associated container factory; details are found in the factories documentation .","title":"Templating"},{"location":"v2/features/template/middleware/","text":"Templated Middleware The primary use case for templating is within middleware, to provide templated responses. To do this, you will: Inject an instance of Zend\\Expressive\\Template\\TemplateRendererInterface into your middleware. Potentially add paths to the templating instance. Render a template. Add the results of rendering to your response. Injecting a TemplateRendererInterface We encourage the use of dependency injection. As such, we recommend writing your middleware to accept the TemplateRendererInterface via either the constructor or a setter. As an example: namespace Acme\\Blog; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class EntryMiddleware implements MiddlewareInterface { private $templateRenderer; public function __construct(TemplateRendererInterface $renderer) { $this->templateRenderer = $renderer; } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // ... } } This will necessitate having a factory for your middleware: namespace Acme\\Blog\\Container; use Acme\\Blog\\EntryMiddleware; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class EntryMiddlewareFactory { public function __invoke(ContainerInterface $container) { return new EntryMiddleware( $container->get(TemplateRendererInterface::class) ); } } And, of course, you'll need to tell your container to use the factory; see the container documentation for more information on how you might accomplish that. Consuming templates Now that we have the templating engine injected into our middleware, we can consume it. Most often, we will want to render a template, optionally with substitutions to pass to it. This will typically look like the following: namespace Acme\\Blog; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Template\\TemplateRendererInterface; class EntryMiddleware implements MiddlewareInterface { private $templateRenderer; public function __construct(TemplateRendererInterface $renderer) { $this->templateRenderer = $renderer; } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // do some work... return new HtmlResponse( $this->templateRenderer->render('blog::entry', [ 'entry' => $entry, ]) ); } }","title":"Templated Middleware"},{"location":"v2/features/template/middleware/#templated-middleware","text":"The primary use case for templating is within middleware, to provide templated responses. To do this, you will: Inject an instance of Zend\\Expressive\\Template\\TemplateRendererInterface into your middleware. Potentially add paths to the templating instance. Render a template. Add the results of rendering to your response.","title":"Templated Middleware"},{"location":"v2/features/template/middleware/#injecting-a-templaterendererinterface","text":"We encourage the use of dependency injection. As such, we recommend writing your middleware to accept the TemplateRendererInterface via either the constructor or a setter. As an example: namespace Acme\\Blog; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class EntryMiddleware implements MiddlewareInterface { private $templateRenderer; public function __construct(TemplateRendererInterface $renderer) { $this->templateRenderer = $renderer; } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // ... } } This will necessitate having a factory for your middleware: namespace Acme\\Blog\\Container; use Acme\\Blog\\EntryMiddleware; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class EntryMiddlewareFactory { public function __invoke(ContainerInterface $container) { return new EntryMiddleware( $container->get(TemplateRendererInterface::class) ); } } And, of course, you'll need to tell your container to use the factory; see the container documentation for more information on how you might accomplish that.","title":"Injecting a TemplateRendererInterface"},{"location":"v2/features/template/middleware/#consuming-templates","text":"Now that we have the templating engine injected into our middleware, we can consume it. Most often, we will want to render a template, optionally with substitutions to pass to it. This will typically look like the following: namespace Acme\\Blog; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Template\\TemplateRendererInterface; class EntryMiddleware implements MiddlewareInterface { private $templateRenderer; public function __construct(TemplateRendererInterface $renderer) { $this->templateRenderer = $renderer; } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // do some work... return new HtmlResponse( $this->templateRenderer->render('blog::entry', [ 'entry' => $entry, ]) ); } }","title":"Consuming templates"},{"location":"v2/features/template/plates/","text":"Using Plates Plates is a native PHP template system maintained by The League of Extraordinary Packages . it provides: Layout facilities. Template inheritance. Helpers for escaping, and the ability to provide custom helper extensions. We provide a TemplateRendererInterface wrapper for Plates via Zend\\Expressive\\Plates\\PlatesRenderer . Installing Plates To use the Plates wrapper, you must install the Plates integration: $ composer require zendframework/zend-expressive-platesrenderer Using the wrapper If instantiated without arguments, Zend\\Expressive\\Plates\\PlatesRenderer will create an instance of the Plates engine, which it will then proxy to. use Zend\\Expressive\\Plates\\PlatesRenderer; $renderer = new PlatesRenderer(); Alternately, you can instantiate and configure the engine yourself, and pass it to the Zend\\Expressive\\Plates\\PlatesRenderer constructor: use League\\Plates\\Engine as PlatesEngine; use Zend\\Expressive\\Plates\\PlatesRenderer; // Create the engine instance: $plates = new PlatesEngine(); // Configure it: $plates->addFolder('error', 'templates/error/'); $plates->loadExtension(new CustomExtension(); // Inject: $renderer = new PlatesRenderer($plates);","title":"Using Plates"},{"location":"v2/features/template/plates/#using-plates","text":"Plates is a native PHP template system maintained by The League of Extraordinary Packages . it provides: Layout facilities. Template inheritance. Helpers for escaping, and the ability to provide custom helper extensions. We provide a TemplateRendererInterface wrapper for Plates via Zend\\Expressive\\Plates\\PlatesRenderer .","title":"Using Plates"},{"location":"v2/features/template/plates/#installing-plates","text":"To use the Plates wrapper, you must install the Plates integration: $ composer require zendframework/zend-expressive-platesrenderer","title":"Installing Plates"},{"location":"v2/features/template/plates/#using-the-wrapper","text":"If instantiated without arguments, Zend\\Expressive\\Plates\\PlatesRenderer will create an instance of the Plates engine, which it will then proxy to. use Zend\\Expressive\\Plates\\PlatesRenderer; $renderer = new PlatesRenderer(); Alternately, you can instantiate and configure the engine yourself, and pass it to the Zend\\Expressive\\Plates\\PlatesRenderer constructor: use League\\Plates\\Engine as PlatesEngine; use Zend\\Expressive\\Plates\\PlatesRenderer; // Create the engine instance: $plates = new PlatesEngine(); // Configure it: $plates->addFolder('error', 'templates/error/'); $plates->loadExtension(new CustomExtension(); // Inject: $renderer = new PlatesRenderer($plates);","title":"Using the wrapper"},{"location":"v2/features/template/twig/","text":"Using Twig Twig is a template language and engine provided as a standalone component by SensioLabs. It provides: Layout facilities. Template inheritance. Helpers for escaping, and the ability to provide custom helper extensions. We provide a TemplateRendererInterface wrapper for Twig via Zend\\Expressive\\Twig\\TwigRenderer . Installing Twig To use the Twig wrapper, you must first install the Twig integration: $ composer require zendframework/zend-expressive-twigrenderer Using the wrapper If instantiated without arguments, Zend\\Expressive\\Twig\\TwigRenderer will create an instance of the Twig engine, which it will then proxy to. use Zend\\Expressive\\Twig\\TwigRenderer; $renderer = new TwigRenderer(); Alternately, you can instantiate and configure the engine yourself, and pass it to the Zend\\Expressive\\Twig\\TwigRenderer constructor: use Twig_Environment; use Twig_Loader_Array; use Zend\\Expressive\\Twig\\TwigRenderer; // Create the engine instance: $loader = new Twig_Loader_Array(include 'config/templates.php'); $twig = new Twig_Environment($loader); // Configure it: $twig->addExtension(new CustomExtension()); $twig->loadExtension(new CustomExtension(); // Inject: $renderer = new TwigRenderer($twig); Included extensions and functions The included Twig extension adds support for url generation. The extension is automatically activated if the UrlHelper and ServerUrlHelper are registered with the container. The following template functions are exposed: path : Render the relative path for a given route and parameters. If there is no route, it returns the current path. twig {{ path('article_show', {'id': '3'}) }} Generates: /article/3 url : Render the absolute url for a given route with its route parameters, query string arguments, and fragment. If there is no route, it returns the current url. twig {{ url('article_show', {'id': '3'}, {'foo': 'bar'}, 'fragment') }} Generates: http://example.com/article/3?foo=bar#fragment absolute_url : Render the absolute url from a given path. If the path is empty, it returns the current url. twig {{ absolute_url('path/to/something') }} Generates: http://example.com/path/to/something asset Render an (optionally versioned) asset url. twig {{ asset('path/to/asset/name.ext', version=3) }} Generates: path/to/asset/name.ext?v=3 To get the absolute url for an asset: twig {{ absolute_url(asset('path/to/asset/name.ext', version=3)) }} Generates: http://example.com/path/to/asset/name.ext?v=3 Configuration The following details configuration specific to Twig, as consumed by the TwigRendererFactory : return [ 'templates' => [ 'extension' => 'file extension used by templates; defaults to html.twig', 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ], 'twig' => [ 'cache_dir' => 'path to cached templates', 'assets_url' => 'base URL for assets', 'assets_version' => 'base version for assets', 'extensions' => [ // extension service names or instances ], 'globals' => [ // Global variables passed to twig templates 'ga_tracking' => 'UA-XXXXX-X' ], ], ]; When specifying the twig.extensions values, always use fully qualified class names or actual extension instances to ensure compatibility with any version of Twig used. Version 2 of Twig requires that a fully qualified class name is used, and not a short-name alias.","title":"Using Twig"},{"location":"v2/features/template/twig/#using-twig","text":"Twig is a template language and engine provided as a standalone component by SensioLabs. It provides: Layout facilities. Template inheritance. Helpers for escaping, and the ability to provide custom helper extensions. We provide a TemplateRendererInterface wrapper for Twig via Zend\\Expressive\\Twig\\TwigRenderer .","title":"Using Twig"},{"location":"v2/features/template/twig/#installing-twig","text":"To use the Twig wrapper, you must first install the Twig integration: $ composer require zendframework/zend-expressive-twigrenderer","title":"Installing Twig"},{"location":"v2/features/template/twig/#using-the-wrapper","text":"If instantiated without arguments, Zend\\Expressive\\Twig\\TwigRenderer will create an instance of the Twig engine, which it will then proxy to. use Zend\\Expressive\\Twig\\TwigRenderer; $renderer = new TwigRenderer(); Alternately, you can instantiate and configure the engine yourself, and pass it to the Zend\\Expressive\\Twig\\TwigRenderer constructor: use Twig_Environment; use Twig_Loader_Array; use Zend\\Expressive\\Twig\\TwigRenderer; // Create the engine instance: $loader = new Twig_Loader_Array(include 'config/templates.php'); $twig = new Twig_Environment($loader); // Configure it: $twig->addExtension(new CustomExtension()); $twig->loadExtension(new CustomExtension(); // Inject: $renderer = new TwigRenderer($twig);","title":"Using the wrapper"},{"location":"v2/features/template/twig/#included-extensions-and-functions","text":"The included Twig extension adds support for url generation. The extension is automatically activated if the UrlHelper and ServerUrlHelper are registered with the container. The following template functions are exposed: path : Render the relative path for a given route and parameters. If there is no route, it returns the current path. twig {{ path('article_show', {'id': '3'}) }} Generates: /article/3 url : Render the absolute url for a given route with its route parameters, query string arguments, and fragment. If there is no route, it returns the current url. twig {{ url('article_show', {'id': '3'}, {'foo': 'bar'}, 'fragment') }} Generates: http://example.com/article/3?foo=bar#fragment absolute_url : Render the absolute url from a given path. If the path is empty, it returns the current url. twig {{ absolute_url('path/to/something') }} Generates: http://example.com/path/to/something asset Render an (optionally versioned) asset url. twig {{ asset('path/to/asset/name.ext', version=3) }} Generates: path/to/asset/name.ext?v=3 To get the absolute url for an asset: twig {{ absolute_url(asset('path/to/asset/name.ext', version=3)) }} Generates: http://example.com/path/to/asset/name.ext?v=3","title":"Included extensions and functions"},{"location":"v2/features/template/twig/#configuration","text":"The following details configuration specific to Twig, as consumed by the TwigRendererFactory : return [ 'templates' => [ 'extension' => 'file extension used by templates; defaults to html.twig', 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ], 'twig' => [ 'cache_dir' => 'path to cached templates', 'assets_url' => 'base URL for assets', 'assets_version' => 'base version for assets', 'extensions' => [ // extension service names or instances ], 'globals' => [ // Global variables passed to twig templates 'ga_tracking' => 'UA-XXXXX-X' ], ], ]; When specifying the twig.extensions values, always use fully qualified class names or actual extension instances to ensure compatibility with any version of Twig used. Version 2 of Twig requires that a fully qualified class name is used, and not a short-name alias.","title":"Configuration"},{"location":"v2/features/template/zend-view/","text":"Using zend-view zend-view provides a native PHP template system via its PhpRenderer , and is maintained by Zend Framework. It provides: Layout facilities. Helpers for escaping, and the ability to provide custom helper extensions. We provide a TemplateRendererInterface wrapper for zend-view's PhpRenderer via Zend\\Expressive\\ZendView\\ZendViewRenderer . Installing zend-view To use the zend-view wrapper, you must first install the zend-view integration: $ composer require zendframework/zend-expressive-zendviewrenderer Using the wrapper If instantiated without arguments, Zend\\Expressive\\ZendView\\ZendViewRenderer will create an instance of the PhpRenderer , which it will then proxy to. use Zend\\Expressive\\ZendView\\ZendViewRenderer; $renderer = new ZendViewRenderer(); Alternately, you can instantiate and configure the engine yourself, and pass it to the Zend\\Expressive\\ZendView\\ZendViewRenderer constructor: use Zend\\Expressive\\ZendView\\ZendViewRenderer; use Zend\\View\\Renderer\\PhpRenderer; use Zend\\View\\Resolver; // Create the engine instance: $renderer = new PhpRenderer(); // Configure it: $resolver = new Resolver\\AggregateResolver(); $resolver->attach( new Resolver\\TemplateMapResolver(include 'config/templates.php'), 100 ); $resolver->attach( (new Resolver\\TemplatePathStack()) ->setPaths(include 'config/template_paths.php') ); $renderer->setResolver($resolver); // Inject: $renderer = new ZendViewRenderer($renderer); Namespaced path resolving Expressive defines a custom zend-view resolver, Zend\\Expressive\\ZendView\\NamespacedPathStackResolver . This resolver provides the ability to segregate paths by namespace, and later resolve a template according to the namespace, using the namespace::template notation required of TemplateRendererInterface implementations. The ZendView adapter ensures that: An AggregateResolver is registered with the renderer. If the registered resolver is not an AggregateResolver , it creates one and adds the original resolver to it. A NamespacedPathStackResolver is registered with the AggregateResolver , at a low priority (0), ensuring attempts to resolve hit it later. With resolvers such as the TemplateMapResolver , you can also resolve namespaced templates, mapping them directly to the template on the filesystem that matches; adding such a resolver can be a nice performance boost! Layouts Unlike the other supported template engines, zend-view does not support layouts out-of-the-box. Expressive abstracts this fact away, providing two facilities for doing so: You may pass a layout template name or Zend\\View\\Model\\ModelInterface instance representing the layout as the second argument to the constructor. You may pass a \"layout\" parameter during rendering, with a value of either a layout template name or a Zend\\View\\Model\\ModelInterface instance representing the layout. Passing a layout this way will override any layout provided to the constructor. In each case, the zend-view implementation will do a depth-first, recursive render in order to provide content within the selected layout. Since 1.3: You may also pass a boolean false value to either addDefaultParam() or via the template variables for the layout key; doing so will disable the layout. Layout name passed to constructor use Zend\\Expressive\\ZendView\\ZendViewRenderer; // Create the engine instance with a layout name: $renderer = new ZendViewRenderer(null, 'layout::layout'); Layout view model passed to constructor use Zend\\Expressive\\ZendView\\ZendViewRenderer; use Zend\\View\\Model\\ViewModel; // Create the layout view model: $layout = new ViewModel([ 'encoding' => 'utf-8', 'cssPath' => '/css/prod/', ]); $layout->setTemplate('layout::layout'); // Create the engine instance with the layout: $renderer = new ZendViewRenderer(null, $layout); Provide a layout name when rendering $content = $renderer->render('blog/entry', [ 'layout' => 'layout::blog', 'entry' => $entry, ]); Provide a layout view model when rendering use Zend\\View\\Model\\ViewModel; // Create the layout view model: $layout = new ViewModel([ 'encoding' => 'utf-8', 'cssPath' => '/css/blog/', ]); $layout->setTemplate('layout::layout'); $content = $renderer->render('blog/entry', [ 'layout' => $layout, 'entry' => $entry, ]); Helpers Expressive provides overrides of specific view helpers in order to better integrate with PSR-7 . These include: Zend\\Expressive\\ZendView\\UrlHelper . This helper consumes the application's Zend\\Expressive\\Router\\RouterInterface instance in order to generate URIs. Its signature is: url($routeName, array $routeParams = [], array $queryParams = [], $fragmentIdentifier = null, array $options = []) Zend\\Expressive\\ZendView\\ServerUrlHelper . This helper consumes the URI from the application's request in order to provide fully qualified URIs. Its signature is: serverUrl($path = null) . To use this particular helper, you will need to inject it with the request URI somewhere within your application: php $serverUrlHelper->setUri($request->getUri()); We recommend doing this within a pre-pipeline middleware. Recommendations We recommend the following practices when using the zend-view adapter: If using a layout, create a factory to return the layout view model as a service; this allows you to inject it into middleware and add variables to it. While we support passing the layout as a rendering parameter, be aware that if you change engines, this may not be supported.","title":"Using zend-view"},{"location":"v2/features/template/zend-view/#using-zend-view","text":"zend-view provides a native PHP template system via its PhpRenderer , and is maintained by Zend Framework. It provides: Layout facilities. Helpers for escaping, and the ability to provide custom helper extensions. We provide a TemplateRendererInterface wrapper for zend-view's PhpRenderer via Zend\\Expressive\\ZendView\\ZendViewRenderer .","title":"Using zend-view"},{"location":"v2/features/template/zend-view/#installing-zend-view","text":"To use the zend-view wrapper, you must first install the zend-view integration: $ composer require zendframework/zend-expressive-zendviewrenderer","title":"Installing zend-view"},{"location":"v2/features/template/zend-view/#using-the-wrapper","text":"If instantiated without arguments, Zend\\Expressive\\ZendView\\ZendViewRenderer will create an instance of the PhpRenderer , which it will then proxy to. use Zend\\Expressive\\ZendView\\ZendViewRenderer; $renderer = new ZendViewRenderer(); Alternately, you can instantiate and configure the engine yourself, and pass it to the Zend\\Expressive\\ZendView\\ZendViewRenderer constructor: use Zend\\Expressive\\ZendView\\ZendViewRenderer; use Zend\\View\\Renderer\\PhpRenderer; use Zend\\View\\Resolver; // Create the engine instance: $renderer = new PhpRenderer(); // Configure it: $resolver = new Resolver\\AggregateResolver(); $resolver->attach( new Resolver\\TemplateMapResolver(include 'config/templates.php'), 100 ); $resolver->attach( (new Resolver\\TemplatePathStack()) ->setPaths(include 'config/template_paths.php') ); $renderer->setResolver($resolver); // Inject: $renderer = new ZendViewRenderer($renderer);","title":"Using the wrapper"},{"location":"v2/features/template/zend-view/#layouts","text":"Unlike the other supported template engines, zend-view does not support layouts out-of-the-box. Expressive abstracts this fact away, providing two facilities for doing so: You may pass a layout template name or Zend\\View\\Model\\ModelInterface instance representing the layout as the second argument to the constructor. You may pass a \"layout\" parameter during rendering, with a value of either a layout template name or a Zend\\View\\Model\\ModelInterface instance representing the layout. Passing a layout this way will override any layout provided to the constructor. In each case, the zend-view implementation will do a depth-first, recursive render in order to provide content within the selected layout. Since 1.3: You may also pass a boolean false value to either addDefaultParam() or via the template variables for the layout key; doing so will disable the layout.","title":"Layouts"},{"location":"v2/features/template/zend-view/#helpers","text":"Expressive provides overrides of specific view helpers in order to better integrate with PSR-7 . These include: Zend\\Expressive\\ZendView\\UrlHelper . This helper consumes the application's Zend\\Expressive\\Router\\RouterInterface instance in order to generate URIs. Its signature is: url($routeName, array $routeParams = [], array $queryParams = [], $fragmentIdentifier = null, array $options = []) Zend\\Expressive\\ZendView\\ServerUrlHelper . This helper consumes the URI from the application's request in order to provide fully qualified URIs. Its signature is: serverUrl($path = null) . To use this particular helper, you will need to inject it with the request URI somewhere within your application: php $serverUrlHelper->setUri($request->getUri()); We recommend doing this within a pre-pipeline middleware.","title":"Helpers"},{"location":"v2/features/template/zend-view/#recommendations","text":"We recommend the following practices when using the zend-view adapter: If using a layout, create a factory to return the layout view model as a service; this allows you to inject it into middleware and add variables to it. While we support passing the layout as a rendering parameter, be aware that if you change engines, this may not be supported.","title":"Recommendations"},{"location":"v2/getting-started/features/","text":"Overview Expressive allows you to write PSR-7 middleware applications for the web. PSR-7 is a standard defining HTTP message interfaces; these are the incoming request and outgoing response for your application. By using PSR-7, we ensure that your applications will work in other PSR-7 contexts. Middleware is any code sitting between a request and a response; it typically analyzes the request to aggregate incoming data, delegates it to another layer to process, and then creates and returns a response. Middleware can and should be relegated only to those tasks, and should be relatively easy to write and maintain. Middleware is also designed for composability; you should be able to nest middleware and re-use middleware. With Expressive, you can build PSR-7-based middleware applications: APIs Websites Single Page Applications and more. Features Expressive builds on zend-stratigility to provide a robust convenience layer on which to build applications. The features it provides include: Routing Stratigility provides limited, literal matching only. Expressive allows you to utilize dynamic routing capabilities from a variety of routers, providing much more fine-grained matching capabilities. The routing layer also allows restricting matched routes to specific HTTP methods, and will return \"405 Not Allowed\" responses with an \"Allow\" HTTP header containing allowed HTTP methods for invalid requests. Routing is abstracted in Expressive, allowing the developer to choose the routing library that best fits the project needs. By default, we provide wrappers for Aura.Router, FastRoute, and the zend-mvc router. PSR-11 Container Expressive encourages the use of Dependency Injection, and defines its Application class to compose a PSR-11 ContainerInterface instance. The container is used to lazy-load middleware, whether it is piped (Stratigility interface) or routed (Expressive). Templating While Expressive does not assume templating is being used, it provides a templating abstraction. Developers can write middleware that typehints on this abstraction, and assume that the underlying adapter will provide layout support and namespaced template support. Error Handling Applications should handle errors gracefully, but also handle them differently in development versus production. Expressive provides both basic error handling via Stratigility's own ErrorHandler implementation, providing specialized error response generators that can perform templating or use Whoops. Flow Overview Below is a diagram detailing the workflow used by Expressive. The Application acts as an \"onion\"; in the diagram above, the top is the outer-most layer of the onion, while the bottom is the inner-most. The Application dispatches each middleware. Each middleware receives a request and a delegate for handing off processing of the request should the middleware not be able to fully process it itself. Internally, the delegate composes a queue of middleware, and invokes the next in the queue when invoked. Any given middleware can return a response , at which point execution winds its way back out the onion. Pipelines The terminology \"pipeline\" is often used to describe the onion. One way of looking at the \"onion\" is as a queue , which is first-in-first-out (FIFO) in operation. This means that the first middleware on the queue is executed first, and this invokes the next, and so on (and hence the \"next\" terminology). When looked at from this perspective: In most cases, the entire queue will not be traversed. The inner-most layer of the onion represents the last item in the queue, and should be guaranteed to return a response; usually this is indicative of a malformed request (HTTP 400 response status) and/or inability to route the middleware to a handler (HTTP 404 response status). Responses are returned back through the pipeline, in reverse order of traversal. Double pass middleware The system described above is what is known as lambda middleware . Each middleware receives the request and the delegate, and you pass only the request to the delegate when wanting to hand off processing: $$$$FENCED_CODE_BLOCK_5e03bde9ed1231.05442032 In Expressive 1.X, the default middleware style was what is known as double pass middleware. Double pass middleware receives both the request and a response in addition to the delegate, and passes both the request and response to the delegate when invoking it: $$$$FENCED_CODE_BLOCK_5e03bde9ed1365.46867770 It is termed \"double pass\" because you pass both the request and response when delegating to the next layer. Expressive 2.X still supports double-pass middleware, though we recommend the lambda style. The Application allows arbitrary middleware to be injected, with each being executed in the order in which they are attached; returning a response from middleware prevents any middleware attached later from executing. You can attach middleware manually, in which case the pipeline is executed in the order of attachment, or use configuration. When you use configuration, you will specify a priority integer to dictate the order in which middleware should be attached. Middleware specifying high integer priorities are attached (and thus executed) earlier, while those specifying lower and/or negative integers are attached later. The default priority is 1. Expressive provides default implementations of \"routing\" and \"dispatch\" middleware, which you either attach to the middleware pipeline manually, or via configuration. These are implemented as the classes Zend\\Expressive\\Middleware\\RouteMiddleware and Zend\\Expressive\\Middleware\\DispatchMiddleware , respectively. Routing within Expressive consists of decomposing the request to match it to middleware that can handle that given request. This typically consists of a combination of matching the requested URI path along with allowed HTTP methods: map a GET request to the path /api/ping to the PingMiddleware map a POST request to the path /contact/process to the HandleContactMiddleware etc. Dispatching is simply the act of calling the middleware mapped by routing. The two events are modeled as separate middleware to allow you to act on the results of routing before attempting to dispatch the mapped middleware; this can be useful for implementing route-based authentication or validation. The majority of your application will consist of routing rules that map to routed middleware. Middleware piped to the application earlier than routing should be middleware that you wish to execute for every request. These might include: bootstrapping parsing of request body parameters addition of debugging tools embedded Expressive applications that you want to match at a given literal path etc. Such middleware may decide that a request is invalid, and return a response; doing so means no further middleware will be executed! This is an important feature of middleware architectures, as it allows you to define application-specific workflows optimized for performance, security, etc. Middleware piped to the application after the routing and dispatch middleware will execute in one of two conditions: routing failed routed middleware called on the next middleware instead of returning a response. As such, the largest use case for such middleware is to provide a \"default\" error response for your application, usually as an HTTP 404 Not Found response. The main points to remember are: The application is a queue, and operates in FIFO order. Each middleware can choose whether to return a response, which will cause the queue to unwind, or to traverse to the next middleware. Most of the time, you will be defining routed middleware , and the routing rules that map to them. You get to control the workflow of your application by deciding the order in which middleware is queued.","title":"Overview and Features"},{"location":"v2/getting-started/features/#overview","text":"Expressive allows you to write PSR-7 middleware applications for the web. PSR-7 is a standard defining HTTP message interfaces; these are the incoming request and outgoing response for your application. By using PSR-7, we ensure that your applications will work in other PSR-7 contexts. Middleware is any code sitting between a request and a response; it typically analyzes the request to aggregate incoming data, delegates it to another layer to process, and then creates and returns a response. Middleware can and should be relegated only to those tasks, and should be relatively easy to write and maintain. Middleware is also designed for composability; you should be able to nest middleware and re-use middleware. With Expressive, you can build PSR-7-based middleware applications: APIs Websites Single Page Applications and more.","title":"Overview"},{"location":"v2/getting-started/features/#features","text":"Expressive builds on zend-stratigility to provide a robust convenience layer on which to build applications. The features it provides include: Routing Stratigility provides limited, literal matching only. Expressive allows you to utilize dynamic routing capabilities from a variety of routers, providing much more fine-grained matching capabilities. The routing layer also allows restricting matched routes to specific HTTP methods, and will return \"405 Not Allowed\" responses with an \"Allow\" HTTP header containing allowed HTTP methods for invalid requests. Routing is abstracted in Expressive, allowing the developer to choose the routing library that best fits the project needs. By default, we provide wrappers for Aura.Router, FastRoute, and the zend-mvc router. PSR-11 Container Expressive encourages the use of Dependency Injection, and defines its Application class to compose a PSR-11 ContainerInterface instance. The container is used to lazy-load middleware, whether it is piped (Stratigility interface) or routed (Expressive). Templating While Expressive does not assume templating is being used, it provides a templating abstraction. Developers can write middleware that typehints on this abstraction, and assume that the underlying adapter will provide layout support and namespaced template support. Error Handling Applications should handle errors gracefully, but also handle them differently in development versus production. Expressive provides both basic error handling via Stratigility's own ErrorHandler implementation, providing specialized error response generators that can perform templating or use Whoops.","title":"Features"},{"location":"v2/getting-started/features/#flow-overview","text":"Below is a diagram detailing the workflow used by Expressive. The Application acts as an \"onion\"; in the diagram above, the top is the outer-most layer of the onion, while the bottom is the inner-most. The Application dispatches each middleware. Each middleware receives a request and a delegate for handing off processing of the request should the middleware not be able to fully process it itself. Internally, the delegate composes a queue of middleware, and invokes the next in the queue when invoked. Any given middleware can return a response , at which point execution winds its way back out the onion.","title":"Flow Overview"},{"location":"v2/getting-started/skeleton/","text":"Quick Start: Using the Skeleton + Installer The easiest way to get started with Expressive is to use the skeleton application and installer . The skeleton provides a generic structure for creating your applications, and prompts you to choose a router, dependency injection container, template renderer, and error handler from the outset. Create a new project First, we'll create a new project, using Composer's create-project command: $ composer create-project zendframework/zend-expressive-skeleton expressive This will prompt you to choose: Whether to install a minimal skeleton (no default middleware), a flat application structure (all code under src/ ), or a modular structure (directories under src/ are modules, each with source code and potentially templates, configuration, assets, etc.). A dependency injection container. We recommend using the default, Zend ServiceManager. (We use ServiceManager in the examples below, so choose it if you want to code along). A router. We recommend using the default, FastRoute. A template renderer. You can ignore this when creating an API project, but if you will be creating any HTML pages, we recommend installing one. (We use Plates in the examples below, so choose it if you want to code along). An error handler. Whoops is a very nice option for development, as it gives you extensive, browseable information for exceptions and errors raised. Start a web server The Skeleton + Installer creates a full application structure that's ready-to-go when complete. You can test it out using built-in web server . From the project root directory, execute the following: $ composer run --timeout=0 serve This starts up a web server on localhost port 8080; browse to http://localhost:8080/ to see if your application responds correctly! Setting a timeout Composer commands time out after 300 seconds (5 minutes). On Linux-based systems, the php -S command that composer serve spawns continues running as a background process, but on other systems halts when the timeout occurs. As such, we recommend running the serve script using a timeout. This can be done by using composer run to execute the serve script, with a --timeout option. When set to 0 , as in the previous example, no timeout will be used, and it will run until you cancel the process (usually via Ctrl-C ). Alternately, you can specify a finite timeout; as an example, the following will extend the timeout to a full day: $$$$FENCED_CODE_BLOCK_5e03bde9ed4d50.19381455 Development Tools We ship tools in our skeleton application to make development easier. Development Mode zf-development-mode allows you to enable and disable development mode from your cli. $ composer development-enable # enable development mode $ composer development-disable # disable development mode $ composer development-status # show development status The development configuration is set in config/autoload/development.local.php.dist . It also allows you to specify configuration and modules that should only be enabled when in development, and not when in production. Clear config cache Production settings are the default, which means enabling the configuration cache. However, it must be easy for developers to clear the configuration cache. That's what this command does. $ composer clear-config-cache Testing Your Code PHPUnit and PHP_CodeSniffer are now installed by default. To execute tests and detect coding standards violations, run the following command: $ composer check Security Advisories We have included the security-advisories package to notify you about installed dependencies with known security vulnerabilities. Each time you run composer update , composer install , or composer require , it prevents installation of software with known and documented security issues. Modules Composer will prompt you during installation to ask if you want a minimal application (no structure or default middleware provided), flat application (all source code under the same tree, and the default selection), or modular application. This latter option is new in the version 2 series, and allows you to segregate discrete areas of application functionality into modules , which can contain source code, templates, assets, and more; these can later be repackaged for re-use if desired. Support for modules is available via the zend-component-installer and zend-config-aggregator packages; the zend-expressive-tooling . package provides tools for creating and manipulating modules in your application. Component Installer Whenever you add a component or module that exposes itself as such, the zend-component-installer composer plugin will prompt you, asking if and where you want to inject its configuration. This ensures that components are wired automatically for you. In most cases, you will choose to inject in the config/config.php file; for tools intended only for usage during development, choose config/development.config.php.dist . Config Aggregator The zend-config-aggregator library collects and merges configuration from different sources. It also supports configuration caching. As an example, your config/config.php file might read as follows in order to aggregate configuration from development mode settings, application configuration, and theoretical User , Blog , and App modules: <?php // config/config.php $aggregator = new ConfigAggregator([ // Module configuration App\\ConfigProvider::class, BlogModule\\ConfigProvider::class, UserModule\\ConfigProvider::class, // Load application config in a pre-defined order in such a way that local settings // overwrite global settings. (Loaded as first to last): // - `global.php` // - `*.global.php` // - `local.php` // - `*.local.php` new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'), // Load development config if it exists new PhpFileProvider('config/development.config.php'), ], 'data/config-cache.php'); return $aggregator->getMergedConfig(); The configuration is merged in the same order as it is passed, with later entries having precedence. Config Providers ConfigAggregator works by aggregating \"Config Providers\" passed to its constructor. Each provider should be a callable class that requires no constructor parameters, where invocation returns a configuration array (or a PHP generator) to be merged. Libraries or modules can have configuration providers that provide default values for a library or module. For the UserModule\\ConfigProvider class loaded in the ConfigAggregator above, the ConfigProvider might look like this: <?php namespace UserModule; class ConfigProvider { /** * Returns the configuration array * * To add some sort of a structure, each section is defined in a separate * method which returns an array with its configuration. * * @return array */ public function __invoke() { return [ 'dependencies' => $this->getDependencies(), 'users' => $this->getConfig(), ]; } /** * Returns the container dependencies * * @return array */ public function getDependencies() { return [ 'factories' => [ Action\\LoginAction::class => Factory\\Action\\LoginActionFactory::class, Middleware\\AuthenticationMiddleware::class => Factory\\Middleware\\AuthenticationMiddlewareFactory::class, ], ]; } /** * Returns the default module configuration * * @return array */ public function getConfig() { return [ 'paths' => [ 'enable_registration' => true, 'enable_username' => false, 'enable_display_name' => true, ], ]; } } expressive-module command To aid in the creation, registration, and deregistration of modules in your application, the installer will add the zendframework/zend-expressive-tooling as a development requirement when you choose the modular application layout. The tool is available from your application root directory via ./vendor/bin/expressive-module . For brevity, we will only reference the tool's name, expressive-module , when describing its capabilities. This tool provides the following functionality: expressive-module create <modulename> will create the default directory structure for the named module, create a ConfigProvider for the module, add an autoloading rule to composer.json , and register the ConfigProvider with the application configuration. expressive-module register <modulename> will add an autoloading rule to composer.json for the module, and register its ConfigProvider , if found, with the application configuration. expressive-module deregister <modulename> will remove any autoloading rules for the module from composer.json , and deregister its ConfigProvider , if found, from the application configuration. You can find out more about its features in the command line tooling documentation . Adding Middleware The skeleton makes the assumption that you will be writing your middleware as classes, and uses piping and routing to add your middleware. Piping Piping is a foundation feature of the underlying zend-stratigility implementation. You can setup the middleware pipeline in config/pipeline.php . In this section, we'll demonstrate setting up a basic pipeline that includes error handling, segregated applications, routing, middleware dispatch, and more. The error handler should be the first (most outer) middleware to catch all exceptions. $app->pipe(ErrorHandler::class); $app->pipe(ServerUrlMiddleware::class); After the ErrorHandler you can pipe more middleware that you want to execute on every request, such as bootstrapping, pre-conditions, and modifications to outgoing responses: $app->pipe(ServerUrlMiddleware::class); Piped middleware may be either callables or service names. Middleware may also be passed as an array; each item in the array must resolve to middleware eventually (i.e., callable or service name); underneath, Expressive creates Zend\\Stratigility\\MiddlewarePipe instances with each of the middleware listed piped to it. Middleware can be attached to specific paths, allowing you to mix and match applications under a common domain. The handlers in each middleware attached this way will see a URI with the MATCHED PATH SEGMENT REMOVED!!! $app->pipe('/api', $apiMiddleware); $app->pipe('/docs', $apiDocMiddleware); $app->pipe('/files', $filesMiddleware); Next, you should register the routing middleware in the middleware pipeline: $app->pipeRoutingMiddleware(); Add more middleware that needs to introspect the routing results; this might include: handling for HTTP HEAD requests handling for HTTP OPTIONS requests middleware for handling URI generation route-based authentication route-based validation etc. $app->pipe(ImplicitHeadMiddleware::class); $app->pipe(ImplicitOptionsMiddleware::class); $app->pipe(UrlHelperMiddleware::class); Next, register the dispatch middleware in the middleware pipeline: $app->pipeDispatchMiddleware(); At this point, if no response is return by any middleware, we need to provide a way of notifying the user of this; by default, we use the NotFoundHandler , but you can provide any other fallback middleware you wish: $app->pipe(NotFoundHandler::class); The full example then looks something like this: // In config/pipeline.php: use Zend\\Expressive\\Helper\\ServerUrlMiddleware; use Zend\\Expressive\\Helper\\UrlHelperMiddleware; use Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware; use Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware; use Zend\\Expressive\\Middleware\\NotFoundHandler; use Zend\\Stratigility\\Middleware\\ErrorHandler; $app->pipe(ErrorHandler::class); $app->pipe(ServerUrlMiddleware::class); // These assume that the variables listed are defined in this scope: $app->pipe('/api', $apiMiddleware); $app->pipe('/docs', $apiDocMiddleware); $app->pipe('/files', $filesMiddleware); $app->pipeRoutingMiddleware(); $app->pipe(ImplicitHeadMiddleware::class); $app->pipe(ImplicitOptionsMiddleware::class); $app->pipe(UrlHelperMiddleware::class); $app->pipeDispatchMiddleware(); $app->pipe(NotFoundHandler::class); Routing Routing is an additional feature provided by Expressive. Routing is setup in config/routes.php . You can setup routes with a single request method: $app->get('/', App\\Action\\HomePageAction::class, 'home'); $app->post('/album', App\\Action\\AlbumCreateAction::class, 'album.create'); $app->put('/album/:id', App\\Action\\AlbumUpdateAction::class, 'album.put'); $app->patch('/album/:id', App\\Action\\AlbumUpdateAction::class, 'album.patch'); $app->delete('/album/:id', App\\Action\\AlbumDeleteAction::class, 'album.delete'); Or with multiple request methods: $app->route('/contact', App\\Action\\ContactAction::class, ['GET', 'POST', ...], 'contact'); Or handling all request methods: $app->route('/contact', App\\Action\\ContactAction::class)->setName('contact'); Alternately, to be explicit, the above could be written as: $app->route( '/contact', App\\Action\\ContactAction::class, Zend\\Expressive\\Router\\Route::HTTP_METHOD_ANY, 'contact' ); We recommend a single middleware class per combination of route and request method. Next Steps The skeleton provides a default structure for templates, if you choose to use them. Let's see how you can create your first vanilla middleware, and templated middleware. Creating middleware To create middleware, create a class implementing Interop\\Http\\ServerMiddleware\\MiddlewareInterface . This interface defines a single method, process() , which accepts a Psr\\Http\\Message\\ServerRequestInterface instance and an Interop\\Http\\ServerMiddleware\\DelegateInterface instance. Legacy double-pass middleware Prior to Expressive 2.0, the default middleware style was what is termed \"double-pass\", for the fact that it passes both the request and response between layers. This middleware did not require an interface, and relied on a conventional definition of: $$$$FENCED_CODE_BLOCK_5e03bde9ed4ee5.33347836 While this style of middleware is still quite wide-spread and used in a number of projects, it has some flaws. Chief among them is the fact that middleware should not rely on the $response instance provided to them (as it may have modifications unacceptable for the current context), and that a response returned from inner layers may not be based off the $response provided to them (as inner layers may create and return a completely different response). Starting in Expressive 2.0, we add support for http-interop/http-middleware , which is a working group of PHP-FIG dedicated to creating a common middleware standard. This middleware uses what is termed a \"single-pass\" or \"lambda\" architecture, whereby only the request instance is passed between layers. We now recommend writing middleware using the http-middleware interfaces for all new middleware. Middleware using the double-pass style is still accepted by Expressive, but support for it will be discontinued with version 3. The skeleton defines an App namespace for you, and suggests placing middleware under the namespace App\\Action . Let's create a \"Hello\" action. Place the following in src/App/Action/HelloAction.php : <?php namespace App\\Action; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\HtmlResponse; class HelloAction implements MiddlewareInterface { public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // On all PHP versions: $query = $request->getQueryParams(); $target = isset($query['target']) ? $query['target'] : 'World'; // Or, on PHP 7+: $target = $request->getQueryParams()['target'] ?? 'World'; $target = htmlspecialchars($target, ENT_HTML5, 'UTF-8'); return new HtmlResponse(sprintf( '<h1>Hello, %s!</h1>', $target )); } } The above looks for a query string parameter \"target\", and uses its value to provide a message, which is then returned in an HTML response. Now we need to inform the application of this middleware, and indicate what path will invoke it. Open the file config/autoload/dependencies.global.php . Edit that file to add an invokable entry for the new middleware: return [ 'dependencies' => [ /* ... */ 'invokables' => [ App\\Action\\HelloAction::class => App\\Action\\HelloAction::class, /* ... */ ], /* ... */ ], ]; Now open the file config/routes.php , and add the following at the bottom of the file: $app->get('/hello', App\\Action\\HelloAction::class, 'hello'); Once you've completed the above, give it a try by going to each of the following URIs: http://localhost:8080/hello http://localhost:8080/hello?target=ME You should see the message change as you go between the two URIs! Using templates You likely don't want to hardcode HTML into your middleware; so, let's use templates. This particular exercise assumes you chose to use the Plates integration. Templates are installed under the templates/ subdirectory. By default, we also register the template namespace app to correspond with the templates/app subdirectory. Create the file templates/app/hello-world.phtml with the following contents: <?php $this->layout('layout::default', ['title' => 'Greetings']) ?> <h2>Hello, <?= $this->e($target) ?></h2> Now that we have a template, we need to: Inject a renderer into our action class. Use the renderer to render the contents. Replace your src/App/Action/HelloAction.php file with the following contents: <?php namespace App\\Action; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Template\\TemplateRendererInterface; class HelloAction implements MiddlewareInterface { private $renderer; public function __construct(TemplateRendererInterface $renderer) { $this->renderer = $renderer; } public function process(ServerRequestInterface $request, DelegateInterface $delegate) { // On all PHP versions: $query = $request->getQueryParams(); $target = isset($query['target']) ? $query['target'] : 'World'; // Or, on PHP 7+: $target = $request->getQueryParams()['target'] ?? 'World'; return new HtmlResponse( $this->renderer->render('app::hello-world', ['target' => $target]) ); } } The above modifies the class to accept a renderer to the constructor, and then calls on it to render a template. Note that we no longer need to escape our target; the template takes care of that for us. How does the template renderer get into the action? The answer is dependency injection. For the next part of the example, we'll be creating and wiring a factory for creating the HelloAction instance; the example assumes you used the default selection for a dependency injection container, zend-servicemanager. zend-servicemanager provides a console (command line) tool for generating factories based on reflecting a class; we'll use that to generate our factory. Navigate to your root skeleton-app directory in the console and enter the following: $ ./vendor/bin/generate-factory-for-class \\ > \"App\\\\Action\\\\HelloAction\" > ./src/App/src/Action/HelloActionFactory.php For more information see generate-factory-for-class With that in place, we'll now update our configuration. Open the file config/autoload/dependencies.global.php ; we'll remove the invokables entry we created previously, and add a factories entry: return [ 'dependencies' => [ /* ... */ 'invokables' => [ // Remove this entry: App\\Action\\HelloAction::class => App\\Action\\HelloAction::class, ], 'factories' => [ /* ... */ // Add this: App\\Action\\HelloAction::class => App\\Action\\HelloActionFactory::class, ], /* ... */ ], ]; Save that file, and now re-visit the URIs: http://localhost:8080/hello http://localhost:8080/hello?target=ME Your page should now have the same layout as the landing page of the skeleton application! Congratulations! Congratulations! You've now created your application, and started writing middleware! It's time to start learning about the rest of the features of Expressive: Containers Routing Templating Error Handling","title":"Quick Start: Skeleton Installer"},{"location":"v2/getting-started/skeleton/#quick-start-using-the-skeleton-installer","text":"The easiest way to get started with Expressive is to use the skeleton application and installer . The skeleton provides a generic structure for creating your applications, and prompts you to choose a router, dependency injection container, template renderer, and error handler from the outset.","title":"Quick Start: Using the Skeleton + Installer"},{"location":"v2/getting-started/skeleton/#create-a-new-project","text":"First, we'll create a new project, using Composer's create-project command: $ composer create-project zendframework/zend-expressive-skeleton expressive This will prompt you to choose: Whether to install a minimal skeleton (no default middleware), a flat application structure (all code under src/ ), or a modular structure (directories under src/ are modules, each with source code and potentially templates, configuration, assets, etc.). A dependency injection container. We recommend using the default, Zend ServiceManager. (We use ServiceManager in the examples below, so choose it if you want to code along). A router. We recommend using the default, FastRoute. A template renderer. You can ignore this when creating an API project, but if you will be creating any HTML pages, we recommend installing one. (We use Plates in the examples below, so choose it if you want to code along). An error handler. Whoops is a very nice option for development, as it gives you extensive, browseable information for exceptions and errors raised.","title":"Create a new project"},{"location":"v2/getting-started/skeleton/#start-a-web-server","text":"The Skeleton + Installer creates a full application structure that's ready-to-go when complete. You can test it out using built-in web server . From the project root directory, execute the following: $ composer run --timeout=0 serve This starts up a web server on localhost port 8080; browse to http://localhost:8080/ to see if your application responds correctly!","title":"Start a web server"},{"location":"v2/getting-started/skeleton/#development-tools","text":"We ship tools in our skeleton application to make development easier.","title":"Development Tools"},{"location":"v2/getting-started/skeleton/#modules","text":"Composer will prompt you during installation to ask if you want a minimal application (no structure or default middleware provided), flat application (all source code under the same tree, and the default selection), or modular application. This latter option is new in the version 2 series, and allows you to segregate discrete areas of application functionality into modules , which can contain source code, templates, assets, and more; these can later be repackaged for re-use if desired. Support for modules is available via the zend-component-installer and zend-config-aggregator packages; the zend-expressive-tooling . package provides tools for creating and manipulating modules in your application.","title":"Modules"},{"location":"v2/getting-started/skeleton/#adding-middleware","text":"The skeleton makes the assumption that you will be writing your middleware as classes, and uses piping and routing to add your middleware.","title":"Adding Middleware"},{"location":"v2/getting-started/skeleton/#next-steps","text":"The skeleton provides a default structure for templates, if you choose to use them. Let's see how you can create your first vanilla middleware, and templated middleware.","title":"Next Steps"},{"location":"v2/getting-started/skeleton/#congratulations","text":"Congratulations! You've now created your application, and started writing middleware! It's time to start learning about the rest of the features of Expressive: Containers Routing Templating Error Handling","title":"Congratulations!"},{"location":"v2/getting-started/standalone/","text":"Quick Start: Standalone Usage Expressive allows you to get started at your own pace. You can start with the simplest example, detailed below, or move on to a more structured, configuration-driven approach as detailed in the use case examples . Deprecated with version 2.2 The Zend\\Expressive\\AppFactory detailed in this chapter is deprecated as of version 2.2, and will be removed in version 3.0. We recommend instead constructing Zend\\Expressive\\Application manually, or using a Zend\\Stratigility\\MiddlewarePipe instance instead. 1. Create a new project directory First, let's create a new project directory and enter it: $ mkdir expressive $ cd expressive 2. Install Expressive If you haven't already, install Composer . Once you have, we can install Expressive, along with a router and a container: $ composer require zendframework/zend-expressive zendframework/zend-expressive-fastroute zendframework/zend-servicemanager Routers Expressive needs a routing implementation in order to create routed middleware. We suggest FastRoute in the quick start, but you can also currently choose from Aura.Router and zend-router. Containers We highly recommend using dependency injection containers with Expressive; they allow you to define dependencies for your middleware, as well as to lazy load your middleware only when it needs to be executed. We suggest zend-servicemanager in the quick start, but you can also use any container supporting PSR-11 Container . 3. Create a web root directory You'll need a directory from which to serve your application, and for security reasons, it's a good idea to keep it separate from your source code. We'll create a public/ directory for this: $ mkdir public 4. Create your bootstrap script Next, we'll create a bootstrap script. Such scripts typically setup the environment, setup the application, and invoke it. This needs to be in our web root, and we want it to intercept any incoming request; as such, we'll use public/index.php : <?php use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Zend\\Diactoros\\Response\\TextResponse; use Zend\\Expressive\\AppFactory; chdir(dirname(__DIR__)); require 'vendor/autoload.php'; $app = AppFactory::create(); $app->get('/', function ($request, DelegateInterface $delegate) { return new TextResponse('Hello, world!'); }); $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); $app->run(); Rewriting URLs Many web servers will not rewrite URLs to the bootstrap script by default. If you use Apache, for instance, you'll need to setup rewrite rules to ensure your bootstrap is invoked for unknown URLs. We'll cover that in a later chapter. Routing and dispatching Note the lines from the above: $$$$FENCED_CODE_BLOCK_5e03bde9ed2d08.16508985 Expressive's Application class provides two separate middlewares, one for routing, and one for dispatching middleware matched by routing. This allows you to slip in validations between the two activities if desired. They are not automatically piped to the application, however, to allow exactly that situation, which means they must be piped manually. 5. Start a web server Since we're just testing out the basic functionality of our application, we'll use PHP's built-in web server . From the project root directory, execute the following: $ php -S 0.0.0.0:8080 -t public/ This starts up a web server on localhost port 8080; browse to http://localhost:8080/ to see if your application responds correctly! Tip: Serve via Composer To simplify starting up a local web server, try adding the following to your composer.json : $$$$FENCED_CODE_BLOCK_5e03bde9ed2df6.39263431 Once you've added that, you can fire up the web server using: $$$$FENCED_CODE_BLOCK_5e03bde9ed2eb2.86234298 Setting a timeout Composer commands time out after 300 seconds (5 minutes). On Linux-based systems, the php -S command that composer serve spawns continues running as a background process, but on other systems halts when the timeout occurs. As such, we recommend running the serve script using a timeout. This can be done by using composer run to execute the serve script, with a --timeout option. When set to 0 , as in the previous example, no timeout will be used, and it will run until you cancel the process (usually via Ctrl-C ). Alternately, you can specify a finite timeout; as an example, the following will extend the timeout to a full day: $$$$FENCED_CODE_BLOCK_5e03bde9ed2f60.16339639 Next steps At this point, you have a working zend-expressive application, that responds to a single route. From here, you may want to read up on: Applications Containers Routing Templating Error Handling Additionally, we have more use case examples .","title":"Quick Start: Standalone"},{"location":"v2/getting-started/standalone/#quick-start-standalone-usage","text":"Expressive allows you to get started at your own pace. You can start with the simplest example, detailed below, or move on to a more structured, configuration-driven approach as detailed in the use case examples .","title":"Quick Start: Standalone Usage"},{"location":"v2/getting-started/standalone/#1-create-a-new-project-directory","text":"First, let's create a new project directory and enter it: $ mkdir expressive $ cd expressive","title":"1. Create a new project directory"},{"location":"v2/getting-started/standalone/#2-install-expressive","text":"If you haven't already, install Composer . Once you have, we can install Expressive, along with a router and a container: $ composer require zendframework/zend-expressive zendframework/zend-expressive-fastroute zendframework/zend-servicemanager","title":"2. Install Expressive"},{"location":"v2/getting-started/standalone/#3-create-a-web-root-directory","text":"You'll need a directory from which to serve your application, and for security reasons, it's a good idea to keep it separate from your source code. We'll create a public/ directory for this: $ mkdir public","title":"3. Create a web root directory"},{"location":"v2/getting-started/standalone/#4-create-your-bootstrap-script","text":"Next, we'll create a bootstrap script. Such scripts typically setup the environment, setup the application, and invoke it. This needs to be in our web root, and we want it to intercept any incoming request; as such, we'll use public/index.php : <?php use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Zend\\Diactoros\\Response\\TextResponse; use Zend\\Expressive\\AppFactory; chdir(dirname(__DIR__)); require 'vendor/autoload.php'; $app = AppFactory::create(); $app->get('/', function ($request, DelegateInterface $delegate) { return new TextResponse('Hello, world!'); }); $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); $app->run();","title":"4. Create your bootstrap script"},{"location":"v2/getting-started/standalone/#5-start-a-web-server","text":"Since we're just testing out the basic functionality of our application, we'll use PHP's built-in web server . From the project root directory, execute the following: $ php -S 0.0.0.0:8080 -t public/ This starts up a web server on localhost port 8080; browse to http://localhost:8080/ to see if your application responds correctly!","title":"5. Start a web server"},{"location":"v2/getting-started/standalone/#next-steps","text":"At this point, you have a working zend-expressive application, that responds to a single route. From here, you may want to read up on: Applications Containers Routing Templating Error Handling Additionally, we have more use case examples .","title":"Next steps"},{"location":"v2/reference/cli-tooling/","text":"Command Line Tooling Expressive offers a number of tools for assisting in project development. This page catalogues each. Development Mode The package zfcampus/zf-development-mode provides a simple way to toggle in and out of development mode . Doing so allows you to ship known development-specific settings within your repository, while ensuring they are not enabled in production. The tooling essentially enables optional, development-specific configuration in your application by: Copying the file config/development.config.php.dist to config/development.config.php ; this can be used to enable development-specific modules or settings (such as the debug flag). Copying the file config/autoload/development.local.php.dist to config/autoload/development.local.php ; this can be used to provide local overrides of a number of configuration settings. The package provides the tooling via vendor/bin/zf-development-mode . If you are using the Expressive skeleton, it provides aliases via Composer: $ composer development-enable $ composer development-disable $ composer development-status Add settings to your development.*.php.dist files, and commit those files to your repository; always toggle out of and into development mode after making changes, to ensure they pick up in your development environment. Expressive command-line tool The package zendframework/zend-expressive-tooling provides the script vendor/bin/expressive , which contains a number of commands related to migration, modules, and middleware. You can install it if it is not already present in your application: $ composer require --dev zendframework/zend-expressive-tooling If you installed the Expressive skeleton prior to version 2.0.2, you will want to update the tooling to get the latest release, which contains the expressive binary, as follows: $ composer require --dev \"zendframework/zend-expressive-tooling:^0.4.1\" Once installed, invoking the binary without arguments will give a listing of available tools: $ ./vendor/bin/expressive Commands supported include: middleware:create <middleware> : Create a class file for the named middleware class. The class must use a namespace already declared in your application, and will be created relative to the path associated with that namespace. migrate:error-middleware-scanner [--dir|-d] : Scan the associated directory (defaults to src ) for declarations of legacy Stratigility v1 error middleware, or invocations of $next() that provide an error argument. See the section on detecting legacy error middleware for more details. migrate:original-messages [--src|-s] : Scan the associated source directory (defaults to src ) for getOriginal*() method calls and replace them with getAttribute() calls. See the section on detecting legacy calls for more details. migrate:pipeline [--config-file|-c] : Convert configuration-driven pipelines and routing to programmatic declarations. See the section on migrating to programmatic pipelines for more details. module:create [--composer|-c] [--modules-path|-p] <module> : Create the named module, add and generate autoloading rules for it, and register the module's ConfigProvider with your application. module:register [--composer|-c] [--modules-path|-p] <module> : Add and generate autoloading rules for the named module, and register the module's ConfigProvider with your application. module:deregister [--composer|-c] [--modules-path|-p] <module> : Remove autoloading rules for the named module and regenerate autoloading rules; remove the module's ConfigProvider from the application configuration. You may obtain full help for each command by invoking: $ ./vendor/bin/expressive help <command> Modules Deprecated since zend-expressive-tooling 0.4.0; see the Expressive CLI tool section above . The package zendframework/zend-expressive-tooling provides the binary vendor/bin/expressive-module , which allows you to create, register, and deregister modules, assuming you are using a modular application layout . For instance, if you wish to create a new module for managing users, you might execute the following: $ ./vendor/bin/expressive-module create User Which would create the following tree: src/ User/ src/ ConfigProvider.php templates/ It would also create an autoloading rule within your composer.json for the User namespace, pointing it at the src/User/src/ tree (and updating the autoloader in the process), and register the new module's ConfigProvider within your config/config.php . The register command will take an existing module and: Add an autoloading rule for it to your composer.json , if necessary. Add an entry for the module's ConfigProvider class to your config/config.php , if possible. $ ./vendor/bin/expressive-module register Account The deregister command does the opposite of register . $ ./vendor/bin/expressive-module deregister Account Migrate to programmatic pipelines Deprecated since zend-expressive-tooling 0.4.0; see the Expressive CLI tool section above . We recommend using programmatic pipelines , versus configuration-defined pipelines. For those upgrading their applications from 1.X versions, we provide a tool that will read their application configuration and generate: config/pipeline.php , with the middleware pipeline config/routes.php , with routing directives config/autoload/zend-expressive.global.php , with settings to ensure programmatic pipelines are used, and new middleware provided for Expressive 2.0 is registered. directives within public/index.php for using the generated pipeline and routes directives. To use this feature, you will need to first install zendframework/zend-expressive-tooling: $ composer require --dev zendframework/zend-expressive-tooling Invoke it as follows: $ ./vendor/bin/expressive-pipeline-from-config generate The tool will notify you of any errors, including whether or not it found (and skipped) Stratigility v1-style \"error middleware\". Detect usage of legacy getOriginal*() calls Deprecated since zend-expressive-tooling 0.4.0; see the Expressive CLI tool section above . When upgrading to version 2.0, you will also receive an upgrade to zendframework/zend-stratigility 2.0. That version eliminates internal decorator classes for the request and response instances, which were used to provide access to the outermost request/response; internal layers could use these to determine the full URI that resulted in their invocation, which is useful when you pipe using a path argument (as the path provided during piping is stripped from the URI when invoking the matched middleware). This affects the following methods: Request::getOriginalRequest() Request::getOriginalUri() Response::getOriginalResponse() To provide equivalent functionality, we provide a couple of tools. First, Stratigility provides middleware, Zend\\Stratigility\\Middleware\\OriginalMessages , which will inject the current request, its URI, and, if invoked as double-pass middleware, current response, as request attributes , named, respectively, originalRequest , originalUri , and originalResponse . (Since Expressive 2.0 decorates double-pass middleware using a wrapper that composes a response, the \"original response\" will be the response prototype composed in the Application instance.) This should be registered as the outermost middleware layer. Middleware that needs access to these instances can then use the following syntax to retrieve them: $originalRequest = $request->getAttribute('originalRequest', $request); $originalUri = $request->getAttribute('originalUri', $request->getUri(); $originalResponse = $request->getAttribute('originalResponse') ?: new Response(); Original response is not trustworthy As noted above, the \"original response\" will likely be injected with the response prototype from the Application instance. We recommend not using it, and instead either composing a pristine response instance in your middleware, or creating a new instance on-the-fly. To aid you in migrating your existing code to use the new getAttribute() syntax, zendframework/zend-expressive-tooling provides a binary, vendor/bin/expressive-migrate-original-messages . First, install that package: $ composer require --dev zendframework/zend-expressive-tooling Then invoke it as follows: $ ./vendor/bin/expressive-migrate-original-messages scan This script will update any getOriginalRequest() and getOriginalUri() calls, and notify you of any getOriginalResponse() calls, providing you with details on how to correct those manually. Detect usage of legacy error middleware Deprecated since zend-expressive-tooling 0.4.0; see the Expressive CLI tool section above . When upgrading to version 2.0, you will also receive an upgrade to zendframework/zend-stratigility 2.0. That version eliminates what was known as \"error middleware\", middleware that either implemented Zend\\Stratigility\\ErrorMiddlewareInterface , or duck-typed it by implementing the signature function ($error, $request, $response, callable $next) . Such \"error middleware\" allowed other middleware to invoke the $next argument with an additional, third argument representing an error condition; when that occurred, Stratigility/Expressive would start iterating through error middleware until one was able to return a response. Each would receive the error as the first argument, and determine how to act upon it. With version 2.0 of each project, such middleware is now no longer accepted, and users should instead be using the new error handling features . However, you may find that: You have defined error middleware in your application. You have standard middleware in your application that invokes $next with the third, error argument. To help you identify such instances, zendframework/zend-expressive-tooling provides the script vendor/bin/expressive-scan-for-error-middleware . First, install that package: $ composer require --dev zendframework/zend-expressive-tooling Then invoke it as follows: $ ./vendor/bin/expressive-scan-for-error-middleware scan The script will notify you of any places where it finds either use case, and provide feedback on how to update your application.","title":"CLI Tooling"},{"location":"v2/reference/cli-tooling/#command-line-tooling","text":"Expressive offers a number of tools for assisting in project development. This page catalogues each.","title":"Command Line Tooling"},{"location":"v2/reference/cli-tooling/#development-mode","text":"The package zfcampus/zf-development-mode provides a simple way to toggle in and out of development mode . Doing so allows you to ship known development-specific settings within your repository, while ensuring they are not enabled in production. The tooling essentially enables optional, development-specific configuration in your application by: Copying the file config/development.config.php.dist to config/development.config.php ; this can be used to enable development-specific modules or settings (such as the debug flag). Copying the file config/autoload/development.local.php.dist to config/autoload/development.local.php ; this can be used to provide local overrides of a number of configuration settings. The package provides the tooling via vendor/bin/zf-development-mode . If you are using the Expressive skeleton, it provides aliases via Composer: $ composer development-enable $ composer development-disable $ composer development-status Add settings to your development.*.php.dist files, and commit those files to your repository; always toggle out of and into development mode after making changes, to ensure they pick up in your development environment.","title":"Development Mode"},{"location":"v2/reference/cli-tooling/#expressive-command-line-tool","text":"The package zendframework/zend-expressive-tooling provides the script vendor/bin/expressive , which contains a number of commands related to migration, modules, and middleware. You can install it if it is not already present in your application: $ composer require --dev zendframework/zend-expressive-tooling If you installed the Expressive skeleton prior to version 2.0.2, you will want to update the tooling to get the latest release, which contains the expressive binary, as follows: $ composer require --dev \"zendframework/zend-expressive-tooling:^0.4.1\" Once installed, invoking the binary without arguments will give a listing of available tools: $ ./vendor/bin/expressive Commands supported include: middleware:create <middleware> : Create a class file for the named middleware class. The class must use a namespace already declared in your application, and will be created relative to the path associated with that namespace. migrate:error-middleware-scanner [--dir|-d] : Scan the associated directory (defaults to src ) for declarations of legacy Stratigility v1 error middleware, or invocations of $next() that provide an error argument. See the section on detecting legacy error middleware for more details. migrate:original-messages [--src|-s] : Scan the associated source directory (defaults to src ) for getOriginal*() method calls and replace them with getAttribute() calls. See the section on detecting legacy calls for more details. migrate:pipeline [--config-file|-c] : Convert configuration-driven pipelines and routing to programmatic declarations. See the section on migrating to programmatic pipelines for more details. module:create [--composer|-c] [--modules-path|-p] <module> : Create the named module, add and generate autoloading rules for it, and register the module's ConfigProvider with your application. module:register [--composer|-c] [--modules-path|-p] <module> : Add and generate autoloading rules for the named module, and register the module's ConfigProvider with your application. module:deregister [--composer|-c] [--modules-path|-p] <module> : Remove autoloading rules for the named module and regenerate autoloading rules; remove the module's ConfigProvider from the application configuration. You may obtain full help for each command by invoking: $ ./vendor/bin/expressive help <command>","title":"Expressive command-line tool"},{"location":"v2/reference/cli-tooling/#modules","text":"Deprecated since zend-expressive-tooling 0.4.0; see the Expressive CLI tool section above . The package zendframework/zend-expressive-tooling provides the binary vendor/bin/expressive-module , which allows you to create, register, and deregister modules, assuming you are using a modular application layout . For instance, if you wish to create a new module for managing users, you might execute the following: $ ./vendor/bin/expressive-module create User Which would create the following tree: src/ User/ src/ ConfigProvider.php templates/ It would also create an autoloading rule within your composer.json for the User namespace, pointing it at the src/User/src/ tree (and updating the autoloader in the process), and register the new module's ConfigProvider within your config/config.php . The register command will take an existing module and: Add an autoloading rule for it to your composer.json , if necessary. Add an entry for the module's ConfigProvider class to your config/config.php , if possible. $ ./vendor/bin/expressive-module register Account The deregister command does the opposite of register . $ ./vendor/bin/expressive-module deregister Account","title":"Modules"},{"location":"v2/reference/cli-tooling/#migrate-to-programmatic-pipelines","text":"Deprecated since zend-expressive-tooling 0.4.0; see the Expressive CLI tool section above . We recommend using programmatic pipelines , versus configuration-defined pipelines. For those upgrading their applications from 1.X versions, we provide a tool that will read their application configuration and generate: config/pipeline.php , with the middleware pipeline config/routes.php , with routing directives config/autoload/zend-expressive.global.php , with settings to ensure programmatic pipelines are used, and new middleware provided for Expressive 2.0 is registered. directives within public/index.php for using the generated pipeline and routes directives. To use this feature, you will need to first install zendframework/zend-expressive-tooling: $ composer require --dev zendframework/zend-expressive-tooling Invoke it as follows: $ ./vendor/bin/expressive-pipeline-from-config generate The tool will notify you of any errors, including whether or not it found (and skipped) Stratigility v1-style \"error middleware\".","title":"Migrate to programmatic pipelines"},{"location":"v2/reference/cli-tooling/#detect-usage-of-legacy-getoriginal-calls","text":"Deprecated since zend-expressive-tooling 0.4.0; see the Expressive CLI tool section above . When upgrading to version 2.0, you will also receive an upgrade to zendframework/zend-stratigility 2.0. That version eliminates internal decorator classes for the request and response instances, which were used to provide access to the outermost request/response; internal layers could use these to determine the full URI that resulted in their invocation, which is useful when you pipe using a path argument (as the path provided during piping is stripped from the URI when invoking the matched middleware). This affects the following methods: Request::getOriginalRequest() Request::getOriginalUri() Response::getOriginalResponse() To provide equivalent functionality, we provide a couple of tools. First, Stratigility provides middleware, Zend\\Stratigility\\Middleware\\OriginalMessages , which will inject the current request, its URI, and, if invoked as double-pass middleware, current response, as request attributes , named, respectively, originalRequest , originalUri , and originalResponse . (Since Expressive 2.0 decorates double-pass middleware using a wrapper that composes a response, the \"original response\" will be the response prototype composed in the Application instance.) This should be registered as the outermost middleware layer. Middleware that needs access to these instances can then use the following syntax to retrieve them: $originalRequest = $request->getAttribute('originalRequest', $request); $originalUri = $request->getAttribute('originalUri', $request->getUri(); $originalResponse = $request->getAttribute('originalResponse') ?: new Response();","title":"Detect usage of legacy getOriginal*() calls"},{"location":"v2/reference/cli-tooling/#detect-usage-of-legacy-error-middleware","text":"Deprecated since zend-expressive-tooling 0.4.0; see the Expressive CLI tool section above . When upgrading to version 2.0, you will also receive an upgrade to zendframework/zend-stratigility 2.0. That version eliminates what was known as \"error middleware\", middleware that either implemented Zend\\Stratigility\\ErrorMiddlewareInterface , or duck-typed it by implementing the signature function ($error, $request, $response, callable $next) . Such \"error middleware\" allowed other middleware to invoke the $next argument with an additional, third argument representing an error condition; when that occurred, Stratigility/Expressive would start iterating through error middleware until one was able to return a response. Each would receive the error as the first argument, and determine how to act upon it. With version 2.0 of each project, such middleware is now no longer accepted, and users should instead be using the new error handling features . However, you may find that: You have defined error middleware in your application. You have standard middleware in your application that invokes $next with the third, error argument. To help you identify such instances, zendframework/zend-expressive-tooling provides the script vendor/bin/expressive-scan-for-error-middleware . First, install that package: $ composer require --dev zendframework/zend-expressive-tooling Then invoke it as follows: $ ./vendor/bin/expressive-scan-for-error-middleware scan The script will notify you of any places where it finds either use case, and provide feedback on how to update your application.","title":"Detect usage of legacy error middleware"},{"location":"v2/reference/expressive-projects/","text":"Projects powered by zend-expressive zend-expressive can be used for anything. Here are some projects, tutorials and the related source code. Have a look around and see how others have used zend-expressive. Sample Code & Tutorials Expressive Tutorial (WIP) - source AstroSplash - source php-ddd-cargo-sample - source Personal Sites mwop.net - source xtreamwayz.com - source alejandrocelaya.com - source zimuel.it - source","title":"Expressive Projects"},{"location":"v2/reference/expressive-projects/#projects-powered-by-zend-expressive","text":"zend-expressive can be used for anything. Here are some projects, tutorials and the related source code. Have a look around and see how others have used zend-expressive.","title":"Projects powered by zend-expressive"},{"location":"v2/reference/expressive-projects/#sample-code-tutorials","text":"Expressive Tutorial (WIP) - source AstroSplash - source php-ddd-cargo-sample - source","title":"Sample Code &amp; Tutorials"},{"location":"v2/reference/expressive-projects/#personal-sites","text":"mwop.net - source xtreamwayz.com - source alejandrocelaya.com - source zimuel.it - source","title":"Personal Sites"},{"location":"v2/reference/migration-to-v2-2/","text":"Migration to Expressive 2.2 Version 2.2 exists to message deprecated functionality, and to provide backports of functionality from version 3.0 as it makes sense. In most cases, your code should continue to work as it did before, but may now emit deprecation notices. This document details some specific deprecations, and how you can change your code to remove the messages, and, simultaneously, help prepare your code for version 3. Config providers The zend-expressive and zend-expressive-router packages now expose config providers . These are dedicated classes that return package-specific configuration, including dependency information. We suggest you add these to your application's configuration. Add the following two lines in your config/config.php file, inside the array passed to the ConfigAggregator constructor: \\Zend\\Expressive\\ConfigProvider::class, \\Zend\\Expressive\\Router\\ConfigProvider::class, The command ./vendor/bin/expressive migrate:expressive-v2.2 will do this for you. Routing and dispatch middleware In previous releases of Expressive, you would route your routing and dispatch middleware using the following dedicated methods: $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); These methods are now deprecated , and will be removed in version 3.0. Instead, you should use pipe() with the following services: $app->pipe(\\Zend\\Expressive\\Router\\Middleware\\RouteMiddleware::class); $app->pipe(\\Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware::class); The command ./vendor/bin/expressive migrate:expressive-v2.2 will do this for you. This also means you can easily replace these middleware with your own at this time! Routing and dispatch constants If you are using configuration-driven routes, you are likely using the constants Zend\\Expressive\\Application::ROUTING_MIDDLEWARE and DISPATCH_MIDDLEWARE to indicate the routing and dispatch middleware, as follows: 'middleware_pipeline' => [ Application::ROUTING_MIDDLEWARE, Application::DISPATCH_MIDDLEWARE, ], In the above section, we detailed deprecation of the methods pipeRoutingMiddleware() and pipeDispatchMiddleware() ; the constants above are the configuration equivalent of calling these methods, and are similarly deprecated. Change these entries to use the same syntax as other pipeline middleware, and have the middleware key indicate the appropriate middleware class as follows: 'middleware_pipeline' => [ [ 'middleware' => \\Zend\\Expressive\\Router\\Middleware\\RouteMiddleware::class, ], [ 'middleware' => \\Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware::class, ], ], Implicit HEAD and OPTIONS middleware These middleware have moved to the zend-expressive-router package. While they still exist within the zend-expressive package, we have added deprecation notices indicating their removal in v3. As such, update either of the following statements, if they exist in your application: $app->pipe(\\Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware::class); $app->pipe(\\Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware::class); to: $app->pipe(\\Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware::class); $app->pipe(\\Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware::class); The command ./vendor/bin/expressive migrate:expressive-v2.2 will do this for you. Response prototypes A number of services expect a response prototype which will be used in order to generate and return a response. Previously, we did not expose a service for this, and instead hard-coded factories to create a zend-diactoros Response instance when creating a service. In version 3, we plan to instead compose a response factory in such services. This is done to ensure a unique response prototype instance is generated for each use; this is particularly important if you wish to use such services with async web servers such as Swoole, ReactPHP, AMP, etc. To prepare for that, Expressive 2.2 does the following: Creates Zend\\Expressive\\Container\\ResponseFactoryFactory , and maps it to the service name Psr\\Http\\Response\\ResponseInterface . It returns a callable that will generate a zend-diactoros Response instance each time it is called. Creates Zend\\Expressive\\Container\\StreamFactoryFactory , and maps it to the service name Psr\\Http\\Response\\StreamInterface . It returns a callable that will generate a zend-diactoros Stream instance (backed by a read/write php://temp stream) each time it is called. The various factories that hard-coded generation of a response previously now pull the ResponseInterface service and, if it is callable, call it to produce a response, but otherwise use the return value. This change should not affect most applications, unless they were defining a ResponseInterface service previously . In such cases, ensure your factory mapping has precedence by placing it in a config/autoload/ configuration file. Double-Pass middleware Double-pass middleware refers to middleware that has the following signature: function ( ServerReqeustInterface $request, ResponseInterface $response, callable $next ) : ResponseInterface where $next will receive both a request and a response instance (this latter is the origin of the \"double-pass\" phrasing). Such middleware was used in v1 releases of Expressive, and we have continued to support it through v2. However, starting in v3, we will no longer allow you to directly pipe or route such middleware. If you need to continue using such middleware, you will need to decorate it using Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator() . This decorator class accepts the middleware and a response prototype as constructor arguments, and decorates it to be used as http-interop middleware. (In version 3, it will decorate it as PSR-15 middleware.) The zend-stratigility package provides a convenience function, Zend\\Stratigility\\doublePassMiddleware() , to simplify this for you: use Zend\\Diactoros\\Response; use function Zend\\Stratigility\\doublePassMiddleware; // Piping: $app->pipe(doublePassMiddleware($someMiddleware, new Response())); // Routing: $app->get('/foo', doublePassMiddleware($someMiddleware, new Response())); Other deprecations The following classes, traits, and instance methods were deprecated, and will be removed in version 3: Zend\\Expressive\\AppFactory : if you are using this, you will need to switch to direct usage of Zend\\Expressive\\Application or a Zend\\Stratigility\\MiddlewarePipe instance. Zend\\Expressive\\Application : deprecates the following methods: pipeRoutingMiddleware() : see the section above pipeDispatchMiddleware() : see the section above getContainer() : this method is removed in version 3; container access will only be via the bootstrap. getDefaultDelegate() : the concept of a default delegate is removed in version 3. getEmitter() : emitters move to a different collaborator in version 3. injectPipelineFromConfig() andd injectRoutesFromConfig() are methods defined by the ApplicationConfigInjectionTrait , which will be removed in version 3. See the section on the ApplicationConfigInjectionDelegator for an alternate, forwards-compatible, approach. Zend\\Expressive\\ApplicationConfigInjectionTrait : if you are using it, it is marked internal, and deprecated; it will be removed in version 3. Zend\\Expressive\\Container\\NotFoundDelegateFactory : the NotFoundDelegate will be renamed to Zend\\Expressive\\Handler\\NotFoundHandler in version 3, making this factory obsolete. Zend\\Expressive\\Delegate\\NotFoundDelegate : this class becomes Zend\\Expressive\\Handler\\NotFoundHandler in v3, and the new class is added in version 2.2 as well. Zend\\Expressive\\Emitter\\EmitterStack : the emitter concept is extracted from zend-diactoros to a new component, zend-httphandlerrunner. This latter component is used in version 3, and defines the EmitterStack class. Unless you are extending it or interacting with it directly, this change should not affect you; the Zend\\Diactoros\\Response\\EmitterInterface service will be directed to the new class in that version. Zend\\Expressive\\IsCallableInteropMiddlewareTrait : if you are using it, it is marked internal, and deprecated; it will be removed in version 3. Zend\\Expressive\\MarshalMiddlewareTrait : if you are using it, it is marked internal, and deprecated; it will be removed in version 3. Zend\\Expressive\\Middleware\\DispatchMiddleware : see the section above . Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware : see the section above . Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware : see the section above . Zend\\Expressive\\Middleware\\NotFoundHandler : this will be removed in version 3, where you can instead pipe Zend\\Expressive\\Handler\\NotFoundHandler directly instead. Zend\\Expressive\\Middleware\\RouteMiddleware : see the section above . ApplicationConfigInjectionDelegator In addition to the above deprecations, we also provide a new class, Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator . This class services two purposes: It can act as a delegator factory for the Zend\\Expressive\\Application service; when enabled, it will look for middleware_pipeline and routes configuration, and use them to inject the Application instance before returning it. It defines static methods for injecting pipelines and routes to an Application instance. To enable the delegator as a delegator factory, add the following configuration to a config/autoload/ configuration file, or a configuration provider class: 'dependencies' => [ 'delegators' => [ \\Zend\\Expressive\\Application::class => [ \\Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator::class, ], ], ], To manually inject an Application instance, you can do the following: use Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator; // assuming $config is the application configuration: ApplicationConfigInjectionDelegator::injectPipelineFromConfig($app, $config); ApplicationConfigInjectionDelegator::injectRoutesFromConfig($app, $config); These changes will be forwards-compatible with version 3.","title":"To version 2.2"},{"location":"v2/reference/migration-to-v2-2/#migration-to-expressive-22","text":"Version 2.2 exists to message deprecated functionality, and to provide backports of functionality from version 3.0 as it makes sense. In most cases, your code should continue to work as it did before, but may now emit deprecation notices. This document details some specific deprecations, and how you can change your code to remove the messages, and, simultaneously, help prepare your code for version 3.","title":"Migration to Expressive 2.2"},{"location":"v2/reference/migration-to-v2-2/#config-providers","text":"The zend-expressive and zend-expressive-router packages now expose config providers . These are dedicated classes that return package-specific configuration, including dependency information. We suggest you add these to your application's configuration. Add the following two lines in your config/config.php file, inside the array passed to the ConfigAggregator constructor: \\Zend\\Expressive\\ConfigProvider::class, \\Zend\\Expressive\\Router\\ConfigProvider::class, The command ./vendor/bin/expressive migrate:expressive-v2.2 will do this for you.","title":"Config providers"},{"location":"v2/reference/migration-to-v2-2/#routing-and-dispatch-middleware","text":"In previous releases of Expressive, you would route your routing and dispatch middleware using the following dedicated methods: $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); These methods are now deprecated , and will be removed in version 3.0. Instead, you should use pipe() with the following services: $app->pipe(\\Zend\\Expressive\\Router\\Middleware\\RouteMiddleware::class); $app->pipe(\\Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware::class); The command ./vendor/bin/expressive migrate:expressive-v2.2 will do this for you. This also means you can easily replace these middleware with your own at this time!","title":"Routing and dispatch middleware"},{"location":"v2/reference/migration-to-v2-2/#routing-and-dispatch-constants","text":"If you are using configuration-driven routes, you are likely using the constants Zend\\Expressive\\Application::ROUTING_MIDDLEWARE and DISPATCH_MIDDLEWARE to indicate the routing and dispatch middleware, as follows: 'middleware_pipeline' => [ Application::ROUTING_MIDDLEWARE, Application::DISPATCH_MIDDLEWARE, ], In the above section, we detailed deprecation of the methods pipeRoutingMiddleware() and pipeDispatchMiddleware() ; the constants above are the configuration equivalent of calling these methods, and are similarly deprecated. Change these entries to use the same syntax as other pipeline middleware, and have the middleware key indicate the appropriate middleware class as follows: 'middleware_pipeline' => [ [ 'middleware' => \\Zend\\Expressive\\Router\\Middleware\\RouteMiddleware::class, ], [ 'middleware' => \\Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware::class, ], ],","title":"Routing and dispatch constants"},{"location":"v2/reference/migration-to-v2-2/#implicit-head-and-options-middleware","text":"These middleware have moved to the zend-expressive-router package. While they still exist within the zend-expressive package, we have added deprecation notices indicating their removal in v3. As such, update either of the following statements, if they exist in your application: $app->pipe(\\Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware::class); $app->pipe(\\Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware::class); to: $app->pipe(\\Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware::class); $app->pipe(\\Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware::class); The command ./vendor/bin/expressive migrate:expressive-v2.2 will do this for you.","title":"Implicit HEAD and OPTIONS middleware"},{"location":"v2/reference/migration-to-v2-2/#response-prototypes","text":"A number of services expect a response prototype which will be used in order to generate and return a response. Previously, we did not expose a service for this, and instead hard-coded factories to create a zend-diactoros Response instance when creating a service. In version 3, we plan to instead compose a response factory in such services. This is done to ensure a unique response prototype instance is generated for each use; this is particularly important if you wish to use such services with async web servers such as Swoole, ReactPHP, AMP, etc. To prepare for that, Expressive 2.2 does the following: Creates Zend\\Expressive\\Container\\ResponseFactoryFactory , and maps it to the service name Psr\\Http\\Response\\ResponseInterface . It returns a callable that will generate a zend-diactoros Response instance each time it is called. Creates Zend\\Expressive\\Container\\StreamFactoryFactory , and maps it to the service name Psr\\Http\\Response\\StreamInterface . It returns a callable that will generate a zend-diactoros Stream instance (backed by a read/write php://temp stream) each time it is called. The various factories that hard-coded generation of a response previously now pull the ResponseInterface service and, if it is callable, call it to produce a response, but otherwise use the return value. This change should not affect most applications, unless they were defining a ResponseInterface service previously . In such cases, ensure your factory mapping has precedence by placing it in a config/autoload/ configuration file.","title":"Response prototypes"},{"location":"v2/reference/migration-to-v2-2/#double-pass-middleware","text":"Double-pass middleware refers to middleware that has the following signature: function ( ServerReqeustInterface $request, ResponseInterface $response, callable $next ) : ResponseInterface where $next will receive both a request and a response instance (this latter is the origin of the \"double-pass\" phrasing). Such middleware was used in v1 releases of Expressive, and we have continued to support it through v2. However, starting in v3, we will no longer allow you to directly pipe or route such middleware. If you need to continue using such middleware, you will need to decorate it using Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator() . This decorator class accepts the middleware and a response prototype as constructor arguments, and decorates it to be used as http-interop middleware. (In version 3, it will decorate it as PSR-15 middleware.) The zend-stratigility package provides a convenience function, Zend\\Stratigility\\doublePassMiddleware() , to simplify this for you: use Zend\\Diactoros\\Response; use function Zend\\Stratigility\\doublePassMiddleware; // Piping: $app->pipe(doublePassMiddleware($someMiddleware, new Response())); // Routing: $app->get('/foo', doublePassMiddleware($someMiddleware, new Response()));","title":"Double-Pass middleware"},{"location":"v2/reference/migration-to-v2-2/#other-deprecations","text":"The following classes, traits, and instance methods were deprecated, and will be removed in version 3: Zend\\Expressive\\AppFactory : if you are using this, you will need to switch to direct usage of Zend\\Expressive\\Application or a Zend\\Stratigility\\MiddlewarePipe instance. Zend\\Expressive\\Application : deprecates the following methods: pipeRoutingMiddleware() : see the section above pipeDispatchMiddleware() : see the section above getContainer() : this method is removed in version 3; container access will only be via the bootstrap. getDefaultDelegate() : the concept of a default delegate is removed in version 3. getEmitter() : emitters move to a different collaborator in version 3. injectPipelineFromConfig() andd injectRoutesFromConfig() are methods defined by the ApplicationConfigInjectionTrait , which will be removed in version 3. See the section on the ApplicationConfigInjectionDelegator for an alternate, forwards-compatible, approach. Zend\\Expressive\\ApplicationConfigInjectionTrait : if you are using it, it is marked internal, and deprecated; it will be removed in version 3. Zend\\Expressive\\Container\\NotFoundDelegateFactory : the NotFoundDelegate will be renamed to Zend\\Expressive\\Handler\\NotFoundHandler in version 3, making this factory obsolete. Zend\\Expressive\\Delegate\\NotFoundDelegate : this class becomes Zend\\Expressive\\Handler\\NotFoundHandler in v3, and the new class is added in version 2.2 as well. Zend\\Expressive\\Emitter\\EmitterStack : the emitter concept is extracted from zend-diactoros to a new component, zend-httphandlerrunner. This latter component is used in version 3, and defines the EmitterStack class. Unless you are extending it or interacting with it directly, this change should not affect you; the Zend\\Diactoros\\Response\\EmitterInterface service will be directed to the new class in that version. Zend\\Expressive\\IsCallableInteropMiddlewareTrait : if you are using it, it is marked internal, and deprecated; it will be removed in version 3. Zend\\Expressive\\MarshalMiddlewareTrait : if you are using it, it is marked internal, and deprecated; it will be removed in version 3. Zend\\Expressive\\Middleware\\DispatchMiddleware : see the section above . Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware : see the section above . Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware : see the section above . Zend\\Expressive\\Middleware\\NotFoundHandler : this will be removed in version 3, where you can instead pipe Zend\\Expressive\\Handler\\NotFoundHandler directly instead. Zend\\Expressive\\Middleware\\RouteMiddleware : see the section above .","title":"Other deprecations"},{"location":"v2/reference/migration-to-v2-2/#applicationconfiginjectiondelegator","text":"In addition to the above deprecations, we also provide a new class, Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator . This class services two purposes: It can act as a delegator factory for the Zend\\Expressive\\Application service; when enabled, it will look for middleware_pipeline and routes configuration, and use them to inject the Application instance before returning it. It defines static methods for injecting pipelines and routes to an Application instance. To enable the delegator as a delegator factory, add the following configuration to a config/autoload/ configuration file, or a configuration provider class: 'dependencies' => [ 'delegators' => [ \\Zend\\Expressive\\Application::class => [ \\Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator::class, ], ], ], To manually inject an Application instance, you can do the following: use Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator; // assuming $config is the application configuration: ApplicationConfigInjectionDelegator::injectPipelineFromConfig($app, $config); ApplicationConfigInjectionDelegator::injectRoutesFromConfig($app, $config); These changes will be forwards-compatible with version 3.","title":"ApplicationConfigInjectionDelegator"},{"location":"v2/reference/migration/","text":"Migration to Expressive 2.0 Expressive 2.0 should not result in many upgrade problems for users. However, starting in this version, we offer a few changes affecting the following that you should be aware of, and potentially update your application to adopt: Signature changes Removed functionality Deprecated functionality PSR-11 support Usage of http-interop middleware Original request and response messages Error handling Final handlers become default delegates Programmatic middleware pipelines Implicit handling of HEAD and OPTIONS requests RouterInterface changes URL helper changes zend-view renderer changes Twig renderer changes Adopting a modular architecture Signature changes The following signature changes were made that could affect class extensions : Zend\\Expressive\\Application::__call($method, array $args) : previously, the $args argument was not typehinted; it now is. If you are extending this class and overriding that method, you will need to update your method signature accordingly. Additionally, a number of signatures change due to updating Expressive to support PSR-11 instead of container-interop (which was the basis for PSR-11). Essentially, these were a matter of updating typehints on Interop\\Container\\ContainerInterface to Psr\\Container\\ContainerInterface . Signatures affected include: Zend\\Expressive\\AppFactory::create() Zend\\Expressive\\Application::__construct() Zend\\Expressive\\Container\\ApplicationFactory::__invoke() Zend\\Expressive\\Container\\ErrorHandlerFactory::__invoke() Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::__invoke() Zend\\Expressive\\Container\\NotFoundDelegateFactory::__invoke() Zend\\Expressive\\Container\\NotFoundHandlerFactory::__invoke() Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::__invoke() Zend\\Expressive\\Container\\WhoopsFactory::__invoke() Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::__invoke() In each of the above cases, updating your import statements from Interop\\Container\\ContainerInterface to Psr\\Container\\ContainerInterface will make your code work again. The following exceptions now implement PSR-11 exception interfaces instead of container-interop variants: Zend\\Expressive\\Container\\Exception\\InvalidServiceException In the above case, if you were previously catching the container-interop exception on which it was based, your code should still work so long as you have container-interop installed. You should likely update it to catch the more general Psr\\Container\\ContainerExceptionInterface instead, however. Removed functionality The following classes and/or methods were removed for the Expressive 2.0 release: Zend\\Expressive\\Application::pipeErrorHandler() . Stratigility 2.0 dropped its ErrorMiddlewareInterface and the concept of error middleware (middleware supporting an additional $error argument in its signature); this method was thus no longer relevant. Zend\\Expressive\\Application::routeMiddleware() . Routing middleware was extracted to the class Zend\\Expressive\\Middleware\\RouteMiddleware . Zend\\Expressive\\Application::dispatchMiddleware() . Dispatch middleware was extracted to the class Zend\\Expressive\\Middleware\\DispatchMiddleware . Zend\\Expressive\\Application::getFinalHandler() . Stratigility 2 supports the http-interop/http-middleware project, and now uses delegates . This method was renamed to getDefaultDelegate() , and now returns an Interop\\Http\\ServerMiddleware\\DelegateInterface instance. Zend\\Expressive\\Container\\Exception\\InvalidArgumentException . This exception was thrown by Zend\\Expressive\\Container\\ApplicationFactory previously; that class now throws Zend\\Expressive\\Exception\\InvalidArgumentException instead. Zend\\Expressive\\Container\\Exception\\NotFoundException . This exception type was never used internally. Zend\\Expressive\\ErrorMiddlewarePipe . With the removal of Stratigility 1 error middleware, this specialized MiddlewarePipe no longer has any use. Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory . See the section on final handler changes for more information. Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory . See the section on final handler changes for more information. Zend\\Expressive\\TemplatedErrorHandler . See the section on final handler changes for more information. Zend\\Expressive\\WhoopsErrorHandler . See the section on final handler changes for more information. Deprecated functionality Zend\\Expressive\\Application::raiseThrowables() . Stratigility 2.0 makes the method a no-op, as exceptions are no longer caught by the middleware dispatcher. As such, the raise_throwables configuration argument now is no longer used, either. PSR-11 support In previous versions of Expressive, we consumed container-interop , which provides Interop\\Container\\ContainerInterface , a shared interface for dependency injection containers. container-interop served as a working group for the PSR-11 specification. In the weeks prior to the Expressive 2.0 release, PSR-11 was formally accepted, and the package psr/container was released. As such, we have updated Expressive to consume the interfaces PSR-11 exposes. No supported implementations currently directly implement PSR-11, however. Fortunately, the container-interop 1.2.0 release acts as a forwards-compatibility measure by altering every interface it exposes to extend those from PSR-11, making existing container-interop implementations de facto PSR-11 implementations! The result is a (mostly) transparent upgrade for users of Expressive. As newer versions of container implementations are released supporting PSR-11 directly, you will be able to upgrade immediately; we will also periodically update the skeleton to pick up these new versions when present. (The one caveat to upgrading is signature changes within Expressive classes based on the new psr/container interface names.) As long as you have container-interop 1.2.0 installed, your existing factories that typehint against its interface will continue to work. However, we recommend updating them to instead typehint against PSR-11, which will allow you to drop the container-interop requirement once your chosen container implementation no longer requires it. Do not update blindly! If you are implementing interfaces from other packages in your factory implementations, be sure to check and see if those interfaces update to PSR-11 before making changes. As an example, zend-servicemanager v3 does not update Zend\\ServiceManager\\Factory\\FactoryInterface and siblings to typehint against PSR-11, as doing so would break backwards compatibility. http-interop Stratigility 2.0 provides the ability to work with http-interop middleware 0.4.1 . This specification, which is being developed as the basis of PSR-15 , defines what is known as lambda or single-pass middleware, vs the double-pass middleware traditionally used by Stratigility and Expressive. Double-pass refers to the fact that two arguments are passed to the delegation function $next : the request and response. Lambda or single-pass middleware only pass a single argument, the request. Stratigility 2.0 provides support for dispatching either style of middleware. Specifically, your middleware can now implement: Interop\\Http\\ServerMiddleware\\MiddlewareInterface , which defines a single method, process(Psr\\Http\\Message\\ServerRequestInterface $request, Interop\\Http\\ServerMiddleware\\DelegateInterface $delegate) . Callable middleware that follows the above signature (the typehint for the request argument is optional). Both styles of middleware may be piped directly to the middleware pipeline or as routed middleware within Expressive. In each case, you can invoke the next middleware layer using $delegate->process($request) . In Expressive 2.0, Application will continue to accept the legacy double-pass signature, but will require that you either: Provide a $responsePrototype (a ResponseInterface instance) to the Application instance prior to piping or routing such middleware. Decorate the middleware in a Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper instance (which also requires a $responsePrototype ). If you use Zend\\Expressive\\Container\\ApplicationFactory to create your Application instance, a response prototype will be injected for you from the outset. We recommend that you begin writing middleware to follow the http-interop standard at this time. As an example: namespace App\\Middleware; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; class XClacksOverheadMiddleware implements MiddlewareInterface { /** * {@inheritDoc} */ public function process(ServerRequestInterface $request, DelegateInterface $delegate) { $response = $delegate->process($request); return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett'); } } Alternately, you can write this as a callable: namespace App\\Middleware; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; class XClacksOverheadMiddleware { /** * @param ServerRequestInterface $request * @param DelegateInterface $delegate * @return ResponseInterface */ public function __invoke(ServerRequestInterface $request, DelegateInterface $delegate) { $response = $delegate->process($request); return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett'); } } Original messages In the migration to version 1.1 guide , we detail the fact that Stratigility 1.3 deprecated its internal request and response decorators. Stratigility 2.0, on which Expressive 2.0 is based, removes them entirely. If your code relied on the various getOriginal*() methods those decorators exposed, you will need to update your code in two ways: You will need to add Zend\\Stratigility\\Middleware\\OriginalMessages to your middleware pipeline, as the outermost (or close to outermost) layer. You will need to update your code to call on the request instance's getAttribute() method with one of originalRequest , originalUri , or originalResponse to retrieve the values. To address the first point, see the Expressive 1.1 migration documentation , which details how to update your configuration or programmatic pipeline. For the second point, we provide a tool via the zendframework/zend-expressive-tooling package which will help you in this latter part of the migration. Install it as a development requirement via composer: $ composer require --dev zendframework/zend-expressive-tooling And then execute it via: $ ./vendor/bin/expressive-migrate-original-messages This tool will update calls to getOriginalRequest() and getOriginalUri() to instead use the new request attributes that the OriginalMessages middleware injects: getOriginalRequest() becomes getAttribute('originalRequest', $request) getOriginalUri() becomes getAttribute('originalUri', $request->getUri()) In both cases, $request will be replaced with whatever variable name you used for the request instance. For getOriginalResponse() calls, which happen on the response instance, the tool will instead tell you what files had such calls, and detail how you can update those calls to use the originalResponse request attribute. Error handling As noted in the Expressive 1.1 migration docs , Stratigility 1.3 introduced the ability to tell it to no longer catch exceptions internally, paving the way for middleware-based error handling. Additionally, it deprecated its own ErrorMiddlewareInterface and duck-typed implementations of the interface in favor of middleware-based error handling. Finally, it deprecated the $e / $error argument to \"final handlers\", as that argument would be used only when attempting to invoke ErrorMiddlewareInterface instances. Stratigility 2.0, on which Expressive 2.0 is based, no longer catches exceptions internally, removes the ErrorMiddlewareInterface entirely, and thus the $e / $error argument to final handlers. As such, you MUST provide your own error handling with Expressive 2.0. Error handling middleware will typically introduce a try/catch block: function ( ServerRequestInterface $request, ResponseInterface $response, callable $next ) { try { $response = $next($request, $response); return $response; } catch (\\Throwable $exception) { // caught PHP 7 throwable } catch (\\Exception $exception) { // caught PHP 5 exception } // ... // do something with $exception and generate a response // ... return $response; } Additionally, you will need middleware registered as your innermost layer that is guaranteed to return a response. Generally, if you hit that layer, no other middleware is capable of handling the request, indicating a 400 (Bad Request) or 404 (Not Found) HTTP status. With the combination of an error handler at the outermost layer, and a \"not found\" handler at the innermost layer, you can handle any error in your application. Stratigility 1.3 and 2.0 provide an error handler implementation via Zend\\Stratigility\\Middleware\\ErrorHandler . In addition to the try/catch block, it also sets up a PHP error handler that will catch any PHP error types in the current error_reporting mask; the error handler will raise exceptions of the type ErrorException with the PHP error details. ErrorHandler allows injection of an \"error response generator\", which allows you to alter how the error response is generated based on the current environment. Error response generators are callables with the signature: function ( Throwable|Exception $e, ServerRequestInterface $request, ResponseInterface $response ) : ResponseInterface Expressive 2.0 provides the following functionality to assist with your error handling needs: Zend\\Expressive\\Middleware\\ErrorResponseGenerator will output a canned plain/text message, or use a supplied template renderer to generate content for the response. It accepts the following arguments to its constructor: $isDevelopmentMode = false : whether or not the application is in development mode. If so, it will output stack traces when no template renderer is used (see below), or supply the exception to the template via the error variable if a renderer is present. Zend\\Expressive\\Template\\TemplateRendererInterface $renderer : if supplied, the results of rendering a template will be injected into the response. Templates are passed the following variables: response : the response at the time of rendering request : the request at the time of rendering uri : the URI at the time of rendering status : the response status code reason : the response reason phrase error : the exception; this is only provided when in development mode. $template = 'error::error' : the template to render, with a default value if none is provided. Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory can create an instance of the ErrorResponseGenerator using the following: The debug top-level configuration value is used to set the $isDevelopmentMode flag. If a Zend\\Expressive\\Template\\TemplateRendererInterface service is registered, it will be provided to the constructor. The value of zend-expressive.error_handler.template_error , if present, will be used to seed the $template argument. Zend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator uses Whoops to generate the error response. Its constructor takes a single argument, a Whoops\\Run instance. If a Whoops\\Handler\\PrettyPageHandler is registered with the instance, it will add a data table with request details derived from the ServerRequestInterface instance. Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory can create an instance, and will use the Zend\\Expressive\\Whoops service to seed the Whoops\\Run argument. Zend\\Expressive\\Middleware\\NotFoundHandler can be used as the innermost layer of your pipeline in order to return a 404 response. (Typically, if you get to the innermost layer, no middleware was able to handle the request, indicating a 404.) By default, it will produce a canned plaintext response. However, you can also provide an optional TemplateRendererInterface instance and $template in order to provided templated content. The constructor arguments are: ResponseInterface $responsePrototype : this is an empty response on which to set the 404 status and inject the 404 content. TemplateRendererInterface $renderer : optionally, you may provide a renderer to use in order to provide templated response content. $template = 'error::404'`: optionally, you may provide a template to render; if none is provided, a sane default is used. Zend\\Expressive\\Container\\NotFoundHandlerFactory can create an instance of the NotFoundHandler for you, and will use the following to do so: The Zend\\Expressive\\Template\\TemplateRendererInterface service, if available. The zend-expressive.error_handler.template_404 configuration value, if available, will be used for the $template . Zend\\Expressive\\Container\\ErrorHandlerFactory will create an instance of Zend\\Stratigility\\Middleware\\ErrorHandler , and use the Zend\\Stratigility\\Middleware\\ErrorResponseGenerator service to seed it. As such, register one of the following as a factory for the Zend\\Stratigility\\Middleware\\ErrorResponseGenerator service: Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory Error handler configuration example If you are using configuration-driven middleware, your middleware pipeline configuration may look like this in order to make use of the new error handling facilities: // config/autoload/middleware-pipeline.global.php use Zend\\Expressive\\Application; use Zend\\Expressive\\Container; use Zend\\Expressive\\Helper; use Zend\\Expressive\\Middleware; use Zend\\Stratigility\\Middleware\\ErrorHandler; use Zend\\Stratigility\\Middleware\\OriginalMessages; return [ // Add the following section to enable the new error handling: 'zend-expressive' => [ 'raise_throwables' => true, ], 'dependencies' => [ 'invokables' => [ // See above section on \"Original messages\": OriginalMessages::class => OriginalMessages::class, ], 'factories' => [ Helper\\ServerUrlMiddleware::class => Helper\\ServerUrlMiddlewareFactory::class, Helper\\UrlHelperMiddleware::class => Helper\\UrlHelperMiddlewareFactory::class, // Add the following three entries: ErrorHandler::class => Container\\ErrorHandlerFactory::class, Middleware\\ErrorResponseGenerator::class => Container\\ErrorResponseGeneratorFactory::class, Middleware\\NotFoundHandler::class => Container\\NotFoundHandlerFactory::class, ], ], 'middleware_pipeline' => [ 'always' => [ 'middleware' => [ OriginalMessages::class, Helper\\ServerUrlMiddleware::class, ErrorHandler::class, /* ... */ ], 'priority' => 10000, ], 'routing' => [ 'middleware' => [ Application::ROUTING_MIDDLEWARE, Helper\\UrlHelperMiddleware::class, Application::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], 'not-found' => [ 'middleware' => Middleware\\NotFoundHandler::class, 'priority' => 0, ], // Remove the section \"error\"\" ], ]; If you are defining a programmatic pipeline (see more below on this), the pipeline might look like: $app->pipe(OriginalMessages::class); $app->pipe(Helper\\ServerUrlMiddleware::class); $app->pipe(ErrorHandler::class); $app->pipeRoutingMiddleware(); $app->pipe(Helper\\UrlHelperMiddleware::class); $app->pipeDispatchMiddleware(); $app->pipe(Middleware\\NotFoundHandler::class); Error handling and PHP errors As noted above, Zend\\Stratigility\\Middleware\\ErrorHandler also creates a PHP error handler that casts PHP errors to ErrorException instances. More specifically, it uses the current error_reporting value to determine which errors it should cast this way. This can be problematic when deprecation errors are triggered. If they are cast to exceptions, code that would normally run will now result in error pages. We recommend adding the following line to your public/index.php towards the top of the file: error_reporting(error_reporting() & ~E_USER_DEPRECATED); This will prevent the error handler from casting deprecation notices to exceptions, while keeping the rest of your error reporting mask intact. Removing legacy error middleware Stratigility version 1-style error middleware (middleware implementing Zend\\Stratigility\\ErrorMiddlewareInterface , or duck-typing its signature, which included an $error argument as the first argument to the middleware) is no longer supported with Stratigility version 2 and Expressive 2.0. You will need to find any instances of them in your application, or cases where your middleware invokes error middleware via the third argument to $next() . We provide a tool to assist you with that via the package zendframework/zend-expressive-tooling : vendor/bin/expressive-scan-for-error-middleware . Run the command from your project root, optionally passing the help , --help , or -h commands for usage. The tool will detect each of these for you, flagging them for you to update or remove. Final handlers become default delegates One ramification of supporting http-interop middleware is that the concept of \"final handlers\" changes. In Stratigility 1.X and Expressive 1.X, a \"final handler\" was invoked when the middleware pipeline was exhausted; however, due to how Stratigility caught exceptions, this also meant that the final handler often acted as the application error handler, reporting errors to end users. With the error handling changes noted above , error handling is moved to dedicated middleware. However, there is still a need to have something that can execute once the middleware pipeline is exhausted. Such a situation typically indicates no middleware was able to handle the request, or that the request was somehow malformed. In Expressive 2.0, we have removed final handlers, and replaced them with the concept of \"default delegates\". Delegates are Interop\\Http\\ServerMiddleware\\DelegateInterface instances, which are invoked by middleware when they wish to delegate processing of the request to something else. Internally, Stratigility 2.0 and Expressive 2.0 use a delegate to iterate through the middleware pipeline. For Expressive 2.0, a default delegate is a delegate executed when the application's internal middleware pipeline is exhausted. The ramifications for end users are as follows: The $finalHandler argument to Application 's constructor, which previously was a callable , is now called $defaultDelegate , and needs to be a DelegateInterface instance. getFinalHandler() no longer exists; we have added getDefaultDelegate() . The service Zend\\Expressive\\FinalHandler is no longer used. A new service, Zend\\Expressive\\Delegate\\DefaultDelegate , is used by ApplicationFactory , and, if present, will be used to inject the $defaultDelegate argument of the Application constructor. We have removed the following classes, which either provided final handlers, or acted as factories for them: Zend\\Expressive\\TemplatedErrorHandler Zend\\Expressive\\WhoopsErrorHandler Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory If you use the vendor/bin/expressive-pipeline-from-config tool to migrate your application to programmatic pipelines, as described below, the DefaultDelegate service will be mapped to Zend\\Expressive\\Container\\NotFoundDelegateFactory , which will provide an instance of Zend\\Expressive\\Delegate\\NotFoundDelegate . This new class will produce a 404 response, using a template if the Zend\\Expressive\\Template\\TemplateRendererInterface service is present, but otherwise producing a plain text response. Application's built using the 2.0 version of the skeleton application will have these features enabled by default. NotFoundDelegate and NotFoundHandler Zend\\Expressive\\Middleware\\NotFoundHandler , which is intended as innermost middleware for producing a 404 response, composes and proxies to a NotFoundDelegate instance to produce its response. Programmatic middleware pipelines Starting with Expressive 1.1, we recommended programmatic creation of pipelines and routing ; the Expressive 1.1 migration guide provides more detail. With Expressive 2.0, this is now the default option shipped in the skeleton. If you are upgrading from version 1 and are not currently using programmatic pipelines, we provide a migration tool that will convert your application to do so. The tool is available via the package zendframework/zend-expressive-tooling . You may install this package in one of the following ways: Via the vendor binary ./vendor/bin/expressive-tooling : bash $ ./vendor/bin/expressive-tooling # install $ ./vendor/bin/expressive-tooling remove # uninstall Using Composer: bash $ composer require --dev zendframework/zend-expressive-tooling # install $ composer remove --dev zendframework/zend-expressive-tooling # uninstall Once installed, you will use the vendor/bin/expressive-pipeline-from-config command. This command does the following: Reads your middleware_pipeline configuration, and generates a programmatic pipeline for you, which is then stored in config/pipeline.php . The generated pipeline contains the following additions: The first middleware in the pipeline is Zend\\Stratigility\\Middleware\\OriginalMessages , which injects the incoming request, URI, and response as the request attributes originalRequest , originalUri , and originalResponse , respectively. (This can aid URI generation in nested middleware later.) The second middleware in the pipeline is Zend\\Stratigility\\Middleware\\ErrorHandler . The last middleware in the pipeline is Zend\\Expressive\\Middleware\\NotFoundHandler . Reads your routes configuration, and generates a programmatic routing table for you, which is then stored in config/routes.php . Adds a new configuration file, config/autoload/programmatic-pipeline.global.php , which enables the programmatic_pipelines configuration flag. Additionally, it adds dependency configuration for the new error handlers. Inserts two lines before the $app->run() statement of your public/index.php , one each to require config/pipeline.php and config/routes.php . Your middleware_pipeline and routes configuration are not removed at this time, to allow you to test and verify your application first; however, due to the configuration in config/autoload/programmatic-pipeline.global.php , these are now ignored. If you wish to use Whoops in your development environment, you may add the following to a local configuration file (e.g., config/autoload/local.php ): use Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory; use Zend\\Expressive\\Middleware\\ErrorResponseGenerator; return [ 'dependencies' => [ 'factories' => [ ErrorResponseGenerator::class => WhoopsErrorResponseGeneratorFactory::class, ], ], ]; Other things you may want to do: The ErrorHandler entry could potentially be moved inwards a few layers. As an example, the ServerUrlMiddleware has no possibility of raising an exception or error, and could be moved outwards; you could do similarly for any middleware that only injects additional response headers. Remove any Stratigility-style error middleware (middleware expecting an error as the first argument). If any specialized error handling should occur, add additional middleware into the pipeline that can catch exceptions, and have that middleware re-throw for exceptions it cannot handle. (Use the vendor/bin/expressive-scan-for-error-middleware command from zendframework/zend-expressive-tooling to assist in this.) Consider providing your own Zend\\Stratigility\\NoopFinalHandler implementation; this will now only be invoked if the queue is exhausted, and could return a generic 404 page, raise an exception, etc. Handling HEAD and OPTIONS requests Prior to 2.0, it was possible to route middleware that could not handle HEAD and/or OPTIONS requests. Per RFC 7231, section 4.1 , \"all general-purpose servers MUST support the methods GET and HEAD. All other methods are OPTIONAL.\" Additionally, most servers and implementors agree that OPTIONS should be supported for any given resource, so that consumers can determine what methods are allowed for the given resource. To make this happen, the Expressive project implemented several features. First, zend-expressive-router 1.3.0 introduced several features in both Zend\\Expressive\\Router\\Route and Zend\\Expressive\\Router\\RouteResult to help consumers implement support for HEAD and OPTIONS in an automated way. The Route class now has two new methods, implicitHead() and implicitOptions() ; these each return a boolean true value if support for those methods is implicit \u2014 i.e., not defined explicitly for the route. The RouteResult class now introduces a new factory method, fromRoute() , that will create an instance from a Route instance; this then allows consumers of a RouteResult to query the Route to see if a matched HEAD or OPTIONS request needs automated handling. Each of the supported router implementations were updated to use this method, as well as to return a successful routing result if HEAD and/or OPTIONS requests are submitted, but the route does not explicitly support the method. Within Expressive itself, we now offer two new middleware to provide this automation: Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware If you want to support these methods automatically, each of these should be enabled between the routing and dispatch middleware. If you use the expressive-pipeline-from-config tool as documented in the programmatic pipeline migration section , entries for each will be injected into your generated pipeline. Please see the chapter on the implicit methods middleware for more information on each. Router interface changes Expressive 2.0 uses zendframework/zend-expressive-router 2.1+. Version 2.0 of that package introduced a change to the Zend\\Expressive\\Router\\RouterInterface::generateUri() method; it now accepts an additional, optional, third argument, array $options = [] , which can be used to pass router-specific options when generating a URI. As an example, the implementation that uses zendframework/zend-router might use these options to pass a translator instance in order to translate a path segment to the currently selected locale. For consumers, his represents no backwards-incompatible change; consumers may opt-in to the new argument at will. For those implementing the interface, upgrading will require updating your router implementation's signature to match the new interface: public function generateUri( string $name, array $substitutions = [], array $options = [] ) : string URL helper changes Expressive 2.0 uses zendframework/zend-expressive-helpers version 3.0+. This new version updates the signature of the Zend\\Expressive\\Helper\\UrlHelper from: function ( $routeName, array $routeParams = [] ) : string to: function ( $routeName, array $routeParams = [], $queryParams = [], $fragmentIdentifier = null, array $options = [] ) : string For consumers, this should represent a widening of features, and will not require any changes, unless you wish to opt-in to the new arguments. See the UrlHelper documentation for information on each argument. For any users who were extending the class, you will need to update your extension accordingly. zend-view renderer changes Expressive 2.0 will use zend-expressive-zendviewrenderer 1.3+ if that renderer is chosen. Starting with 1.3.0 of that renderer, you may now pass a boolean false value for the layout variable when calling either addDefaultParam() or render() on the renderer instance in order to disable the layout. Twig renderer changes Expressive 2.0 will use zend-expressive-twigrenderer 1.3+ if that renderer is chosen. Starting with 1.3.0 of that renderer, Twig 2.1+ is now supported. Adopting a modular architecture Expressive 2.0 ships with support for modular architectures from the outset, as detailed in the chapter on modules . If you wish to update your application to use these features, you will need to install the following packages: zendframework/zend-config-aggregator zendframework/zend-component-installer As an example: $ composer require zendframework/zend-config-aggregator \\ > zendframework/zend-component-installer Once installed, you should update your config/config.php file to read as follows: <?php use Zend\\ConfigAggregator\\ArrayProvider; use Zend\\ConfigAggregator\\ConfigAggregator; use Zend\\ConfigAggregator\\PhpFileProvider; // To enable or disable caching, set the `ConfigAggregator::ENABLE_CACHE` boolean in // `config/autoload/local.php`. $cacheConfig = [ 'config_cache_path' => 'data/config-cache.php', ]; $aggregator = new ConfigAggregator([ // Include cache configuration new ArrayProvider($cacheConfig), // Default App module config App\\ConfigProvider::class, // Load application config in a pre-defined order in such a way that local settings // overwrite global settings. (Loaded as first to last): // - `global.php` // - `*.global.php` // - `local.php` // - `*.local.php` new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'), // Load development config if it exists new PhpFileProvider('config/development.config.php'), ], $cacheConfig['config_cache_path']); return $aggregator->getMergedConfig(); The above should mimic what you already had in place; if it does not, check to see if there are additional paths you were globbing previously.","title":"To version 2"},{"location":"v2/reference/migration/#migration-to-expressive-20","text":"Expressive 2.0 should not result in many upgrade problems for users. However, starting in this version, we offer a few changes affecting the following that you should be aware of, and potentially update your application to adopt: Signature changes Removed functionality Deprecated functionality PSR-11 support Usage of http-interop middleware Original request and response messages Error handling Final handlers become default delegates Programmatic middleware pipelines Implicit handling of HEAD and OPTIONS requests RouterInterface changes URL helper changes zend-view renderer changes Twig renderer changes Adopting a modular architecture","title":"Migration to Expressive 2.0"},{"location":"v2/reference/migration/#signature-changes","text":"The following signature changes were made that could affect class extensions : Zend\\Expressive\\Application::__call($method, array $args) : previously, the $args argument was not typehinted; it now is. If you are extending this class and overriding that method, you will need to update your method signature accordingly. Additionally, a number of signatures change due to updating Expressive to support PSR-11 instead of container-interop (which was the basis for PSR-11). Essentially, these were a matter of updating typehints on Interop\\Container\\ContainerInterface to Psr\\Container\\ContainerInterface . Signatures affected include: Zend\\Expressive\\AppFactory::create() Zend\\Expressive\\Application::__construct() Zend\\Expressive\\Container\\ApplicationFactory::__invoke() Zend\\Expressive\\Container\\ErrorHandlerFactory::__invoke() Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::__invoke() Zend\\Expressive\\Container\\NotFoundDelegateFactory::__invoke() Zend\\Expressive\\Container\\NotFoundHandlerFactory::__invoke() Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::__invoke() Zend\\Expressive\\Container\\WhoopsFactory::__invoke() Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::__invoke() In each of the above cases, updating your import statements from Interop\\Container\\ContainerInterface to Psr\\Container\\ContainerInterface will make your code work again. The following exceptions now implement PSR-11 exception interfaces instead of container-interop variants: Zend\\Expressive\\Container\\Exception\\InvalidServiceException In the above case, if you were previously catching the container-interop exception on which it was based, your code should still work so long as you have container-interop installed. You should likely update it to catch the more general Psr\\Container\\ContainerExceptionInterface instead, however.","title":"Signature changes"},{"location":"v2/reference/migration/#removed-functionality","text":"The following classes and/or methods were removed for the Expressive 2.0 release: Zend\\Expressive\\Application::pipeErrorHandler() . Stratigility 2.0 dropped its ErrorMiddlewareInterface and the concept of error middleware (middleware supporting an additional $error argument in its signature); this method was thus no longer relevant. Zend\\Expressive\\Application::routeMiddleware() . Routing middleware was extracted to the class Zend\\Expressive\\Middleware\\RouteMiddleware . Zend\\Expressive\\Application::dispatchMiddleware() . Dispatch middleware was extracted to the class Zend\\Expressive\\Middleware\\DispatchMiddleware . Zend\\Expressive\\Application::getFinalHandler() . Stratigility 2 supports the http-interop/http-middleware project, and now uses delegates . This method was renamed to getDefaultDelegate() , and now returns an Interop\\Http\\ServerMiddleware\\DelegateInterface instance. Zend\\Expressive\\Container\\Exception\\InvalidArgumentException . This exception was thrown by Zend\\Expressive\\Container\\ApplicationFactory previously; that class now throws Zend\\Expressive\\Exception\\InvalidArgumentException instead. Zend\\Expressive\\Container\\Exception\\NotFoundException . This exception type was never used internally. Zend\\Expressive\\ErrorMiddlewarePipe . With the removal of Stratigility 1 error middleware, this specialized MiddlewarePipe no longer has any use. Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory . See the section on final handler changes for more information. Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory . See the section on final handler changes for more information. Zend\\Expressive\\TemplatedErrorHandler . See the section on final handler changes for more information. Zend\\Expressive\\WhoopsErrorHandler . See the section on final handler changes for more information.","title":"Removed functionality"},{"location":"v2/reference/migration/#deprecated-functionality","text":"Zend\\Expressive\\Application::raiseThrowables() . Stratigility 2.0 makes the method a no-op, as exceptions are no longer caught by the middleware dispatcher. As such, the raise_throwables configuration argument now is no longer used, either.","title":"Deprecated functionality"},{"location":"v2/reference/migration/#psr-11-support","text":"In previous versions of Expressive, we consumed container-interop , which provides Interop\\Container\\ContainerInterface , a shared interface for dependency injection containers. container-interop served as a working group for the PSR-11 specification. In the weeks prior to the Expressive 2.0 release, PSR-11 was formally accepted, and the package psr/container was released. As such, we have updated Expressive to consume the interfaces PSR-11 exposes. No supported implementations currently directly implement PSR-11, however. Fortunately, the container-interop 1.2.0 release acts as a forwards-compatibility measure by altering every interface it exposes to extend those from PSR-11, making existing container-interop implementations de facto PSR-11 implementations! The result is a (mostly) transparent upgrade for users of Expressive. As newer versions of container implementations are released supporting PSR-11 directly, you will be able to upgrade immediately; we will also periodically update the skeleton to pick up these new versions when present. (The one caveat to upgrading is signature changes within Expressive classes based on the new psr/container interface names.) As long as you have container-interop 1.2.0 installed, your existing factories that typehint against its interface will continue to work. However, we recommend updating them to instead typehint against PSR-11, which will allow you to drop the container-interop requirement once your chosen container implementation no longer requires it.","title":"PSR-11 support"},{"location":"v2/reference/migration/#http-interop","text":"Stratigility 2.0 provides the ability to work with http-interop middleware 0.4.1 . This specification, which is being developed as the basis of PSR-15 , defines what is known as lambda or single-pass middleware, vs the double-pass middleware traditionally used by Stratigility and Expressive. Double-pass refers to the fact that two arguments are passed to the delegation function $next : the request and response. Lambda or single-pass middleware only pass a single argument, the request. Stratigility 2.0 provides support for dispatching either style of middleware. Specifically, your middleware can now implement: Interop\\Http\\ServerMiddleware\\MiddlewareInterface , which defines a single method, process(Psr\\Http\\Message\\ServerRequestInterface $request, Interop\\Http\\ServerMiddleware\\DelegateInterface $delegate) . Callable middleware that follows the above signature (the typehint for the request argument is optional). Both styles of middleware may be piped directly to the middleware pipeline or as routed middleware within Expressive. In each case, you can invoke the next middleware layer using $delegate->process($request) . In Expressive 2.0, Application will continue to accept the legacy double-pass signature, but will require that you either: Provide a $responsePrototype (a ResponseInterface instance) to the Application instance prior to piping or routing such middleware. Decorate the middleware in a Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper instance (which also requires a $responsePrototype ). If you use Zend\\Expressive\\Container\\ApplicationFactory to create your Application instance, a response prototype will be injected for you from the outset. We recommend that you begin writing middleware to follow the http-interop standard at this time. As an example: namespace App\\Middleware; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Interop\\Http\\ServerMiddleware\\MiddlewareInterface; use Psr\\Http\\Message\\ServerRequestInterface; class XClacksOverheadMiddleware implements MiddlewareInterface { /** * {@inheritDoc} */ public function process(ServerRequestInterface $request, DelegateInterface $delegate) { $response = $delegate->process($request); return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett'); } } Alternately, you can write this as a callable: namespace App\\Middleware; use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; class XClacksOverheadMiddleware { /** * @param ServerRequestInterface $request * @param DelegateInterface $delegate * @return ResponseInterface */ public function __invoke(ServerRequestInterface $request, DelegateInterface $delegate) { $response = $delegate->process($request); return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett'); } }","title":"http-interop"},{"location":"v2/reference/migration/#original-messages","text":"In the migration to version 1.1 guide , we detail the fact that Stratigility 1.3 deprecated its internal request and response decorators. Stratigility 2.0, on which Expressive 2.0 is based, removes them entirely. If your code relied on the various getOriginal*() methods those decorators exposed, you will need to update your code in two ways: You will need to add Zend\\Stratigility\\Middleware\\OriginalMessages to your middleware pipeline, as the outermost (or close to outermost) layer. You will need to update your code to call on the request instance's getAttribute() method with one of originalRequest , originalUri , or originalResponse to retrieve the values. To address the first point, see the Expressive 1.1 migration documentation , which details how to update your configuration or programmatic pipeline. For the second point, we provide a tool via the zendframework/zend-expressive-tooling package which will help you in this latter part of the migration. Install it as a development requirement via composer: $ composer require --dev zendframework/zend-expressive-tooling And then execute it via: $ ./vendor/bin/expressive-migrate-original-messages This tool will update calls to getOriginalRequest() and getOriginalUri() to instead use the new request attributes that the OriginalMessages middleware injects: getOriginalRequest() becomes getAttribute('originalRequest', $request) getOriginalUri() becomes getAttribute('originalUri', $request->getUri()) In both cases, $request will be replaced with whatever variable name you used for the request instance. For getOriginalResponse() calls, which happen on the response instance, the tool will instead tell you what files had such calls, and detail how you can update those calls to use the originalResponse request attribute.","title":"Original messages"},{"location":"v2/reference/migration/#error-handling","text":"As noted in the Expressive 1.1 migration docs , Stratigility 1.3 introduced the ability to tell it to no longer catch exceptions internally, paving the way for middleware-based error handling. Additionally, it deprecated its own ErrorMiddlewareInterface and duck-typed implementations of the interface in favor of middleware-based error handling. Finally, it deprecated the $e / $error argument to \"final handlers\", as that argument would be used only when attempting to invoke ErrorMiddlewareInterface instances. Stratigility 2.0, on which Expressive 2.0 is based, no longer catches exceptions internally, removes the ErrorMiddlewareInterface entirely, and thus the $e / $error argument to final handlers. As such, you MUST provide your own error handling with Expressive 2.0. Error handling middleware will typically introduce a try/catch block: function ( ServerRequestInterface $request, ResponseInterface $response, callable $next ) { try { $response = $next($request, $response); return $response; } catch (\\Throwable $exception) { // caught PHP 7 throwable } catch (\\Exception $exception) { // caught PHP 5 exception } // ... // do something with $exception and generate a response // ... return $response; } Additionally, you will need middleware registered as your innermost layer that is guaranteed to return a response. Generally, if you hit that layer, no other middleware is capable of handling the request, indicating a 400 (Bad Request) or 404 (Not Found) HTTP status. With the combination of an error handler at the outermost layer, and a \"not found\" handler at the innermost layer, you can handle any error in your application. Stratigility 1.3 and 2.0 provide an error handler implementation via Zend\\Stratigility\\Middleware\\ErrorHandler . In addition to the try/catch block, it also sets up a PHP error handler that will catch any PHP error types in the current error_reporting mask; the error handler will raise exceptions of the type ErrorException with the PHP error details. ErrorHandler allows injection of an \"error response generator\", which allows you to alter how the error response is generated based on the current environment. Error response generators are callables with the signature: function ( Throwable|Exception $e, ServerRequestInterface $request, ResponseInterface $response ) : ResponseInterface Expressive 2.0 provides the following functionality to assist with your error handling needs: Zend\\Expressive\\Middleware\\ErrorResponseGenerator will output a canned plain/text message, or use a supplied template renderer to generate content for the response. It accepts the following arguments to its constructor: $isDevelopmentMode = false : whether or not the application is in development mode. If so, it will output stack traces when no template renderer is used (see below), or supply the exception to the template via the error variable if a renderer is present. Zend\\Expressive\\Template\\TemplateRendererInterface $renderer : if supplied, the results of rendering a template will be injected into the response. Templates are passed the following variables: response : the response at the time of rendering request : the request at the time of rendering uri : the URI at the time of rendering status : the response status code reason : the response reason phrase error : the exception; this is only provided when in development mode. $template = 'error::error' : the template to render, with a default value if none is provided. Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory can create an instance of the ErrorResponseGenerator using the following: The debug top-level configuration value is used to set the $isDevelopmentMode flag. If a Zend\\Expressive\\Template\\TemplateRendererInterface service is registered, it will be provided to the constructor. The value of zend-expressive.error_handler.template_error , if present, will be used to seed the $template argument. Zend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator uses Whoops to generate the error response. Its constructor takes a single argument, a Whoops\\Run instance. If a Whoops\\Handler\\PrettyPageHandler is registered with the instance, it will add a data table with request details derived from the ServerRequestInterface instance. Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory can create an instance, and will use the Zend\\Expressive\\Whoops service to seed the Whoops\\Run argument. Zend\\Expressive\\Middleware\\NotFoundHandler can be used as the innermost layer of your pipeline in order to return a 404 response. (Typically, if you get to the innermost layer, no middleware was able to handle the request, indicating a 404.) By default, it will produce a canned plaintext response. However, you can also provide an optional TemplateRendererInterface instance and $template in order to provided templated content. The constructor arguments are: ResponseInterface $responsePrototype : this is an empty response on which to set the 404 status and inject the 404 content. TemplateRendererInterface $renderer : optionally, you may provide a renderer to use in order to provide templated response content. $template = 'error::404'`: optionally, you may provide a template to render; if none is provided, a sane default is used. Zend\\Expressive\\Container\\NotFoundHandlerFactory can create an instance of the NotFoundHandler for you, and will use the following to do so: The Zend\\Expressive\\Template\\TemplateRendererInterface service, if available. The zend-expressive.error_handler.template_404 configuration value, if available, will be used for the $template . Zend\\Expressive\\Container\\ErrorHandlerFactory will create an instance of Zend\\Stratigility\\Middleware\\ErrorHandler , and use the Zend\\Stratigility\\Middleware\\ErrorResponseGenerator service to seed it. As such, register one of the following as a factory for the Zend\\Stratigility\\Middleware\\ErrorResponseGenerator service: Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory","title":"Error handling"},{"location":"v2/reference/migration/#final-handlers-become-default-delegates","text":"One ramification of supporting http-interop middleware is that the concept of \"final handlers\" changes. In Stratigility 1.X and Expressive 1.X, a \"final handler\" was invoked when the middleware pipeline was exhausted; however, due to how Stratigility caught exceptions, this also meant that the final handler often acted as the application error handler, reporting errors to end users. With the error handling changes noted above , error handling is moved to dedicated middleware. However, there is still a need to have something that can execute once the middleware pipeline is exhausted. Such a situation typically indicates no middleware was able to handle the request, or that the request was somehow malformed. In Expressive 2.0, we have removed final handlers, and replaced them with the concept of \"default delegates\". Delegates are Interop\\Http\\ServerMiddleware\\DelegateInterface instances, which are invoked by middleware when they wish to delegate processing of the request to something else. Internally, Stratigility 2.0 and Expressive 2.0 use a delegate to iterate through the middleware pipeline. For Expressive 2.0, a default delegate is a delegate executed when the application's internal middleware pipeline is exhausted. The ramifications for end users are as follows: The $finalHandler argument to Application 's constructor, which previously was a callable , is now called $defaultDelegate , and needs to be a DelegateInterface instance. getFinalHandler() no longer exists; we have added getDefaultDelegate() . The service Zend\\Expressive\\FinalHandler is no longer used. A new service, Zend\\Expressive\\Delegate\\DefaultDelegate , is used by ApplicationFactory , and, if present, will be used to inject the $defaultDelegate argument of the Application constructor. We have removed the following classes, which either provided final handlers, or acted as factories for them: Zend\\Expressive\\TemplatedErrorHandler Zend\\Expressive\\WhoopsErrorHandler Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory If you use the vendor/bin/expressive-pipeline-from-config tool to migrate your application to programmatic pipelines, as described below, the DefaultDelegate service will be mapped to Zend\\Expressive\\Container\\NotFoundDelegateFactory , which will provide an instance of Zend\\Expressive\\Delegate\\NotFoundDelegate . This new class will produce a 404 response, using a template if the Zend\\Expressive\\Template\\TemplateRendererInterface service is present, but otherwise producing a plain text response. Application's built using the 2.0 version of the skeleton application will have these features enabled by default.","title":"Final handlers become default delegates"},{"location":"v2/reference/migration/#programmatic-middleware-pipelines","text":"Starting with Expressive 1.1, we recommended programmatic creation of pipelines and routing ; the Expressive 1.1 migration guide provides more detail. With Expressive 2.0, this is now the default option shipped in the skeleton. If you are upgrading from version 1 and are not currently using programmatic pipelines, we provide a migration tool that will convert your application to do so. The tool is available via the package zendframework/zend-expressive-tooling . You may install this package in one of the following ways: Via the vendor binary ./vendor/bin/expressive-tooling : bash $ ./vendor/bin/expressive-tooling # install $ ./vendor/bin/expressive-tooling remove # uninstall Using Composer: bash $ composer require --dev zendframework/zend-expressive-tooling # install $ composer remove --dev zendframework/zend-expressive-tooling # uninstall Once installed, you will use the vendor/bin/expressive-pipeline-from-config command. This command does the following: Reads your middleware_pipeline configuration, and generates a programmatic pipeline for you, which is then stored in config/pipeline.php . The generated pipeline contains the following additions: The first middleware in the pipeline is Zend\\Stratigility\\Middleware\\OriginalMessages , which injects the incoming request, URI, and response as the request attributes originalRequest , originalUri , and originalResponse , respectively. (This can aid URI generation in nested middleware later.) The second middleware in the pipeline is Zend\\Stratigility\\Middleware\\ErrorHandler . The last middleware in the pipeline is Zend\\Expressive\\Middleware\\NotFoundHandler . Reads your routes configuration, and generates a programmatic routing table for you, which is then stored in config/routes.php . Adds a new configuration file, config/autoload/programmatic-pipeline.global.php , which enables the programmatic_pipelines configuration flag. Additionally, it adds dependency configuration for the new error handlers. Inserts two lines before the $app->run() statement of your public/index.php , one each to require config/pipeline.php and config/routes.php . Your middleware_pipeline and routes configuration are not removed at this time, to allow you to test and verify your application first; however, due to the configuration in config/autoload/programmatic-pipeline.global.php , these are now ignored. If you wish to use Whoops in your development environment, you may add the following to a local configuration file (e.g., config/autoload/local.php ): use Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory; use Zend\\Expressive\\Middleware\\ErrorResponseGenerator; return [ 'dependencies' => [ 'factories' => [ ErrorResponseGenerator::class => WhoopsErrorResponseGeneratorFactory::class, ], ], ]; Other things you may want to do: The ErrorHandler entry could potentially be moved inwards a few layers. As an example, the ServerUrlMiddleware has no possibility of raising an exception or error, and could be moved outwards; you could do similarly for any middleware that only injects additional response headers. Remove any Stratigility-style error middleware (middleware expecting an error as the first argument). If any specialized error handling should occur, add additional middleware into the pipeline that can catch exceptions, and have that middleware re-throw for exceptions it cannot handle. (Use the vendor/bin/expressive-scan-for-error-middleware command from zendframework/zend-expressive-tooling to assist in this.) Consider providing your own Zend\\Stratigility\\NoopFinalHandler implementation; this will now only be invoked if the queue is exhausted, and could return a generic 404 page, raise an exception, etc.","title":"Programmatic middleware pipelines"},{"location":"v2/reference/migration/#handling-head-and-options-requests","text":"Prior to 2.0, it was possible to route middleware that could not handle HEAD and/or OPTIONS requests. Per RFC 7231, section 4.1 , \"all general-purpose servers MUST support the methods GET and HEAD. All other methods are OPTIONAL.\" Additionally, most servers and implementors agree that OPTIONS should be supported for any given resource, so that consumers can determine what methods are allowed for the given resource. To make this happen, the Expressive project implemented several features. First, zend-expressive-router 1.3.0 introduced several features in both Zend\\Expressive\\Router\\Route and Zend\\Expressive\\Router\\RouteResult to help consumers implement support for HEAD and OPTIONS in an automated way. The Route class now has two new methods, implicitHead() and implicitOptions() ; these each return a boolean true value if support for those methods is implicit \u2014 i.e., not defined explicitly for the route. The RouteResult class now introduces a new factory method, fromRoute() , that will create an instance from a Route instance; this then allows consumers of a RouteResult to query the Route to see if a matched HEAD or OPTIONS request needs automated handling. Each of the supported router implementations were updated to use this method, as well as to return a successful routing result if HEAD and/or OPTIONS requests are submitted, but the route does not explicitly support the method. Within Expressive itself, we now offer two new middleware to provide this automation: Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware If you want to support these methods automatically, each of these should be enabled between the routing and dispatch middleware. If you use the expressive-pipeline-from-config tool as documented in the programmatic pipeline migration section , entries for each will be injected into your generated pipeline. Please see the chapter on the implicit methods middleware for more information on each.","title":"Handling HEAD and OPTIONS requests"},{"location":"v2/reference/migration/#router-interface-changes","text":"Expressive 2.0 uses zendframework/zend-expressive-router 2.1+. Version 2.0 of that package introduced a change to the Zend\\Expressive\\Router\\RouterInterface::generateUri() method; it now accepts an additional, optional, third argument, array $options = [] , which can be used to pass router-specific options when generating a URI. As an example, the implementation that uses zendframework/zend-router might use these options to pass a translator instance in order to translate a path segment to the currently selected locale. For consumers, his represents no backwards-incompatible change; consumers may opt-in to the new argument at will. For those implementing the interface, upgrading will require updating your router implementation's signature to match the new interface: public function generateUri( string $name, array $substitutions = [], array $options = [] ) : string","title":"Router interface changes"},{"location":"v2/reference/migration/#url-helper-changes","text":"Expressive 2.0 uses zendframework/zend-expressive-helpers version 3.0+. This new version updates the signature of the Zend\\Expressive\\Helper\\UrlHelper from: function ( $routeName, array $routeParams = [] ) : string to: function ( $routeName, array $routeParams = [], $queryParams = [], $fragmentIdentifier = null, array $options = [] ) : string For consumers, this should represent a widening of features, and will not require any changes, unless you wish to opt-in to the new arguments. See the UrlHelper documentation for information on each argument. For any users who were extending the class, you will need to update your extension accordingly.","title":"URL helper changes"},{"location":"v2/reference/migration/#zend-view-renderer-changes","text":"Expressive 2.0 will use zend-expressive-zendviewrenderer 1.3+ if that renderer is chosen. Starting with 1.3.0 of that renderer, you may now pass a boolean false value for the layout variable when calling either addDefaultParam() or render() on the renderer instance in order to disable the layout.","title":"zend-view renderer changes"},{"location":"v2/reference/migration/#twig-renderer-changes","text":"Expressive 2.0 will use zend-expressive-twigrenderer 1.3+ if that renderer is chosen. Starting with 1.3.0 of that renderer, Twig 2.1+ is now supported.","title":"Twig renderer changes"},{"location":"v2/reference/migration/#adopting-a-modular-architecture","text":"Expressive 2.0 ships with support for modular architectures from the outset, as detailed in the chapter on modules . If you wish to update your application to use these features, you will need to install the following packages: zendframework/zend-config-aggregator zendframework/zend-component-installer As an example: $ composer require zendframework/zend-config-aggregator \\ > zendframework/zend-component-installer Once installed, you should update your config/config.php file to read as follows: <?php use Zend\\ConfigAggregator\\ArrayProvider; use Zend\\ConfigAggregator\\ConfigAggregator; use Zend\\ConfigAggregator\\PhpFileProvider; // To enable or disable caching, set the `ConfigAggregator::ENABLE_CACHE` boolean in // `config/autoload/local.php`. $cacheConfig = [ 'config_cache_path' => 'data/config-cache.php', ]; $aggregator = new ConfigAggregator([ // Include cache configuration new ArrayProvider($cacheConfig), // Default App module config App\\ConfigProvider::class, // Load application config in a pre-defined order in such a way that local settings // overwrite global settings. (Loaded as first to last): // - `global.php` // - `*.global.php` // - `local.php` // - `*.local.php` new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'), // Load development config if it exists new PhpFileProvider('config/development.config.php'), ], $cacheConfig['config_cache_path']); return $aggregator->getMergedConfig(); The above should mimic what you already had in place; if it does not, check to see if there are additional paths you were globbing previously.","title":"Adopting a modular architecture"},{"location":"v2/reference/usage-examples/","text":"Usage Examples Below are several usage examples, covering a variety of ways of creating and managing an application. In all examples, the assumption is the following directory structure: . \u251c\u2500\u2500 config \u251c\u2500\u2500 data \u251c\u2500\u2500 composer.json \u251c\u2500\u2500 public \u2502 \u2514\u2500\u2500 index.php \u251c\u2500\u2500 src \u2514\u2500\u2500 vendor We assume also that: You have installed zend-expressive per the installation instructions . public/ will be the document root of your application. Your own classes are under src/ with the top-level namespace App , and you have configured autoloading in your composer.json for those classes (this should be done for you during installation). Using the built-in web server You can use the built-in web server to run the examples. Run: $$$$FENCED_CODE_BLOCK_5e03bde9f0c2c1.43464966 from the application root to start up a web server running on port 8080, and then browse to http://localhost:8080/. If you used the Expressive installer, the following is equivalent: $$$$FENCED_CODE_BLOCK_5e03bde9f0c431.49888619 Setting up autoloading for the Application namespace In your composer.json file, place the following: $$$$FENCED_CODE_BLOCK_5e03bde9f0c583.95812931 Once done, run: $$$$FENCED_CODE_BLOCK_5e03bde9f0c6a2.28298443 Routing As noted in the Application documentation , routing is abstracted and can be accomplished by calling any of the following methods: route($path, $middleware, array $methods = null, $name = null) to route to a path and match any HTTP method, multiple HTTP methods, or custom HTTP methods. get($path, $middleware, $name = null) to route to a path that will only respond to the GET HTTP method. post($path, $middleware, $name = null) to route to a path that will only respond to the POST HTTP method. put($path, $middleware, $name = null) to route to a path that will only respond to the PUT HTTP method. patch($path, $middleware, $name = null) to route to a path that will only respond to the PATCH HTTP method. delete($path, $middleware, $name = null) to route to a path that will only respond to the DELETE HTTP method. All methods return a Zend\\Expressive\\Router\\Route method, which allows you to specify additional options to associate with the route (e.g., for specifying criteria, default values to match, etc.). As examples: // GET // This demonstrates passing a middleware instance (assuming $helloWorld is // valid middleware) $app->get('/', $helloWorld); // POST // This example specifies the middleware as a service name instead of as // actual executable middleware. $app->post('/trackback', 'TrackBack'); // PUT // This example shows operating on the returned route. In this case, it's adding // regex tokens to restrict what values for {id} will match. (The tokens feature // is specific to Aura.Router.) $app->put('/post/{id}', 'ReplacePost') ->setOptions([ 'tokens' => ['id' => '\\d+'], ]); // PATCH // This example builds on the one above. Expressive allows you to specify // the same path for a route matching on a different HTTP method, and // corresponding to different middleware. $app->patch('/post/{id}', 'UpdatePost') ->setOptions([ 'tokens' => ['id' => '\\d+'], ]); // DELETE $app->delete('/post/{id}', 'DeletePost') ->setOptions([ 'tokens' => ['id' => '\\d+'], ]); // Matching ALL HTTP methods // If the underlying router supports matching any HTTP method, the following // will do so. Note: FastRoute *requires* you to specify the HTTP methods // allowed explicitly, and does not support wildcard routes. As such, the // following example maps to the combination of HEAD, OPTIONS, GET, POST, PATCH, // PUT, TRACE, and DELETE. // Just like the previous examples, it returns a Route instance that you can // further manipulate. $app->route('/post/{id}', 'HandlePost') ->setOptions([ 'tokens' => ['id' => '\\d+'], ]); // Matching multiple HTTP methods // You can pass an array of HTTP methods as a third argument to route(); in such // cases, routing will match if any of the specified HTTP methods are provided. $app->route('/post', 'HandlePostCollection', ['GET', 'POST']); // Matching NO HTTP methods // Pass an empty array to the HTTP methods. HEAD and OPTIONS will still be // honored. (In FastRoute, GET is also honored.) $app->route('/post', 'WillThisHandlePost', []); Finally, if desired, you can create a Zend\\Expressive\\Router\\Route instance manually and pass it to route() as the sole argument: $route = new Route('/post', 'HandlePost', ['GET', 'POST']); $route->setOptions($options); $app->route($route); Hello World using a Container Expressive works with PSR-11 Containers , though it's an optional feature. By default, if you use the AppFactory , it will use zend-servicemanager so long as that package is installed. In the following example, we'll populate the container with our middleware, and the application will pull it from there when matched. Edit your public/index.php to read as follows: use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Zend\\Diactoros\\Response\\JsonResponse; use Zend\\Diactoros\\Response\\TextResponse; use Zend\\Expressive\\AppFactory; use Zend\\ServiceManager\\ServiceManager; require __DIR__ . '/../vendor/autoload.php'; $container = new ServiceManager(); $container->setFactory('HelloWorld', function ($container) { return function ($request, DelegateInterface $delegate) { return new TextResponse('Hello, world!'); }; }); $container->setFactory('Ping', function ($container) { return function ($request, DelegateInterface $delegate) { return new JsonResponse(['ack' => time()]); }; }); $app = AppFactory::create($container); $app->get('/', 'HelloWorld'); $app->get('/ping', 'Ping'); $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); $app->run(); In the example above, we pass our container to AppFactory . We could have also done this instead: $app = AppFactory::create(); $container = $app->getContainer(); and then added our service definitions. We recommend passing the container to the factory instead; if we ever change which container we use by default, your code might not work! The following two lines are the ones of interest: $app->get('/', 'HelloWorld'); $app->get('/ping', 'Ping'); These map the two paths to service names instead of callables. When routing matches a path, it does the following: If the middleware provided when defining the route is callable, it uses it directly. If the middleware is a valid service name in the container, it pulls it from the container. This is what happens in this example. Finally, if no container is available, or the service name is not found in the container, it checks to see if it's a valid class name; if so, it instantiates and returns the class instance. If you fire up your web server, you'll find that the / and /ping paths continue to work. One other approach you could take would be to define the application itself in the container, and then pull it from there: $container->setFactory('Zend\\Expressive\\Application', function ($container) { $app = AppFactory::create($container); $app->get('/', 'HelloWorld'); $app->get('/ping', 'Ping'); return $app; }); $app = $container->get('Zend\\Expressive\\Application'); $app->run(); This is a nice way to encapsulate the application creation. You could then potentially move all service configuration to another file! (We already document an ApplicationFactory for exactly this scenario. ) Hello World using a Configuration-Driven Container In the above example, we configured our middleware as services, and then passed our service container to the application. At the end, we hinted that you could potentially define the application itself as a service. Expressive already provides a service factory for the application instance to provide fine-grained control over your application. In this example, we'll leverage it, defining our routes via configuration. First, we're going to leverage zend-config to merge configuration files. This is important, as it allows us to define local, environment-specific configuration in files that we then can exclude from our repository. This practice ensures that things like credentials are not accidentally published in a public repository, and also provides a mechanism for slip-streaming in configuration based on our environment (you might use different settings in development than in production, after all!). First, install zend-config and zend-stdlib: $ composer require zendframework/zend-config zendframework/zend-stdlib Now we can start creating our configuration files and container factories. In config/config.php , place the following: <?php use Zend\\Stdlib\\ArrayUtils; use Zend\\Stdlib\\Glob; $config = []; // Load configuration from autoload path foreach (Glob::glob('config/autoload/{{,*.}global,{,*.}local}.php', Glob::GLOB_BRACE) as $file) { $config = ArrayUtils::merge($config, include $file); } // Return an ArrayObject so we can inject the config as a service in Aura.Di // and still use array checks like ``is_array``. return new ArrayObject($config, ArrayObject::ARRAY_AS_PROPS); In config/container.php , place the following: <?php use Zend\\ServiceManager\\Config; use Zend\\ServiceManager\\ServiceManager; // Load configuration $config = require __DIR__.'/config.php'; // Build container $container = new ServiceManager(); (new Config($config['dependencies']))->configureServiceManager($container); // Inject config $container->setService('config', $config); return $container; In config/autoload/dependencies.global.php , place the following: <?php use Zend\\ServiceManager\\Factory\\InvokableFactory; return [ 'dependencies' => [ 'invokables' => [ \\Application\\HelloWorldAction::class => InvokableFactory::class, \\Application\\PingAction::class => InvokableFactory::class, ], 'factories' => [ \\Zend\\Expressive\\Application::class => \\Zend\\Expressive\\Container\\ApplicationFactory::class, ], ] ]; In config/autoload/routes.global.php , place the following: <?php return [ 'routes' => [ [ 'path' => '/', 'middleware' => \\Application\\HelloWorldAction::class, 'allowed_methods' => ['GET'], ], [ 'path' => '/ping', 'middleware' => \\Application\\PingAction::class, 'allowed_methods' => ['GET'], ], ], ]; In src/Application/HelloWorld.php , place the following: <?php namespace Application; class HelloWorld { public function __invoke($req, $res, $next) { $res->getBody()->write('Hello, world!'); return $res; } } In src/Application/Ping.php , place the following: <?php namespace Application; use Zend\\Diactoros\\Response\\JsonResponse; class Ping { public function __invoke($req, $res, $next) { return new JsonResponse(['ack' => time()]); } } After that\u2019s done run: composer dump-autoload Finally, in public/index.php , place the following: <?php // Change to the project root, to simplify resolving paths chdir(dirname(__DIR__)); // Setup autoloading require 'vendor/autoload.php'; $container = include 'config/container.php'; $app = $container->get(Zend\\Expressive\\Application::class); $app->run(); Notice that our index file now doesn't have any code related to setting up the application any longer! All it does is setup autoloading, retrieve our service container, pull the application from it, and run it. Our choices for container, router, etc. are all abstracted, and if we change our mind later, this code will continue to work. Firing up the web server, you'll see the same responses as the previous examples. Hybrid Container and Programmatic Creation The above example may look a little daunting at first. By making everything configuration-driven, you sometimes lose a sense for how the code all fits together. Fortunately, you can mix the two. Building on the example above, we'll add a new route and middleware. Between pulling the application from the container and calling $app->run() , add the following in your public/index.php : $app->post('/post', function ($request, \\Interop\\Http\\ServerMiddleware\\DelegateInterface $delegate) { return new \\Zend\\Diactoros\\Response\\TextResponse('IN POST!'); }); Note that we're using post() here; that means you'll have to use cURL, HTTPie, Postman, or some other tool to test making a POST request to the path: $ curl -X POST http://localhost:8080/post You should see IN POST! for the response! Using this approach, you can build re-usable applications that are container-driven, and add one-off routes and middleware as needed. Using the container to register middleware If you use a container to fetch your application instance, you have an additional option for specifying middleware for the pipeline: configuration: <?php return [ 'routes' => [ [ 'path' => '/path/to/match', 'middleware' => 'Middleware Service Name or Callable', 'allowed_methods' => ['GET', 'POST', 'PATCH'], 'options' => [ 'stuff' => 'to', 'pass' => 'to', 'the' => 'underlying router', ], ], // etc. ], 'middleware_pipeline' => [ // See specification below ], ]; The key to note is middleware_pipeline , which is an array of middlewares to register in the pipeline; each will each be pipe() 'd to the Application in the order specified. Each middleware specified must be in the following form: [ // required: 'middleware' => 'Name of middleware service, or a callable', // optional: 'path' => '/path/to/match', 'priority' => 1, // Integer ] Priority should be an integer, and follows the semantics of SplPriorityQueue : higher numbers indicate higher priority (top of the queue; executed earliest), while lower numbers indicated lower priority (bottom of the queue, executed last); negative values are low priority . Items of the same priority are executed in the order in which they are attached. The default priority is 1, and this priority is used by the routing and dispatch middleware. To indicate that middleware should execute before these, use a priority higher than 1. The above specification can be used for all middleware, with one exception: registration of the routing and/or dispatch middleware that Expressive provides. In these cases, use the following constants, which will be caught by the factory and expanded: Zend\\Expressive\\Application::ROUTING_MIDDLEWARE for the routing middleware; this should always come before the dispatch middleware. Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE for the dispatch middleware. As an example: return [ 'middleware_pipeline' => [ [ /* ... */ ], Zend\\Expressive\\Application::ROUTING_MIDDLEWARE, Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE, [ /* ... */ ], ], ]; Place routing middleware correctly If you are defining routes and defining other middleware for the pipeline, you must add the routing middleware. When you do so, make sure you put it at the appropriate location in the pipeline. Typically, you will place any middleware you want to execute on all requests prior to the routing middleware. This includes utilities for bootstrapping the application (such as injection of the ServerUrlHelper ), utilities for injecting common response headers (such as CORS support), etc. Make sure these middleware specifications include the priority key, and that the value of this key is greater than 1. Use priority to shape the specific workflow you want for your middleware. Middleware items may be any valid middleware , including arrays of middleware, which indicate a nested middleware pipeline; these may even contain the routing and dispatch middleware constants: return [ 'middleware_pipeline' => [ [ /* ... */ ], 'routing' => [ 'middleware' => [ Zend\\Expressive\\Application::ROUTING_MIDDLEWARE, /* ... middleware that introspects routing results ... */ Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE, ], 'priority' => 1, ], [ /* ... */ ], ], ]; Pipeline keys are ignored Keys in a middleware_pipeline specification are ignored. However, they can be useful when merging several configurations; if multiple configuration files specify the same key, then those entries will be merged. Be aware, however, that the middleware entry for each, since it is an indexed array, will merge arrays by appending; in other words, order will not be guaranteed within that array after merging. If order is critical, define a middleware spec with priority keys. The path, if specified, can only be a literal path to match, and is typically used for segregating middleware applications or applying rules to subsets of an application that match a common path root. Segregating your application to a subpath One benefit of a middleware-based application is the ability to compose middleware and segregate them by paths. Zend\\Expressive\\Application is itself middleware, allowing you to do exactly that if desired. In the following example, we'll assume that $api and $blog are Zend\\Expressive\\Application instances, and compose them into a Zend\\Stratigility\\MiddlewarePipe . use Zend\\Diactoros\\Server; use Zend\\Diactoros\\ServerRequestFactory; use Zend\\Stratigility\\MiddlewarePipe; require __DIR__ . '/../vendor/autoload.php'; $app = new MiddlewarePipe(); $app->pipe('/blog', $blog); $app->pipe('/api', $api); $server = Server::createServerFromRequest( $app, ServerRequestFactory::fromGlobals() ); $server->listen(); You could also compose them in an Application instance, and utilize run() : $app = AppFactory::create(); $app->pipe('/blog', $blog); $app->pipe('/api', $api); $app->run(); This approach allows you to develop discrete applications and compose them together to create a website.","title":"Examples"},{"location":"v2/reference/usage-examples/#usage-examples","text":"Below are several usage examples, covering a variety of ways of creating and managing an application. In all examples, the assumption is the following directory structure: . \u251c\u2500\u2500 config \u251c\u2500\u2500 data \u251c\u2500\u2500 composer.json \u251c\u2500\u2500 public \u2502 \u2514\u2500\u2500 index.php \u251c\u2500\u2500 src \u2514\u2500\u2500 vendor We assume also that: You have installed zend-expressive per the installation instructions . public/ will be the document root of your application. Your own classes are under src/ with the top-level namespace App , and you have configured autoloading in your composer.json for those classes (this should be done for you during installation).","title":"Usage Examples"},{"location":"v2/reference/usage-examples/#hello-world-using-a-container","text":"Expressive works with PSR-11 Containers , though it's an optional feature. By default, if you use the AppFactory , it will use zend-servicemanager so long as that package is installed. In the following example, we'll populate the container with our middleware, and the application will pull it from there when matched. Edit your public/index.php to read as follows: use Interop\\Http\\ServerMiddleware\\DelegateInterface; use Zend\\Diactoros\\Response\\JsonResponse; use Zend\\Diactoros\\Response\\TextResponse; use Zend\\Expressive\\AppFactory; use Zend\\ServiceManager\\ServiceManager; require __DIR__ . '/../vendor/autoload.php'; $container = new ServiceManager(); $container->setFactory('HelloWorld', function ($container) { return function ($request, DelegateInterface $delegate) { return new TextResponse('Hello, world!'); }; }); $container->setFactory('Ping', function ($container) { return function ($request, DelegateInterface $delegate) { return new JsonResponse(['ack' => time()]); }; }); $app = AppFactory::create($container); $app->get('/', 'HelloWorld'); $app->get('/ping', 'Ping'); $app->pipeRoutingMiddleware(); $app->pipeDispatchMiddleware(); $app->run(); In the example above, we pass our container to AppFactory . We could have also done this instead: $app = AppFactory::create(); $container = $app->getContainer(); and then added our service definitions. We recommend passing the container to the factory instead; if we ever change which container we use by default, your code might not work! The following two lines are the ones of interest: $app->get('/', 'HelloWorld'); $app->get('/ping', 'Ping'); These map the two paths to service names instead of callables. When routing matches a path, it does the following: If the middleware provided when defining the route is callable, it uses it directly. If the middleware is a valid service name in the container, it pulls it from the container. This is what happens in this example. Finally, if no container is available, or the service name is not found in the container, it checks to see if it's a valid class name; if so, it instantiates and returns the class instance. If you fire up your web server, you'll find that the / and /ping paths continue to work. One other approach you could take would be to define the application itself in the container, and then pull it from there: $container->setFactory('Zend\\Expressive\\Application', function ($container) { $app = AppFactory::create($container); $app->get('/', 'HelloWorld'); $app->get('/ping', 'Ping'); return $app; }); $app = $container->get('Zend\\Expressive\\Application'); $app->run(); This is a nice way to encapsulate the application creation. You could then potentially move all service configuration to another file! (We already document an ApplicationFactory for exactly this scenario. )","title":"Hello World using a Container"},{"location":"v2/reference/usage-examples/#hello-world-using-a-configuration-driven-container","text":"In the above example, we configured our middleware as services, and then passed our service container to the application. At the end, we hinted that you could potentially define the application itself as a service. Expressive already provides a service factory for the application instance to provide fine-grained control over your application. In this example, we'll leverage it, defining our routes via configuration. First, we're going to leverage zend-config to merge configuration files. This is important, as it allows us to define local, environment-specific configuration in files that we then can exclude from our repository. This practice ensures that things like credentials are not accidentally published in a public repository, and also provides a mechanism for slip-streaming in configuration based on our environment (you might use different settings in development than in production, after all!). First, install zend-config and zend-stdlib: $ composer require zendframework/zend-config zendframework/zend-stdlib Now we can start creating our configuration files and container factories. In config/config.php , place the following: <?php use Zend\\Stdlib\\ArrayUtils; use Zend\\Stdlib\\Glob; $config = []; // Load configuration from autoload path foreach (Glob::glob('config/autoload/{{,*.}global,{,*.}local}.php', Glob::GLOB_BRACE) as $file) { $config = ArrayUtils::merge($config, include $file); } // Return an ArrayObject so we can inject the config as a service in Aura.Di // and still use array checks like ``is_array``. return new ArrayObject($config, ArrayObject::ARRAY_AS_PROPS); In config/container.php , place the following: <?php use Zend\\ServiceManager\\Config; use Zend\\ServiceManager\\ServiceManager; // Load configuration $config = require __DIR__.'/config.php'; // Build container $container = new ServiceManager(); (new Config($config['dependencies']))->configureServiceManager($container); // Inject config $container->setService('config', $config); return $container; In config/autoload/dependencies.global.php , place the following: <?php use Zend\\ServiceManager\\Factory\\InvokableFactory; return [ 'dependencies' => [ 'invokables' => [ \\Application\\HelloWorldAction::class => InvokableFactory::class, \\Application\\PingAction::class => InvokableFactory::class, ], 'factories' => [ \\Zend\\Expressive\\Application::class => \\Zend\\Expressive\\Container\\ApplicationFactory::class, ], ] ]; In config/autoload/routes.global.php , place the following: <?php return [ 'routes' => [ [ 'path' => '/', 'middleware' => \\Application\\HelloWorldAction::class, 'allowed_methods' => ['GET'], ], [ 'path' => '/ping', 'middleware' => \\Application\\PingAction::class, 'allowed_methods' => ['GET'], ], ], ]; In src/Application/HelloWorld.php , place the following: <?php namespace Application; class HelloWorld { public function __invoke($req, $res, $next) { $res->getBody()->write('Hello, world!'); return $res; } } In src/Application/Ping.php , place the following: <?php namespace Application; use Zend\\Diactoros\\Response\\JsonResponse; class Ping { public function __invoke($req, $res, $next) { return new JsonResponse(['ack' => time()]); } } After that\u2019s done run: composer dump-autoload Finally, in public/index.php , place the following: <?php // Change to the project root, to simplify resolving paths chdir(dirname(__DIR__)); // Setup autoloading require 'vendor/autoload.php'; $container = include 'config/container.php'; $app = $container->get(Zend\\Expressive\\Application::class); $app->run(); Notice that our index file now doesn't have any code related to setting up the application any longer! All it does is setup autoloading, retrieve our service container, pull the application from it, and run it. Our choices for container, router, etc. are all abstracted, and if we change our mind later, this code will continue to work. Firing up the web server, you'll see the same responses as the previous examples.","title":"Hello World using a Configuration-Driven Container"},{"location":"v2/reference/usage-examples/#hybrid-container-and-programmatic-creation","text":"The above example may look a little daunting at first. By making everything configuration-driven, you sometimes lose a sense for how the code all fits together. Fortunately, you can mix the two. Building on the example above, we'll add a new route and middleware. Between pulling the application from the container and calling $app->run() , add the following in your public/index.php : $app->post('/post', function ($request, \\Interop\\Http\\ServerMiddleware\\DelegateInterface $delegate) { return new \\Zend\\Diactoros\\Response\\TextResponse('IN POST!'); }); Note that we're using post() here; that means you'll have to use cURL, HTTPie, Postman, or some other tool to test making a POST request to the path: $ curl -X POST http://localhost:8080/post You should see IN POST! for the response! Using this approach, you can build re-usable applications that are container-driven, and add one-off routes and middleware as needed.","title":"Hybrid Container and Programmatic Creation"},{"location":"v2/reference/usage-examples/#segregating-your-application-to-a-subpath","text":"One benefit of a middleware-based application is the ability to compose middleware and segregate them by paths. Zend\\Expressive\\Application is itself middleware, allowing you to do exactly that if desired. In the following example, we'll assume that $api and $blog are Zend\\Expressive\\Application instances, and compose them into a Zend\\Stratigility\\MiddlewarePipe . use Zend\\Diactoros\\Server; use Zend\\Diactoros\\ServerRequestFactory; use Zend\\Stratigility\\MiddlewarePipe; require __DIR__ . '/../vendor/autoload.php'; $app = new MiddlewarePipe(); $app->pipe('/blog', $blog); $app->pipe('/api', $api); $server = Server::createServerFromRequest( $app, ServerRequestFactory::fromGlobals() ); $server->listen(); You could also compose them in an Application instance, and utilize run() : $app = AppFactory::create(); $app->pipe('/blog', $blog); $app->pipe('/api', $api); $app->run(); This approach allows you to develop discrete applications and compose them together to create a website.","title":"Segregating your application to a subpath"},{"location":"v3/","text":"Expressive: PSR-15 Middleware in Minutes Expressive builds on Stratigility to provide a minimalist PSR-15 middleware framework for PHP, with the following features: Routing. Choose your own router; we support: Aura.Router FastRoute zend-router DI Containers, via PSR-11 Container . All middleware composed in Expressive may be retrieved from the composed container. Optionally, templating. We support: Plates Twig zend-view's PhpRenderer Error handling. Create templated error pages, or use tools like whoops for debugging purposes. Nested middleware applications. Write an application, and compose it later in another, optionally under a separate subpath. Simplified installation . Our custom Composer -based installer prompts you for your initial stack choices, giving you exactly the base you want to start from. Essentially, Expressive allows you to develop using the tools you prefer, and provides minimal structure and facilities to ease your development. Should I choose it over zend-mvc? That\u2019s a good question. Here\u2019s what we recommend. If you\u2019re keen to get started, then keep reading and get started writing your first middleware application today!","title":"Expressive: PSR-15 Middleware in Minutes"},{"location":"v3/#expressive-psr-15-middleware-in-minutes","text":"Expressive builds on Stratigility to provide a minimalist PSR-15 middleware framework for PHP, with the following features: Routing. Choose your own router; we support: Aura.Router FastRoute zend-router DI Containers, via PSR-11 Container . All middleware composed in Expressive may be retrieved from the composed container. Optionally, templating. We support: Plates Twig zend-view's PhpRenderer Error handling. Create templated error pages, or use tools like whoops for debugging purposes. Nested middleware applications. Write an application, and compose it later in another, optionally under a separate subpath. Simplified installation . Our custom Composer -based installer prompts you for your initial stack choices, giving you exactly the base you want to start from. Essentially, Expressive allows you to develop using the tools you prefer, and provides minimal structure and facilities to ease your development. Should I choose it over zend-mvc? That\u2019s a good question. Here\u2019s what we recommend. If you\u2019re keen to get started, then keep reading and get started writing your first middleware application today!","title":"Expressive: PSR-15 Middleware in Minutes"},{"location":"v3/why-expressive/","text":"Should You Choose zend-expressive Over zend-mvc? We recommend that you choose Expressive for any new project \u2014 if the choice is yours to make . Why Use zend-mvc? zend-mvc is a proven platform, with more than half a decade of development behind it. It is stable and battle-tested in production platforms. Because it is opinionated about project structure and architecture, fewer decisions need be made up front; developers know where new code goes, and how it will wire into the overall application. Additionally, a number of training courses exist, including offerings by Zend , allowing you or your team to fully learn the framework and take advantage of all its features. Finally, zend-mvc has a lively module ecosystem , allowing you to add features and capabilities to your application without needing to develop them from scratch. We Recommend Expressive zend-mvc has many preconceptions about how things work, yet they're very broad and general. What\u2019s more, it also has several pre-wired structures in place that may either aid you \u2014 or get in your way. As a result, you are required to know a lot of what those things are \u2014 if you want to use it optimally. And to acquire that depth of knowledge, you\u2019re going to need to spend a lot of time digging deep into zend-mvc\u2019s internals before you begin to get the most out of it. To quote Zend Framework project lead, Matthew Weier O\u2019Phinney : The problem is that zend-mvc is anything but beginner-friendly at this point. You're required to deep dive into the event manager, service manager, and module system \u2014 right from the outset; And to do this you need more than a passing understanding of object-oriented programming and a range of design patterns. Expressive (specifically applications based on the Expressive Skeleton Installer ) on the other hand, comes with barely any of these assumptions and requirements. It provides a very minimalist structure. Essentially all you have to become familiar with are five core components. These are: A DI container. A router. An error handler for development. A template engine (if you\u2019re not creating an API). PSR-7 messages and PSR-15 middleware and request handlers. In many cases, these are provided for you by the skeleton, and do not require any additional knowledge on your part. Given that, you can quickly get up to speed with the framework and begin creating the application that you need. We believe that this approach \u2014 in contrast to the zend-mvc approach \u2014 is more flexible and accommodating. What\u2019s more, you can mix and match the types of applications that you create. Do you just need an API? Great; you can do that quite quickly. Do you want an HTML-based front-end? That\u2019s available too. When building applications with Expressive, you can make use of the various Zend components, or any third-party components or middleware. You can pick and choose what you need, as and when you need it. You\u2019re not bound by many, if any, constraints and design decisions. In Conclusion For what it\u2019s worth, we\u2019re not saying that zend-mvc is a poor choice! What we are saying is: The learning curve, from getting started to building the first application, is significantly lower with Expressive The ways in which you can create applications, whether through multiple pieces of middleware or by combining multiple Expressive apps, into one larger one, is a much more efficient and fluid way to work Ultimately, the choice is always up to you, your team, and your project\u2019s needs. We just want to ensure that you\u2019ve got all the information you need, to make an informed decision.","title":"Why choose Expressive?"},{"location":"v3/why-expressive/#should-you-choose-zend-expressive-over-zend-mvc","text":"We recommend that you choose Expressive for any new project \u2014 if the choice is yours to make .","title":"Should You Choose zend-expressive Over zend-mvc?"},{"location":"v3/why-expressive/#why-use-zend-mvc","text":"zend-mvc is a proven platform, with more than half a decade of development behind it. It is stable and battle-tested in production platforms. Because it is opinionated about project structure and architecture, fewer decisions need be made up front; developers know where new code goes, and how it will wire into the overall application. Additionally, a number of training courses exist, including offerings by Zend , allowing you or your team to fully learn the framework and take advantage of all its features. Finally, zend-mvc has a lively module ecosystem , allowing you to add features and capabilities to your application without needing to develop them from scratch.","title":"Why Use zend-mvc?"},{"location":"v3/why-expressive/#we-recommend-expressive","text":"zend-mvc has many preconceptions about how things work, yet they're very broad and general. What\u2019s more, it also has several pre-wired structures in place that may either aid you \u2014 or get in your way. As a result, you are required to know a lot of what those things are \u2014 if you want to use it optimally. And to acquire that depth of knowledge, you\u2019re going to need to spend a lot of time digging deep into zend-mvc\u2019s internals before you begin to get the most out of it. To quote Zend Framework project lead, Matthew Weier O\u2019Phinney : The problem is that zend-mvc is anything but beginner-friendly at this point. You're required to deep dive into the event manager, service manager, and module system \u2014 right from the outset; And to do this you need more than a passing understanding of object-oriented programming and a range of design patterns. Expressive (specifically applications based on the Expressive Skeleton Installer ) on the other hand, comes with barely any of these assumptions and requirements. It provides a very minimalist structure. Essentially all you have to become familiar with are five core components. These are: A DI container. A router. An error handler for development. A template engine (if you\u2019re not creating an API). PSR-7 messages and PSR-15 middleware and request handlers. In many cases, these are provided for you by the skeleton, and do not require any additional knowledge on your part. Given that, you can quickly get up to speed with the framework and begin creating the application that you need. We believe that this approach \u2014 in contrast to the zend-mvc approach \u2014 is more flexible and accommodating. What\u2019s more, you can mix and match the types of applications that you create. Do you just need an API? Great; you can do that quite quickly. Do you want an HTML-based front-end? That\u2019s available too. When building applications with Expressive, you can make use of the various Zend components, or any third-party components or middleware. You can pick and choose what you need, as and when you need it. You\u2019re not bound by many, if any, constraints and design decisions.","title":"We Recommend Expressive"},{"location":"v3/why-expressive/#in-conclusion","text":"For what it\u2019s worth, we\u2019re not saying that zend-mvc is a poor choice! What we are saying is: The learning curve, from getting started to building the first application, is significantly lower with Expressive The ways in which you can create applications, whether through multiple pieces of middleware or by combining multiple Expressive apps, into one larger one, is a much more efficient and fluid way to work Ultimately, the choice is always up to you, your team, and your project\u2019s needs. We just want to ensure that you\u2019ve got all the information you need, to make an informed decision.","title":"In Conclusion"},{"location":"v3/cookbook/access-common-data-in-templates/","text":"How Can I Access Common Data In Templates? Templates often need access to common request data, such as request attributes, the current route name, the currently authenticated user, and more. Wrangling all of that data in every single handler, however, often leads to code duplication, and the possibility of accidently omitting some of that data. How can you make such data available to all templates? The approach detailed in this recipe involves creating a middleware that calls on the template renderer's addDefaultParam() method. Foolowing is an example that injects the current user, the matched route name, and all flash messages via a single middleware. // In src/App/Middleware/TemplateDefaultsMiddleware.php (flat structure), or // in src/App/src/Middleware/TemplateDefaultsMiddleware.php (modular structure): <?php declare(strict_types=1); namespace App\\Middleware; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Router\\RouteResult; use Zend\\Expressive\\Session\\Authentication\\UserInterface; use Zend\\Expressive\\Flash\\FlashMessagesInterface; use Zend\\Expressive\\Flash\\FlashMessageMiddleware; use Zend\\Expressive\\Template\\TemplateRendererInterface; class TemplateDefaultsMiddleware implements MiddlewareInterface { /** @var TemplateRendererInterface */ private $templateRenderer; public function __construct(TemplateRendererInterface $templateRenderer) { $this->templateRenderer = $templateRenderer; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // Inject the current user, or null if there isn't one. $this->templateRenderer->addDefaultParam( TemplateRendererInterface::TEMPLATE_ALL, 'security', // This is named security so it will not interfere with your user admin pages $request->getAttribute(UserInterface::class) ); // Inject the currently matched route name. $routeResult = $request->getAttribute(RouteResult::class); $this->templateRenderer->addDefaultParam( TemplateRendererInterface::TEMPLATE_ALL, 'matchedRouteName', $routeResult ? $routeResult->getMatchedRouteName() : null ); // Inject all flash messages /** @var FlashMessagesInterface $flashMessages */ $flashMessages = $request->getAttribute(FlashMessageMiddleware::FLASH_ATTRIBUTE); $this->templateRenderer->addDefaultParam( TemplateRendererInterface::TEMPLATE_ALL, 'notifications', $flashMessages ? $flashMessages->getFlashes() : [] ); // Inject any other data you always need in all your templates... return $handler->handle($request); } } Next you need to create a factory for this middleware and register it with the DI container; zend-expressive-tooling provides functionality for doing so: $ ./vendor/bin/expressive factory:create \"App\\Middleware\\TemplateDefaultsMiddleware\" Once the factory is created, you can add this to any route that may generate a template: // In config/routes.php: $app->get('/some/resource/{id}', [ App\\Middleware\\TemplateDefaultsMiddleware::class, SomeResourceHandler::class, ]); Alternately, if you want it to apply to any handler, place it in your application pipeline immediately before the DispatchMiddleware : // In config/pipeline.php: $app->pipe(App\\Middleware\\TemplateDefaultsMiddleware::class); $app->pipe(DispatchMiddleware::class); Be aware, however, that if authentication is performed in per-handler pipelines, you will need to use the first approach to ensure that the authenticated user has been discovered.","title":"Provide Access to Common Data In Templates"},{"location":"v3/cookbook/access-common-data-in-templates/#how-can-i-access-common-data-in-templates","text":"Templates often need access to common request data, such as request attributes, the current route name, the currently authenticated user, and more. Wrangling all of that data in every single handler, however, often leads to code duplication, and the possibility of accidently omitting some of that data. How can you make such data available to all templates? The approach detailed in this recipe involves creating a middleware that calls on the template renderer's addDefaultParam() method. Foolowing is an example that injects the current user, the matched route name, and all flash messages via a single middleware. // In src/App/Middleware/TemplateDefaultsMiddleware.php (flat structure), or // in src/App/src/Middleware/TemplateDefaultsMiddleware.php (modular structure): <?php declare(strict_types=1); namespace App\\Middleware; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Router\\RouteResult; use Zend\\Expressive\\Session\\Authentication\\UserInterface; use Zend\\Expressive\\Flash\\FlashMessagesInterface; use Zend\\Expressive\\Flash\\FlashMessageMiddleware; use Zend\\Expressive\\Template\\TemplateRendererInterface; class TemplateDefaultsMiddleware implements MiddlewareInterface { /** @var TemplateRendererInterface */ private $templateRenderer; public function __construct(TemplateRendererInterface $templateRenderer) { $this->templateRenderer = $templateRenderer; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // Inject the current user, or null if there isn't one. $this->templateRenderer->addDefaultParam( TemplateRendererInterface::TEMPLATE_ALL, 'security', // This is named security so it will not interfere with your user admin pages $request->getAttribute(UserInterface::class) ); // Inject the currently matched route name. $routeResult = $request->getAttribute(RouteResult::class); $this->templateRenderer->addDefaultParam( TemplateRendererInterface::TEMPLATE_ALL, 'matchedRouteName', $routeResult ? $routeResult->getMatchedRouteName() : null ); // Inject all flash messages /** @var FlashMessagesInterface $flashMessages */ $flashMessages = $request->getAttribute(FlashMessageMiddleware::FLASH_ATTRIBUTE); $this->templateRenderer->addDefaultParam( TemplateRendererInterface::TEMPLATE_ALL, 'notifications', $flashMessages ? $flashMessages->getFlashes() : [] ); // Inject any other data you always need in all your templates... return $handler->handle($request); } } Next you need to create a factory for this middleware and register it with the DI container; zend-expressive-tooling provides functionality for doing so: $ ./vendor/bin/expressive factory:create \"App\\Middleware\\TemplateDefaultsMiddleware\" Once the factory is created, you can add this to any route that may generate a template: // In config/routes.php: $app->get('/some/resource/{id}', [ App\\Middleware\\TemplateDefaultsMiddleware::class, SomeResourceHandler::class, ]); Alternately, if you want it to apply to any handler, place it in your application pipeline immediately before the DispatchMiddleware : // In config/pipeline.php: $app->pipe(App\\Middleware\\TemplateDefaultsMiddleware::class); $app->pipe(DispatchMiddleware::class); Be aware, however, that if authentication is performed in per-handler pipelines, you will need to use the first approach to ensure that the authenticated user has been discovered.","title":"How Can I Access Common Data In Templates?"},{"location":"v3/cookbook/autowiring-routes-and-pipelines/","text":"How can I autowire routes and pipelines? Sometimes you may find you'd like to keep route definitions close to the handlers and middleware they will invoke. This is particularly important if you want to re-use a module or library in another project. In this recipe, we'll demonstrate two mechanisms for doing so. One is a built-in delegator factory , and the other is a custom delegator factory. ApplicationConfigInjectionDelegator Expressive ships with the class Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator , which can be used as a delegator factory for the Zend\\Expressive\\Application class in order to automate piping of pipeline middleware and routing to request handlers and middleware. The delegator factory looks for configuration that looks like the following: return [ 'middleware_pipeline' => [ [ // required: 'middleware' => 'Middleware service or pipeline', // optional: 'path' => '/path/to/match', // for path-segregated middleware 'priority' => 1, // integer; to ensure specific order ] ], 'routes' => [ [ 'path' => '/path/to/match', 'middleware' => 'Middleware service or pipeline', 'allowed_methods' => ['GET', 'POST', 'PATCH'], 'name' => 'route.name', 'options' => [ 'stuff' => 'to', 'pass' => 'to', 'the' => 'underlying router', ], ], 'another.route.name' => [ 'path' => '/another/path/to/match', 'middleware' => 'Middleware service or pipeline', 'allowed_methods' => ['GET', 'POST'], 'options' => [ 'more' => 'router', 'options' => 'here', ], ], ], ]; This configuration may be placed at the application level, in a file under config/autoload/ , or within a module's ConfigProvider class. For details on what values are accepted, see below. In order to enable the delegator factory, you will need to define the following service configuration somewhere, either at the application level in a config/autoload/ file, or within a module-specific ConfigProvider class: return [ 'dependencies' => [ 'delegators' => [ \\Zend\\Expressive\\Application::class => [ \\Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator::class, ], ], ], ]; Pipeline middleware Pipeline middleware are each described as an associative array, with the following keys: middleware ( required , string or array): the value should be a middleware service name, or an array of service names (in which case a MiddlewarePipe will be created and piped). path (optional, string): if you wish to path-segregate the middleware, provide a literal path prefix that must be matched in order to dispatch the given middleware. priority (optional, integer): The elements in the middleware_pipeline section are piped to the application in the order in which they are discovered \u2014 which could have ramifications if multiple components and/or modules provide pipeline middleware. If you wish to force a certain order, you may use the priority to do so. Higher value integers are piped first, lower value (including negative values), last. If two middleware use the same priority, they will be piped in the order discovered. Routed middleware Routed middleware are also each described as an associative array, using the following keys: path ( required , string): the path specification to match; this will be dependent on the router implementation you use. middleware ( required , string or array): the value should be a middleware service name, or an array of service names (in which case a MiddlewarePipe will be created and piped). allowed_methods (optional, array or value of `Zend\\Expressive\\Route\\HTTP_METHOD_ANY): the HTTP methods allowed for the route. If this is omitted, the assumption is any method is allowed. name (optional, string): the name of the route, if any; this can be used later to generate a URI based on the route, and must be unique. The name may also be set using a string key in the routes configuration array. If both are set the name assigned in the spec will be used. options (optional, array): any options to provide to the generated route. These might be default values or constraints, depending on the router implementation. Custom delegator factories As outlined in the introduction to this recipe, we can also create our own custom delegator factories in order to inject pipeline or routed middleware. Unlike the above solution, the solution we will outline here will exercise the Zend\\Expressive\\Application API in order to populate it. First, we'll create the class App\\Factory\\PipelineAndRoutesDelegator , with the following contents: <?php namespace App\\Factory; use App\\Handler; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\Handler\\NotFoundHandler; use Zend\\Expressive\\Helper\\ServerUrlMiddleware; use Zend\\Expressive\\Helper\\UrlHelperMiddleware; use Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware; use Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware; use Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware; use Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware; use Zend\\Expressive\\Router\\Middleware\\RouteMiddleware; use Zend\\Stratigility\\Middleware\\ErrorHandler; class PipelineAndRoutesDelegator { public function __invoke( ContainerInterface $container, string $serviceName, callable $callback ) : Application { /** @var $app Application */ $app = $callback(); // Setup pipeline: $app->pipe(ErrorHandler::class); $app->pipe(ServerUrlMiddleware::class); $app->pipe(RouteMiddleware::class); $app->pipe(ImplicitHeadMiddleware::class); $app->pipe(ImplicitOptionsMiddleware::class); $app->pipe(MethodNotAllowedMiddleware::class); $app->pipe(UrlHelperMiddleware::class); $app->pipe(DispatchMiddleware::class); $app->pipe(NotFoundHandler::class); // Setup routes: $app->get('/', Handler\\HomePageHandler::class, 'home'); $app->get('/api/ping', Handler\\PingHandler::class, 'api.ping'); return $app; } } Where to put the factory You will place the factory class in one of the following locations: src/App/Factory/PipelineAndRoutesDelegator.php if using the default, flat, application structure. src/App/src/Factory/PipelineAndRoutesDelegator.php if using the recommended, modular, application structure. Once you've created this, edit the class App\\ConfigProvider ; in it, we'll update the getDependencies() method to add the delegator factory: public function getDependencies() { return [ /* . . . */ 'delegators' => [ \\Zend\\Expressive\\Application::class => [ Factory\\PipelineAndRoutesDelegator::class, ], ], ]; } Where is the ConfigProvider class? The ConfigProvider class is in one of the following locations: src/App/ConfigProvider.php if using the default, flat, application structure. src/App/src/ConfigProvider.php using the recommended, modular, application structure. Why is an array assigned? As noted above in the description of delegator factories, since each delegator factory returns an instance, you can nest multiple delegator factories in order to shape initialization of a service. As such, they are assigned as an array to the service. If you're paying careful attention to this example, it essentially replaces both config/pipeline.php and config/routes.php ! If you were to update those files to remove the default pipeline and routes, you should find that reloading your application returns the exact same results! Caution: pipelines Using delegator factories is a nice way to keep your routing and pipeline configuration close to the modules in which they are defined. However, there is a caveat: you likely should not register pipeline middleware in a delegator factory other than within your root application module . The reason for this is simple: pipelines are linear, and specific to your application. If one module pipes in middleware, there's no guarantee it will be piped before or after your main pipeline, and no way to pipe the middleware at a position in the middle of the pipeline! As such: Use a config/pipeline.php file for your pipeline, OR Ensure you only define the pipeline in a single delegator factory on your Application instance. Caution: third-party, distributed modules If you are developing a module to distribute as a package via Composer , you should not autowire any delegator factories that inject pipeline middleware or routes in the Application . Why? As noted in the above section, pipelines should be created exactly once, at the application level. Registering pipeline middleware within a distributable package will very likely not have the intended consequences. If you ship with pipeline middleware, we suggest that you: Document the middleware, and where you anticipate it being used in the middleware pipeline. Document how to add the middleware service to dependency configuration, or provide the dependency configuration via your module's ConfigProvider . With regards to routes, there are other considerations: Routes defined by the package might conflict with the application, or with other packages used by the application. Routing definitions are typically highly specific to the router implementation in use. As an example, each of the currently supported router implementations has a different syntax for placeholders: /user/:id + \"constraints\" configuration to define constraints (zend-router) /user/{id} + \"tokens\" configuration to define constraints (Aura.Router) /user/{id:\\d+} (FastRoute) Your application may have specific routing considerations or design. You could, of course, detect what router is in use, and provide routing for each known, supported router implementation within your delegator factory. We even recommend doing exactly that. However, we note that such an approach does not solve the other two points above. However, we still recommend shipping a delegator factory that would register your routes, since routes are often a part of module design; just do not autowire that delegator factory. This way, end-users who can use the defaults do not need to cut-and-paste routing definitions from your documentation into their own applications; they will instead opt-in to your delegator factory by wiring it into their own configuration. Synopsis We recommend using delegator factories for the purpose of autowiring routes, and, with caveats, pipeline middleware: The pipeline should be created exactly once, so calls to pipe() should occur in exactly one delegator factory. Distributable packages should create a delegator factory for routes only , but should not register the delegator factory by default.","title":"Autowiring routes and pipeline middleware"},{"location":"v3/cookbook/autowiring-routes-and-pipelines/#how-can-i-autowire-routes-and-pipelines","text":"Sometimes you may find you'd like to keep route definitions close to the handlers and middleware they will invoke. This is particularly important if you want to re-use a module or library in another project. In this recipe, we'll demonstrate two mechanisms for doing so. One is a built-in delegator factory , and the other is a custom delegator factory.","title":"How can I autowire routes and pipelines?"},{"location":"v3/cookbook/autowiring-routes-and-pipelines/#applicationconfiginjectiondelegator","text":"Expressive ships with the class Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator , which can be used as a delegator factory for the Zend\\Expressive\\Application class in order to automate piping of pipeline middleware and routing to request handlers and middleware. The delegator factory looks for configuration that looks like the following: return [ 'middleware_pipeline' => [ [ // required: 'middleware' => 'Middleware service or pipeline', // optional: 'path' => '/path/to/match', // for path-segregated middleware 'priority' => 1, // integer; to ensure specific order ] ], 'routes' => [ [ 'path' => '/path/to/match', 'middleware' => 'Middleware service or pipeline', 'allowed_methods' => ['GET', 'POST', 'PATCH'], 'name' => 'route.name', 'options' => [ 'stuff' => 'to', 'pass' => 'to', 'the' => 'underlying router', ], ], 'another.route.name' => [ 'path' => '/another/path/to/match', 'middleware' => 'Middleware service or pipeline', 'allowed_methods' => ['GET', 'POST'], 'options' => [ 'more' => 'router', 'options' => 'here', ], ], ], ]; This configuration may be placed at the application level, in a file under config/autoload/ , or within a module's ConfigProvider class. For details on what values are accepted, see below. In order to enable the delegator factory, you will need to define the following service configuration somewhere, either at the application level in a config/autoload/ file, or within a module-specific ConfigProvider class: return [ 'dependencies' => [ 'delegators' => [ \\Zend\\Expressive\\Application::class => [ \\Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator::class, ], ], ], ];","title":"ApplicationConfigInjectionDelegator"},{"location":"v3/cookbook/autowiring-routes-and-pipelines/#custom-delegator-factories","text":"As outlined in the introduction to this recipe, we can also create our own custom delegator factories in order to inject pipeline or routed middleware. Unlike the above solution, the solution we will outline here will exercise the Zend\\Expressive\\Application API in order to populate it. First, we'll create the class App\\Factory\\PipelineAndRoutesDelegator , with the following contents: <?php namespace App\\Factory; use App\\Handler; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\Handler\\NotFoundHandler; use Zend\\Expressive\\Helper\\ServerUrlMiddleware; use Zend\\Expressive\\Helper\\UrlHelperMiddleware; use Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware; use Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware; use Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware; use Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware; use Zend\\Expressive\\Router\\Middleware\\RouteMiddleware; use Zend\\Stratigility\\Middleware\\ErrorHandler; class PipelineAndRoutesDelegator { public function __invoke( ContainerInterface $container, string $serviceName, callable $callback ) : Application { /** @var $app Application */ $app = $callback(); // Setup pipeline: $app->pipe(ErrorHandler::class); $app->pipe(ServerUrlMiddleware::class); $app->pipe(RouteMiddleware::class); $app->pipe(ImplicitHeadMiddleware::class); $app->pipe(ImplicitOptionsMiddleware::class); $app->pipe(MethodNotAllowedMiddleware::class); $app->pipe(UrlHelperMiddleware::class); $app->pipe(DispatchMiddleware::class); $app->pipe(NotFoundHandler::class); // Setup routes: $app->get('/', Handler\\HomePageHandler::class, 'home'); $app->get('/api/ping', Handler\\PingHandler::class, 'api.ping'); return $app; } }","title":"Custom delegator factories"},{"location":"v3/cookbook/autowiring-routes-and-pipelines/#caution-pipelines","text":"Using delegator factories is a nice way to keep your routing and pipeline configuration close to the modules in which they are defined. However, there is a caveat: you likely should not register pipeline middleware in a delegator factory other than within your root application module . The reason for this is simple: pipelines are linear, and specific to your application. If one module pipes in middleware, there's no guarantee it will be piped before or after your main pipeline, and no way to pipe the middleware at a position in the middle of the pipeline! As such: Use a config/pipeline.php file for your pipeline, OR Ensure you only define the pipeline in a single delegator factory on your Application instance.","title":"Caution: pipelines"},{"location":"v3/cookbook/autowiring-routes-and-pipelines/#caution-third-party-distributed-modules","text":"If you are developing a module to distribute as a package via Composer , you should not autowire any delegator factories that inject pipeline middleware or routes in the Application . Why? As noted in the above section, pipelines should be created exactly once, at the application level. Registering pipeline middleware within a distributable package will very likely not have the intended consequences. If you ship with pipeline middleware, we suggest that you: Document the middleware, and where you anticipate it being used in the middleware pipeline. Document how to add the middleware service to dependency configuration, or provide the dependency configuration via your module's ConfigProvider . With regards to routes, there are other considerations: Routes defined by the package might conflict with the application, or with other packages used by the application. Routing definitions are typically highly specific to the router implementation in use. As an example, each of the currently supported router implementations has a different syntax for placeholders: /user/:id + \"constraints\" configuration to define constraints (zend-router) /user/{id} + \"tokens\" configuration to define constraints (Aura.Router) /user/{id:\\d+} (FastRoute) Your application may have specific routing considerations or design. You could, of course, detect what router is in use, and provide routing for each known, supported router implementation within your delegator factory. We even recommend doing exactly that. However, we note that such an approach does not solve the other two points above. However, we still recommend shipping a delegator factory that would register your routes, since routes are often a part of module design; just do not autowire that delegator factory. This way, end-users who can use the defaults do not need to cut-and-paste routing definitions from your documentation into their own applications; they will instead opt-in to your delegator factory by wiring it into their own configuration.","title":"Caution: third-party, distributed modules"},{"location":"v3/cookbook/autowiring-routes-and-pipelines/#synopsis","text":"We recommend using delegator factories for the purpose of autowiring routes, and, with caveats, pipeline middleware: The pipeline should be created exactly once, so calls to pipe() should occur in exactly one delegator factory. Distributable packages should create a delegator factory for routes only , but should not register the delegator factory by default.","title":"Synopsis"},{"location":"v3/cookbook/common-prefix-for-routes/","text":"How can I prepend a common path to all my routes? You may have multiple middleware in your project, each providing their own functionality: $app->pipe(UserMiddleware::class); $app->pipe(ProjectMiddleware::class); Let's assume the above represents an API. As your application progresses, you may have a mixture of different content, and now want to have the above segregated under the path /api . To accomplish it, we will pipe an array of middleware under a path , /api . When we pipe an array of middleware, internally, Zend\\Expressive\\Application creates a new Zend\\Stratigility\\MiddlewarePipe instance, and pipes each middleware item to it. When we specify a path, the middleware is decorated with a Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator . This middleware will compare the request path against the path with which it was created; if they match, it passes processing on to its middleware. The following example assumes you are using the structure of config/pipeline.php as shipped with the skeleton application. use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\MiddlewareFactory; /** * Setup middleware pipeline: */ return function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void { // . . . $app->pipe('/api', [ UserMiddleware::class, ProjectMiddleware::class, ]); // . . . } Alternately, you can perform the path decoration manually: use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\MiddlewareFactory; use function Zend\\Stratigility\\path; /** * Setup middleware pipeline: */ return function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void { // . . . $app->pipe(path('/api', $factory->pipeline( UserMiddleware::class, ProjectMiddleware::class ))); // . . . } (Calling $factory->pipeline() is necessary here to ensure that we create the MiddlewarePipe instance, and so that each item in the specified pipeline will be decorated as Zend\\Expressive\\Middleware\\LazyLoadingMiddleware .)","title":"Prepending a common path to all routes"},{"location":"v3/cookbook/common-prefix-for-routes/#how-can-i-prepend-a-common-path-to-all-my-routes","text":"You may have multiple middleware in your project, each providing their own functionality: $app->pipe(UserMiddleware::class); $app->pipe(ProjectMiddleware::class); Let's assume the above represents an API. As your application progresses, you may have a mixture of different content, and now want to have the above segregated under the path /api . To accomplish it, we will pipe an array of middleware under a path , /api . When we pipe an array of middleware, internally, Zend\\Expressive\\Application creates a new Zend\\Stratigility\\MiddlewarePipe instance, and pipes each middleware item to it. When we specify a path, the middleware is decorated with a Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator . This middleware will compare the request path against the path with which it was created; if they match, it passes processing on to its middleware. The following example assumes you are using the structure of config/pipeline.php as shipped with the skeleton application. use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\MiddlewareFactory; /** * Setup middleware pipeline: */ return function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void { // . . . $app->pipe('/api', [ UserMiddleware::class, ProjectMiddleware::class, ]); // . . . } Alternately, you can perform the path decoration manually: use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\MiddlewareFactory; use function Zend\\Stratigility\\path; /** * Setup middleware pipeline: */ return function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void { // . . . $app->pipe(path('/api', $factory->pipeline( UserMiddleware::class, ProjectMiddleware::class ))); // . . . } (Calling $factory->pipeline() is necessary here to ensure that we create the MiddlewarePipe instance, and so that each item in the specified pipeline will be decorated as Zend\\Expressive\\Middleware\\LazyLoadingMiddleware .)","title":"How can I prepend a common path to all my routes?"},{"location":"v3/cookbook/debug-toolbars/","text":"How can I get a debug toolbar for my Expressive application? Many modern frameworks and applications provide debug toolbars: in-browser toolbars to provide profiling information of the request executed. These can provide invaluable details into application objects, database queries, and more. As an Expressive user, how can you get similar functionality? Zend Server Z-Ray Zend Server ships with a tool called Z-Ray , which provides both a debug toolbar and debug console (for API debugging). Z-Ray is also currently available as a standalone technology preview , and can be added as an extension to an existing PHP installation. When using Zend Server or the standalone Z-Ray, you do not need to make any changes to your application whatsoever to benefit from it; you simply need to make sure Z-Ray is enabled and/or that you've setup a security token to selectively enable it on-demand. See the Z-Ray documentation for full usage details. php-middleware/php-debug-bar php-middleware/php-debug-bar provides a PSR-15 middleware wrapper around maximebf/php-debugbar , a popular framework-agnostic debug bar for PHP projects. First, install the middleware in your application: $ composer require php-middleware/php-debug-bar This package supplies a config provider, which could be added to your config/config.php when using zend-config-aggregator or expressive-config-manager. However, because it should only be enabled in development, we recommend creating a \"local\" configuration file (e.g., config/autoload/php-debugbar.local.php ) when you need to enable it, with the following contents: <?php use PhpMiddleware\\PhpDebugBar\\ConfigProvider; $provider = new ConfigProvider(); return $provider(); Use locally! Remember to enable PhpMiddleware\\PhpDebugBar\\ConfigProvider only in your development environments!","title":"Enabling debug toolbars"},{"location":"v3/cookbook/debug-toolbars/#how-can-i-get-a-debug-toolbar-for-my-expressive-application","text":"Many modern frameworks and applications provide debug toolbars: in-browser toolbars to provide profiling information of the request executed. These can provide invaluable details into application objects, database queries, and more. As an Expressive user, how can you get similar functionality?","title":"How can I get a debug toolbar for my Expressive application?"},{"location":"v3/cookbook/debug-toolbars/#zend-server-z-ray","text":"Zend Server ships with a tool called Z-Ray , which provides both a debug toolbar and debug console (for API debugging). Z-Ray is also currently available as a standalone technology preview , and can be added as an extension to an existing PHP installation. When using Zend Server or the standalone Z-Ray, you do not need to make any changes to your application whatsoever to benefit from it; you simply need to make sure Z-Ray is enabled and/or that you've setup a security token to selectively enable it on-demand. See the Z-Ray documentation for full usage details.","title":"Zend Server Z-Ray"},{"location":"v3/cookbook/debug-toolbars/#php-middlewarephp-debug-bar","text":"php-middleware/php-debug-bar provides a PSR-15 middleware wrapper around maximebf/php-debugbar , a popular framework-agnostic debug bar for PHP projects. First, install the middleware in your application: $ composer require php-middleware/php-debug-bar This package supplies a config provider, which could be added to your config/config.php when using zend-config-aggregator or expressive-config-manager. However, because it should only be enabled in development, we recommend creating a \"local\" configuration file (e.g., config/autoload/php-debugbar.local.php ) when you need to enable it, with the following contents: <?php use PhpMiddleware\\PhpDebugBar\\ConfigProvider; $provider = new ConfigProvider(); return $provider();","title":"php-middleware/php-debug-bar"},{"location":"v3/cookbook/double-pass-middleware/","text":"Using Double-Pass Middleware Expressive uses PSR-15 middleware and request handlers exclusively as of version 3. In previous releases, however, we supported \"double-pass\" middleware, and a number of third-party packages provided double-pass middleware. How can you use this middleware with Expressive 3? What is Double-Pass Middleware? Double pass middleware receives both the request and a response in addition to the handler, and passes both the request and response to the handler when invoking it: $$$$FENCED_CODE_BLOCK_5e03bde9ec40e4.65712362 It is termed \"double pass\" because you pass both the request and response when delegating to the next layer. doublePassMiddleware function zend-stratigility v2.2 and v3.0 ship a utility function, Zend\\Stratigility\\doublePassMiddleware() , that will decorate a callable double-pass middleware using a Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator instance; this latter is a PSR-15 impelementation, and can thus be used in your middleware pipelines. The function (and class) also expects a PSR-7 ResponseInterface instance as a second argument; this is then passed as the $response argument to the double-pass middleware. The following examples demostrate both piping and routing to double pass middleware using this technique, and using zend-diactoros to provide the response instance. use Zend\\Diactoros\\Response; use function Zend\\Stratigility\\doublePassMiddleware; $app->pipe(doublePassMiddleware(function ($request, $response, $next) { $response = $next($request, $response); return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett'); }, new Response())); // <-- note the response $app->get('/api/ping', doublePassMiddleware(function ($request, $response, $next) { return new Response\\JsonResponse([ 'ack' => time(), ]); }, new Response())); // <-- note the response Double-Pass Middleware Services What if you're piping or routing to a service \u2014 for instance, a class provided by a third-party implementation? In this case, you have one of two options: Decorate the middleware before returning it from the factory that creates it. Use a delegator factory to decorate the middleware. Decorating via factory If you have control of the factory that creates the double-pass middleware you will be using in your application, you can use the strategy outlined above to decorate your middleware before returning it, with one minor change: you can pull a response factory from the container as well. To demonstrate: use Psr\\Container\\ContainerInterface; use Psr\\Http\\Message\\ResponseInterface; use function Zend\\Stratigility\\doublePassMiddleware; class SomeDoublePassMiddlewareFactory { public function __invoke(ContainerInterface $container) { // Create the middleware instance somehow. This example // assumes it is in `$middleware` when done. return doublePassMiddleware( $middleware, ($container->get(ResponseInterface::class))() ); } } That last line may look a little strange. The Psr\\Http\\Response\\ResponseInterface service returns a callable factory for producing response instances, and not a response instance itself. As such, we pull it, and then invoke it to produce the response instance for our double-pass middleware. This approach will work, but it means code duplication everywhere you have double-pass middleware. Let's look at the delegator factory solution. Decorating via delegator factory Delegator factories can be re-used for multiple services. In our case, we'll re-use it to decorate double-pass middleware. The delegator factory would look like this: use Psr\\Container\\ContainerInterface; use Psr\\Http\\Message\\ResponseInterface; use function Zend\\Stratigility\\doublePassMiddleware; class DoublePassMiddlewareDelegator { public function __invoke(Container $container, string $serviceName, callable $callback) { return doublePassMiddleware( $callback(), ($container->get(ResponseInterface::class))() ); } } This looks similar to our previous solution, but is self-contained; we rely on the $callback argument to produce the middleware we want to decorate. Then, for each service we have that represents double-pass middleware, we can provide configuration like the following: return [ 'dependencies' => [ 'delegators' => [ SomeDoublePassMiddleware::class => [ DoublePassMiddlewareDelegator::class, ], ], ], ]; This approach has a couple of benefits: We do not need to change existing factories. We do not need to extend factories from third-party services. We can see explicitly in our configuration all services we consume that are double-pass middleware. This will help us identify projects we want to contribute PSR-15 patches to, or potentially migrate away from, or middleware of our own we need to refactor. Extending the MiddlewareContainer Another possibility is to extend Zend\\Expressive\\MiddlewareContainer to add awareness of double-pass middleware, and have it auto-decorate them for you. A contributor has created such a library: https://github.com/Moln/expressive-callable-middleware-compat You can install it using composer require moln/expressive-callable-middleware-compat . Once installed, add its Moln\\ExpressiveCallableCompat\\ConfigProvider as an entry in your config/config.php after the Zend\\Expressive\\ConfigProvider entry. This last point is particularly important: providers are merged in the order presented, with later entries having precedence; you need to ensure the new package overrides the MiddlewareContainer service provided by zend-expressive! When you use this approach, it will automatically detect double-pass middleware and decorate it for you. The main drawback with such an approach is that it will not help you identify double-pass middleware in your system.","title":"Using double-pass middleware"},{"location":"v3/cookbook/double-pass-middleware/#using-double-pass-middleware","text":"Expressive uses PSR-15 middleware and request handlers exclusively as of version 3. In previous releases, however, we supported \"double-pass\" middleware, and a number of third-party packages provided double-pass middleware. How can you use this middleware with Expressive 3?","title":"Using Double-Pass Middleware"},{"location":"v3/cookbook/double-pass-middleware/#doublepassmiddleware-function","text":"zend-stratigility v2.2 and v3.0 ship a utility function, Zend\\Stratigility\\doublePassMiddleware() , that will decorate a callable double-pass middleware using a Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator instance; this latter is a PSR-15 impelementation, and can thus be used in your middleware pipelines. The function (and class) also expects a PSR-7 ResponseInterface instance as a second argument; this is then passed as the $response argument to the double-pass middleware. The following examples demostrate both piping and routing to double pass middleware using this technique, and using zend-diactoros to provide the response instance. use Zend\\Diactoros\\Response; use function Zend\\Stratigility\\doublePassMiddleware; $app->pipe(doublePassMiddleware(function ($request, $response, $next) { $response = $next($request, $response); return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett'); }, new Response())); // <-- note the response $app->get('/api/ping', doublePassMiddleware(function ($request, $response, $next) { return new Response\\JsonResponse([ 'ack' => time(), ]); }, new Response())); // <-- note the response","title":"doublePassMiddleware function"},{"location":"v3/cookbook/double-pass-middleware/#double-pass-middleware-services","text":"What if you're piping or routing to a service \u2014 for instance, a class provided by a third-party implementation? In this case, you have one of two options: Decorate the middleware before returning it from the factory that creates it. Use a delegator factory to decorate the middleware.","title":"Double-Pass Middleware Services"},{"location":"v3/cookbook/flash-messengers/","text":"How Can I Implement Flash Messages? Flash messages are used to display one-time messages to a user. A typical use case is for setting and later displaying a successful submission via a Post/Redirect/Get (PRG) workflow, where the flash message would be set during the POST request, but displayed during the GET request. (PRG is used to prevent double-submission of forms.) As such, flash messages usually are session-based; the message is set in one request, and accessed and cleared in another. Expressive does not provide native session facilities out-of-the-box, which means you will need: Session functionality. Flash message functionality, for handling message expiry from the session after first access. A number of flash message libraries already exist that can be integrated via middleware, and these typically either use PHP's ext/session functionality or have a dependency on a session library. Two such libraries are: zendframework/zend-expressive-flash slim/flash zendframework/zend-expressive-flash zend-expressive-flash is a new offering from Zend Framework. Using it requires a session persistence engine as well, and Zend Framework provides that as well. Install the component using the following: $ composer require zendframework/zend-expressive-flash zendframework/zend-expressive-session-ext Once installed, you will need to pipe the middleware, along with the zend-expressive-session middleware, in your pipeline. This can be done at the application level: $app->pipe(\\Zend\\Expressive\\Session\\SessionMiddleware::class); $app->pipe(\\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class); or within a routed middleware pipeline: $app->post('/user/login', [ \\Zend\\Expressive\\Session\\SessionMiddleware::class, \\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class, LoginHandler::class, ]); Once this is in place, the flash message container will be registered as a request attribute, which you can then pull and manipulate: $flashMessages = $request->getAttribute(FlashMessageMiddleware::FLASH_ATTRIBUTE); // or $flashMessages = $request->getAttribute('flash'); // Create a flash message for the next request: $flashMessages->flash($messageName, $messageValue); // Or retrieve them: $message = $flashMessages->getFlash($messageName); The component has functionality for specifying the number of hops the message will be valid for, as well as accessing messages created in the current request; read more in the documentation . slim/flash Slim's Flash messages service provider can be used in Expressive. It uses PHP's native session support. First, you'll need to add it to your application: $ composer require slim/flash Second, create middleware that will add the flash message provider to the request: <?php namespace App; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Slim\\Flash\\Messages; class SlimFlashMiddleware implements MiddlewareInterface { public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // Start the session whenever we use this! session_start(); return $handler->handle( $request->withAttribute('flash', new Messages()) ); } } Third, we will register the new middleware with our container as an invokable. Edit either the file config/autoload/dependencies.global.php or config/autoload/middleware-pipeline.global.php to add the following: return [ 'dependencies' => [ 'invokables' => [ App\\SlimFlashMiddleware::class => App\\SlimFlashMiddleware::class, /* ... */ ], /* ... */ ], ]; Finally, let's register it with our middleware pipeline. For programmatic pipelines, pipe the middleware somewhere, generally before the routing middleware: $app->pipe(App\\SlimFlashMiddleware::class); Or as part of a routed middleware pipeline: $app->post('/form/handler', [ App\\SlimFlashMiddleware::class, FormHandlerMiddleware::class, ]); If using configuration-driven pipelines, edit config/autoload/middleware-pipeline.global.php to make the following additions: return [ 'middleware_pipeline' => [ 'always' => [ 'middleware' => [ 'App\\SlimFlashMiddleware', /* ... */ ], 'priority' => 10000, ], /* ... */ ], ]; Where to register the flash middleware Sessions can sometimes be expensive. As such, you may not want the flash middleware enabled for every request. If this is the case, add the flash middleware as part of a route-specific pipeline instead, as demonstrated in the programmatic pipelines above. From here, you can add and read messages by accessing the request's flash attribute. As an example, middleware generating messages might read as follows: use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\RedirectResponse; function($request, RequestHandlerInterface $handler) { $flash = $request->getAttribute('flash'); $flash->addMessage('message', 'Hello World!'); return new RedirectResponse('/other-middleware'); } And middleware consuming the message might read: use Psr\\Http\\Server\\RequestHandlerInterface; function($request, RequestHandlerInterface $handler) { $flash = $request->getAttribute('flash'); $messages = $flash->getMessages(); // ... } From there, it's a matter of providing the flash messages to your template.","title":"Flash Messengers"},{"location":"v3/cookbook/flash-messengers/#how-can-i-implement-flash-messages","text":"Flash messages are used to display one-time messages to a user. A typical use case is for setting and later displaying a successful submission via a Post/Redirect/Get (PRG) workflow, where the flash message would be set during the POST request, but displayed during the GET request. (PRG is used to prevent double-submission of forms.) As such, flash messages usually are session-based; the message is set in one request, and accessed and cleared in another. Expressive does not provide native session facilities out-of-the-box, which means you will need: Session functionality. Flash message functionality, for handling message expiry from the session after first access. A number of flash message libraries already exist that can be integrated via middleware, and these typically either use PHP's ext/session functionality or have a dependency on a session library. Two such libraries are: zendframework/zend-expressive-flash slim/flash","title":"How Can I Implement Flash Messages?"},{"location":"v3/cookbook/flash-messengers/#zendframeworkzend-expressive-flash","text":"zend-expressive-flash is a new offering from Zend Framework. Using it requires a session persistence engine as well, and Zend Framework provides that as well. Install the component using the following: $ composer require zendframework/zend-expressive-flash zendframework/zend-expressive-session-ext Once installed, you will need to pipe the middleware, along with the zend-expressive-session middleware, in your pipeline. This can be done at the application level: $app->pipe(\\Zend\\Expressive\\Session\\SessionMiddleware::class); $app->pipe(\\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class); or within a routed middleware pipeline: $app->post('/user/login', [ \\Zend\\Expressive\\Session\\SessionMiddleware::class, \\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class, LoginHandler::class, ]); Once this is in place, the flash message container will be registered as a request attribute, which you can then pull and manipulate: $flashMessages = $request->getAttribute(FlashMessageMiddleware::FLASH_ATTRIBUTE); // or $flashMessages = $request->getAttribute('flash'); // Create a flash message for the next request: $flashMessages->flash($messageName, $messageValue); // Or retrieve them: $message = $flashMessages->getFlash($messageName); The component has functionality for specifying the number of hops the message will be valid for, as well as accessing messages created in the current request; read more in the documentation .","title":"zendframework/zend-expressive-flash"},{"location":"v3/cookbook/flash-messengers/#slimflash","text":"Slim's Flash messages service provider can be used in Expressive. It uses PHP's native session support. First, you'll need to add it to your application: $ composer require slim/flash Second, create middleware that will add the flash message provider to the request: <?php namespace App; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Slim\\Flash\\Messages; class SlimFlashMiddleware implements MiddlewareInterface { public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // Start the session whenever we use this! session_start(); return $handler->handle( $request->withAttribute('flash', new Messages()) ); } } Third, we will register the new middleware with our container as an invokable. Edit either the file config/autoload/dependencies.global.php or config/autoload/middleware-pipeline.global.php to add the following: return [ 'dependencies' => [ 'invokables' => [ App\\SlimFlashMiddleware::class => App\\SlimFlashMiddleware::class, /* ... */ ], /* ... */ ], ]; Finally, let's register it with our middleware pipeline. For programmatic pipelines, pipe the middleware somewhere, generally before the routing middleware: $app->pipe(App\\SlimFlashMiddleware::class); Or as part of a routed middleware pipeline: $app->post('/form/handler', [ App\\SlimFlashMiddleware::class, FormHandlerMiddleware::class, ]); If using configuration-driven pipelines, edit config/autoload/middleware-pipeline.global.php to make the following additions: return [ 'middleware_pipeline' => [ 'always' => [ 'middleware' => [ 'App\\SlimFlashMiddleware', /* ... */ ], 'priority' => 10000, ], /* ... */ ], ];","title":"slim/flash"},{"location":"v3/cookbook/host-segregated-middleware/","text":"How does one segregate middleware by host? If your application is being re-used to respond to multiple host domains, how can you segregate middleware to work only in reponse to a specific host request? As an example, perhaps you have an \"admin\" area of your application you only want to expose via the host name \"admin.example.org\"; how can you do this? The host function Stratigility provides a function, Zend\\Stratigility\\host() that can be used to decorate middleware in a Zend\\Stratigility\\Middleware\\HostMiddlewareDecorator instance. These expect the string name of a host, and the middleware that should only trigger when that host is matched in the request. As a simple example: // in config/pipeline.php: use function Zend\\Stratigility\\host; $app->pipe(host('admin.example.org', $adminMiddleware)); However, you'll note that the above uses an already instantiated middleware instance; how can you lazy-load a named service instead? Lazy-loading host-segregated middleware The config/pipeline.php file defines and returns a callable that accepts three arguments: a Zend\\Expressive\\Application $app instance a Zend\\Expressive\\MiddlewareFactory $factory instance a Psr\\Container\\ContainerInterface $container instance We can use the second of these to help us. We will use the lazy() method to specify a middleware service name to lazy-load: $app->pipe(host('admin.example.org', $factory->lazy(AdminMiddleware::class))); What about specifying a pipeline of middleware? For that, we can use the pipeline() method of the factory: $app->pipe(host('admin.example.org', $factory->pipeline( SessionMiddleware::class, AuthenticationMiddleware::class, AuthorizationMiddleware::class, AdminHandler::class ))); Alternately, either of the above examples could use the prepare() method: // lazy example: $app->pipe(host('admin.example.org', $factory->prepare(AdminMiddleware::class))); // pipeline example: $app->pipe(host('admin.example.org', $factory->prepare([ SessionMiddleware::class, AuthenticationMiddleware::class, AuthorizationMiddleware::class, AdminHandler::class, ]))); For more information on the MiddlewareFactory , read its documentation .","title":"Segregating middleware by host"},{"location":"v3/cookbook/host-segregated-middleware/#how-does-one-segregate-middleware-by-host","text":"If your application is being re-used to respond to multiple host domains, how can you segregate middleware to work only in reponse to a specific host request? As an example, perhaps you have an \"admin\" area of your application you only want to expose via the host name \"admin.example.org\"; how can you do this?","title":"How does one segregate middleware by host?"},{"location":"v3/cookbook/host-segregated-middleware/#the-host-function","text":"Stratigility provides a function, Zend\\Stratigility\\host() that can be used to decorate middleware in a Zend\\Stratigility\\Middleware\\HostMiddlewareDecorator instance. These expect the string name of a host, and the middleware that should only trigger when that host is matched in the request. As a simple example: // in config/pipeline.php: use function Zend\\Stratigility\\host; $app->pipe(host('admin.example.org', $adminMiddleware)); However, you'll note that the above uses an already instantiated middleware instance; how can you lazy-load a named service instead?","title":"The host function"},{"location":"v3/cookbook/host-segregated-middleware/#lazy-loading-host-segregated-middleware","text":"The config/pipeline.php file defines and returns a callable that accepts three arguments: a Zend\\Expressive\\Application $app instance a Zend\\Expressive\\MiddlewareFactory $factory instance a Psr\\Container\\ContainerInterface $container instance We can use the second of these to help us. We will use the lazy() method to specify a middleware service name to lazy-load: $app->pipe(host('admin.example.org', $factory->lazy(AdminMiddleware::class))); What about specifying a pipeline of middleware? For that, we can use the pipeline() method of the factory: $app->pipe(host('admin.example.org', $factory->pipeline( SessionMiddleware::class, AuthenticationMiddleware::class, AuthorizationMiddleware::class, AdminHandler::class ))); Alternately, either of the above examples could use the prepare() method: // lazy example: $app->pipe(host('admin.example.org', $factory->prepare(AdminMiddleware::class))); // pipeline example: $app->pipe(host('admin.example.org', $factory->prepare([ SessionMiddleware::class, AuthenticationMiddleware::class, AuthorizationMiddleware::class, AdminHandler::class, ]))); For more information on the MiddlewareFactory , read its documentation .","title":"Lazy-loading host-segregated middleware"},{"location":"v3/cookbook/passing-data-between-middleware/","text":"Passing Data Between Middleware A frequently asked question is how to pass data between middleware. The answer is present in every middleware: via request object attributes. Middleware is always executed in the order in which it is piped to the application. This way you can ensure the request object in middleware receiving data contains an attribute containing data passed by outer middleware. In the following example, PassingDataMiddleware prepares data to pass as a request attribute to nested middleware. We use the fully qualified class name for the attribute name to ensure uniqueness, but you can name it anything you want. namespace App\\Middleware; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class PassingDataMiddleware implements MiddlewareInterface { // ... public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // Step 1: Do something first $data = [ 'foo' => 'bar', ]; // Step 2: Inject data into the request, call the next middleware and wait for the response $response = $handler->handle($request->withAttribute(self::class, $data)); // Step 3: Optionally, do something (with the response) before returning the response // Step 4: Return the response return $response; } } Later, ReceivingDataMiddleware grabs the data and processes it: namespace App\\Middleware; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class ReceivingDataMiddleware implements MiddlewareInterface { // ... public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // Step 1: Grab the data from the request and use it $data = $request->getAttribute(PassingDataMiddleware::class); // Step 2: Call the next middleware and wait for the response $response = $handler->handle($request); // Step 3: Optionally, do something (with the response) before returning the response // Step 4: Return the response return $response; } } Of course, you could also use the data in routed middleware, which is usually at the innermost layer of your application. The ExampleHandler below takes that information and passes it to the template renderer to create an HtmlResponse : namespace App\\Handler; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\HtmlResponse; class ExampleHandler implements RequestHandlerInterface { // ... public function handle(ServerRequestInterface $request) : ResponseInterface { // Step 1: Grab the data from the request $data = $request->getAttribute(PassingDataMiddleware::class); $id = $request->getAttribute('id'); // Step 2: Do some more stuff // Step 3: Return a Response return new HtmlResponse( $this->templateRenderer->render('blog::entry', [ 'data' => $data, 'id' => $id, ]) ); } }","title":"Passing data between middleware"},{"location":"v3/cookbook/passing-data-between-middleware/#passing-data-between-middleware","text":"A frequently asked question is how to pass data between middleware. The answer is present in every middleware: via request object attributes. Middleware is always executed in the order in which it is piped to the application. This way you can ensure the request object in middleware receiving data contains an attribute containing data passed by outer middleware. In the following example, PassingDataMiddleware prepares data to pass as a request attribute to nested middleware. We use the fully qualified class name for the attribute name to ensure uniqueness, but you can name it anything you want. namespace App\\Middleware; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class PassingDataMiddleware implements MiddlewareInterface { // ... public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // Step 1: Do something first $data = [ 'foo' => 'bar', ]; // Step 2: Inject data into the request, call the next middleware and wait for the response $response = $handler->handle($request->withAttribute(self::class, $data)); // Step 3: Optionally, do something (with the response) before returning the response // Step 4: Return the response return $response; } } Later, ReceivingDataMiddleware grabs the data and processes it: namespace App\\Middleware; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class ReceivingDataMiddleware implements MiddlewareInterface { // ... public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // Step 1: Grab the data from the request and use it $data = $request->getAttribute(PassingDataMiddleware::class); // Step 2: Call the next middleware and wait for the response $response = $handler->handle($request); // Step 3: Optionally, do something (with the response) before returning the response // Step 4: Return the response return $response; } } Of course, you could also use the data in routed middleware, which is usually at the innermost layer of your application. The ExampleHandler below takes that information and passes it to the template renderer to create an HtmlResponse : namespace App\\Handler; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\HtmlResponse; class ExampleHandler implements RequestHandlerInterface { // ... public function handle(ServerRequestInterface $request) : ResponseInterface { // Step 1: Grab the data from the request $data = $request->getAttribute(PassingDataMiddleware::class); $id = $request->getAttribute('id'); // Step 2: Do some more stuff // Step 3: Return a Response return new HtmlResponse( $this->templateRenderer->render('blog::entry', [ 'data' => $data, 'id' => $id, ]) ); } }","title":"Passing Data Between Middleware"},{"location":"v3/cookbook/path-segregated-routing/","text":"Path-segregated routing Since zend-expressive-router 3.1.0, zend-expressive-helpers 5.1.0, and zend-expressive-hal 1.1.0. You may want to develop a self-contained module that you can then drop in to an existing application; you may even want to path-segregate it. In such cases, you will want to use a different router instance, which has a huge number of ramifications: You'll need separate routing middleware. You'll need a separate UrlHelper instance, as well as its related middleware, if you are generating URIs. If you are generating HAL , you'll need: a separate URL generator for HAL that consumes the separate UrlHelper instance. a separate LinkGenerator for HAL that consumes the separate URL generator. a separate ResourceGenerator for HAL that consumes the separate LinkGenerator . These tasks can be accomplished by writing your own factories, but that means a lot of extra code, and the potential for the factories to go out-of-sync with the official factories for these services. What should you do? We provide details on how to accomplish these scenarios elsewhere: For modules not using HAL For modules using HAL","title":"Path-segregated routing"},{"location":"v3/cookbook/path-segregated-routing/#path-segregated-routing","text":"Since zend-expressive-router 3.1.0, zend-expressive-helpers 5.1.0, and zend-expressive-hal 1.1.0. You may want to develop a self-contained module that you can then drop in to an existing application; you may even want to path-segregate it. In such cases, you will want to use a different router instance, which has a huge number of ramifications: You'll need separate routing middleware. You'll need a separate UrlHelper instance, as well as its related middleware, if you are generating URIs. If you are generating HAL , you'll need: a separate URL generator for HAL that consumes the separate UrlHelper instance. a separate LinkGenerator for HAL that consumes the separate URL generator. a separate ResourceGenerator for HAL that consumes the separate LinkGenerator . These tasks can be accomplished by writing your own factories, but that means a lot of extra code, and the potential for the factories to go out-of-sync with the official factories for these services. What should you do? We provide details on how to accomplish these scenarios elsewhere: For modules not using HAL For modules using HAL","title":"Path-segregated routing"},{"location":"v3/cookbook/route-specific-pipeline/","text":"How can I specify a route-specific middleware pipeline? Sometimes you may want to use a middleware pipeline only if a particular route is matched. As an example, for an API resource, you might want to: check for authentication credentials check for authorization for the selected action parse the incoming body validate the parsed body parameters before you actually execute the selected middleware. The above might each be encapsulated as discrete middleware, but should be executed within the routed middleware's context. You can accomplish this in one of two ways: Have your middleware service resolve to a MiddlewarePipe instance that composes the various middlewares. Specify an array of middlewares (either as actual instances, or as container service names); this effectively creates and returns a MiddlewarePipe . Resolving to a MiddlewarePipe You can do this programmatically within a container factory, assuming you are using a container that supports factories. use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\MiddlewareFactory; use Zend\\Stratigility\\MiddlewarePipe; class ApiResourcePipelineFactory { public function __invoke(ContainerInterface $container) { $factory = $container->get(MiddlewareFactory::class); $pipeline = new MiddlewarePipe(); // These correspond to the bullet points above $pipeline->pipe($factory->prepare(AuthenticationMiddleware::class)); $pipeline->pipe($factory->prepare(AuthorizationMiddleware::class)); $pipeline->pipe($factory->prepare(BodyParsingMiddleware::class)); $pipeline->pipe($factory->prepare(ValidationMiddleware::class)); // This is the actual handler you're routing to: $pipeline->pipe($factory->prepare(ApiResource::class)); return $pipeline; } } $factory->prepare() is used here to allow lazy-loading each middleware and handler. If we instead pulled each class from the container directly, each would be created, even if it was not ultimately executed. This gives you full control over the creation of the pipeline. You would, however, need to ensure that you map the middleware to the pipeline factory when setting up your container configuration. One alternative when using zend-servicemanager is to use a delegator factory . Delegator factories allow you to decorate the primary factory used to create the middleware in order to change the instance or return an alternate instance. In this case, we'd do the latter. The following is an example: use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\MiddlewareFactory; use Zend\\ServiceManager\\DelegatorFactoryInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; use Zend\\Stratigility\\MiddlewarePipe; class ApiResourcePipelineDelegatorFactory implements DelegatorFactoryInterface { public function __invoke( ContainerInterface $container, $name, callable $callback, array $options = null ) : MiddlewarePipe { $factory = $container->get(MiddlewareFactory::class); $pipeline = new MiddlewarePipe(); // These correspond to the bullet points above $pipeline->pipe($factory->prepare(AuthenticationMiddleware::class)); $pipeline->pipe($factory->prepare(AuthorizationMiddleware::class)); $pipeline->pipe($factory->prepare(BodyParsingMiddleware::class)); $pipeline->pipe($factory->prepare(ValidationMiddleware::class)); // This is the actual handler you're routing to. $pipeline->pipe($callback()); return $pipeline; } } When configuring the container, you'd do something like the following: return [ 'dependencies' => [ 'factories' => [ AuthenticationMiddleware::class => '...', AuthorizationMiddleware::class => '...', BodyParsingMiddleware::class => '...', ValidationMiddleware::class => '...', ApiResource::class => '...', ], 'delegators' => [ ApiResource::class => [ ApiResourcePipelineDelegatorFactory::class, ], ], ], ]; This approach allows you to cleanly separate the factory for your middleware from the pipeline you want to compose it in, and allows you to re-use the pipeline creation across multiple middleware if desired. Middleware Arrays If you'd rather not create a factory for each such middleware, the other option is to use arrays of middlewares when routing. $app->route('/api/resource[/{id:[a-f0-9]{32}}]', [ AuthenticationMiddleware::class, AuthorizationMiddleware::class, BodyParsingMiddleware::class, ValidationMiddleware::class, ApiResource::class, ], ['GET', 'POST', 'PATCH', 'DELETE'], 'api-resource'); When either of these approaches are used, the individual middleware listed MUST be one of the following: an instance of Psr\\Http\\Middleware\\MiddlewareInterface ; a callable middleware (will be decorated using Zend\\Stratigility\\middleware() ); a service name of middleware available in the container; a fully qualified class name of a directly instantiable (no constructor arguments) middleware class. This approach is essentially equivalent to creating a factory that returns a middleware pipeline.","title":"Route-specific middleware pipelines"},{"location":"v3/cookbook/route-specific-pipeline/#how-can-i-specify-a-route-specific-middleware-pipeline","text":"Sometimes you may want to use a middleware pipeline only if a particular route is matched. As an example, for an API resource, you might want to: check for authentication credentials check for authorization for the selected action parse the incoming body validate the parsed body parameters before you actually execute the selected middleware. The above might each be encapsulated as discrete middleware, but should be executed within the routed middleware's context. You can accomplish this in one of two ways: Have your middleware service resolve to a MiddlewarePipe instance that composes the various middlewares. Specify an array of middlewares (either as actual instances, or as container service names); this effectively creates and returns a MiddlewarePipe .","title":"How can I specify a route-specific middleware pipeline?"},{"location":"v3/cookbook/route-specific-pipeline/#resolving-to-a-middlewarepipe","text":"You can do this programmatically within a container factory, assuming you are using a container that supports factories. use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\MiddlewareFactory; use Zend\\Stratigility\\MiddlewarePipe; class ApiResourcePipelineFactory { public function __invoke(ContainerInterface $container) { $factory = $container->get(MiddlewareFactory::class); $pipeline = new MiddlewarePipe(); // These correspond to the bullet points above $pipeline->pipe($factory->prepare(AuthenticationMiddleware::class)); $pipeline->pipe($factory->prepare(AuthorizationMiddleware::class)); $pipeline->pipe($factory->prepare(BodyParsingMiddleware::class)); $pipeline->pipe($factory->prepare(ValidationMiddleware::class)); // This is the actual handler you're routing to: $pipeline->pipe($factory->prepare(ApiResource::class)); return $pipeline; } } $factory->prepare() is used here to allow lazy-loading each middleware and handler. If we instead pulled each class from the container directly, each would be created, even if it was not ultimately executed. This gives you full control over the creation of the pipeline. You would, however, need to ensure that you map the middleware to the pipeline factory when setting up your container configuration. One alternative when using zend-servicemanager is to use a delegator factory . Delegator factories allow you to decorate the primary factory used to create the middleware in order to change the instance or return an alternate instance. In this case, we'd do the latter. The following is an example: use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\MiddlewareFactory; use Zend\\ServiceManager\\DelegatorFactoryInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; use Zend\\Stratigility\\MiddlewarePipe; class ApiResourcePipelineDelegatorFactory implements DelegatorFactoryInterface { public function __invoke( ContainerInterface $container, $name, callable $callback, array $options = null ) : MiddlewarePipe { $factory = $container->get(MiddlewareFactory::class); $pipeline = new MiddlewarePipe(); // These correspond to the bullet points above $pipeline->pipe($factory->prepare(AuthenticationMiddleware::class)); $pipeline->pipe($factory->prepare(AuthorizationMiddleware::class)); $pipeline->pipe($factory->prepare(BodyParsingMiddleware::class)); $pipeline->pipe($factory->prepare(ValidationMiddleware::class)); // This is the actual handler you're routing to. $pipeline->pipe($callback()); return $pipeline; } } When configuring the container, you'd do something like the following: return [ 'dependencies' => [ 'factories' => [ AuthenticationMiddleware::class => '...', AuthorizationMiddleware::class => '...', BodyParsingMiddleware::class => '...', ValidationMiddleware::class => '...', ApiResource::class => '...', ], 'delegators' => [ ApiResource::class => [ ApiResourcePipelineDelegatorFactory::class, ], ], ], ]; This approach allows you to cleanly separate the factory for your middleware from the pipeline you want to compose it in, and allows you to re-use the pipeline creation across multiple middleware if desired.","title":"Resolving to a MiddlewarePipe"},{"location":"v3/cookbook/route-specific-pipeline/#middleware-arrays","text":"If you'd rather not create a factory for each such middleware, the other option is to use arrays of middlewares when routing. $app->route('/api/resource[/{id:[a-f0-9]{32}}]', [ AuthenticationMiddleware::class, AuthorizationMiddleware::class, BodyParsingMiddleware::class, ValidationMiddleware::class, ApiResource::class, ], ['GET', 'POST', 'PATCH', 'DELETE'], 'api-resource'); When either of these approaches are used, the individual middleware listed MUST be one of the following: an instance of Psr\\Http\\Middleware\\MiddlewareInterface ; a callable middleware (will be decorated using Zend\\Stratigility\\middleware() ); a service name of middleware available in the container; a fully qualified class name of a directly instantiable (no constructor arguments) middleware class. This approach is essentially equivalent to creating a factory that returns a middleware pipeline.","title":"Middleware Arrays"},{"location":"v3/cookbook/setting-locale-depending-routing-parameter/","text":"How can I setup the locale depending on a routing parameter? Localized web applications often set the locale (and therefor the language) based on a routing parameter, the session, or a specialized sub-domain. In this recipe we will concentrate on using a routing parameter. Routing parameters Using the approach in this chapter requires that you add a /:locale (or similar) segment to each and every route that can be localized, and, depending on the router used, may also require additional options for specifying constraints. If the majority of your routes are localized, this will become tedious quickly. In such a case, you may want to look at the related recipe on setting the locale without routing parameters . Setting up the route If you want to set the locale depending on an routing parameter, you first have to add a locale parameter to each route that requires localization. In the following examples, we use the locale parameter, which should consist of two lowercase alphabetical characters. Dependency configuration The examples assume the following middleware dependency configuration: use App\\Handler; return [ 'dependencies' => [ 'factories' => [ Handler\\HomePageHandler::class => Handler\\HomePageHandlerFactory::class, Handler\\ContactPageHandler::class => Handler\\ContactPageFactory::class, ], ], ]; Programmatic routes The following describes routing configuration for use when using a programmatic application. use App\\Handler\\ContactPageHandler; use App\\Handler\\HomePageHandler; $localeOptions = ['locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)']; $app->get('/:locale', HomePageHandler::class, 'home') ->setOptions($localeOptions); $app->get('/:locale/contact', ContactPageHandler::class, 'contact') ->setOptions($localeOptions); Note: Routing may differ based on router The routing examples in this recipe use syntax for the zend-mvc router, and, as such, may not work in your application. For Aura.Router, the 'home' route as listed above would read: $$$$FENCED_CODE_BLOCK_5e03bde9eca333.40072268 For FastRoute: $$$$FENCED_CODE_BLOCK_5e03bde9eca464.21262410 As such, be aware as you read the examples that you might not be able to simply cut-and-paste them without modification. Create a route result middleware class for localization To make sure that you can setup the locale after the routing has been processed, you need to implement localization middleware that acts on the route result, and registered in the pipeline immediately following the routing middleware. Such a LocalizationMiddleware class could look similar to this: <?php namespace App\\I18n; use Locale; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class LocalizationMiddleware implements MiddlewareInterface { public const LOCALIZATION_ATTRIBUTE = 'locale'; public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // Get locale from route, fallback to the user's browser preference $locale = $request->getAttribute( 'locale', Locale::acceptFromHttp( $request->getServerParams()['HTTP_ACCEPT_LANGUAGE'] ?? 'en_US' ) ); // Store the locale as a request attribute return $handler->handle($request->withAttribute(self::LOCALIZATION_ATTRIBUTE, $locale)); } } Locale::setDefault is unsafe Do not use Locale::setDefault($locale) to set a global static locale. PSR-15 apps may run in async processes, which could lead to another process overwriting the value, and thus lead to unexpected results for your users. Use a request parameter as detailed above instead, as the request is created specific to each process. Register this new middleware in either config/autoload/middleware-pipeline.global.php or config/autoload/dependencies.global.php : return [ 'dependencies' => [ 'invokables' => [ LocalizationMiddleware::class => LocalizationMiddleware::class, /* ... */ ], /* ... */ ], ]; Pipe it immediately after your routing middleware: use App\\I18n\\LocalizationMiddleware; /* ... */ $app->pipe(RouteMiddleware::class); $app->pipe(LocalizationMiddleware::class); /* ... */","title":"Setting a locale based on a routing parameter"},{"location":"v3/cookbook/setting-locale-depending-routing-parameter/#how-can-i-setup-the-locale-depending-on-a-routing-parameter","text":"Localized web applications often set the locale (and therefor the language) based on a routing parameter, the session, or a specialized sub-domain. In this recipe we will concentrate on using a routing parameter.","title":"How can I setup the locale depending on a routing parameter?"},{"location":"v3/cookbook/setting-locale-depending-routing-parameter/#setting-up-the-route","text":"If you want to set the locale depending on an routing parameter, you first have to add a locale parameter to each route that requires localization. In the following examples, we use the locale parameter, which should consist of two lowercase alphabetical characters.","title":"Setting up the route"},{"location":"v3/cookbook/setting-locale-depending-routing-parameter/#create-a-route-result-middleware-class-for-localization","text":"To make sure that you can setup the locale after the routing has been processed, you need to implement localization middleware that acts on the route result, and registered in the pipeline immediately following the routing middleware. Such a LocalizationMiddleware class could look similar to this: <?php namespace App\\I18n; use Locale; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class LocalizationMiddleware implements MiddlewareInterface { public const LOCALIZATION_ATTRIBUTE = 'locale'; public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // Get locale from route, fallback to the user's browser preference $locale = $request->getAttribute( 'locale', Locale::acceptFromHttp( $request->getServerParams()['HTTP_ACCEPT_LANGUAGE'] ?? 'en_US' ) ); // Store the locale as a request attribute return $handler->handle($request->withAttribute(self::LOCALIZATION_ATTRIBUTE, $locale)); } }","title":"Create a route result middleware class for localization"},{"location":"v3/cookbook/setting-locale-without-routing-parameter/","text":"How can I setup the locale without routing parameters? Localized web applications often set the locale (and therefore the language) based on a routing parameter, the session, or a specialized sub-domain. In this recipe we will concentrate on introspecting the URI path via middleware, which allows you to have a global mechanism for detecting the locale without requiring any changes to existing routes. Distinguishing between routes that require localization If your application has a mixture of routes that require localization, and those that do not, the solution in this recipe may lead to multiple URIs that resolve to the identical action, which may be undesirable. In such cases, you may want to prefix the specific routes that require localization with a required routing parameter; this approach is described in the \"Setting a locale based on a routing parameter\" recipe . Setup a middleware to extract the locale from the URI First, we need to setup middleware that extracts the locale param directly from the request URI's path. If it doesn't find one, it sets a default. If it does find one, it uses the value to setup the locale. It also: amends the request with a truncated path (removing the locale segment). adds the locale segment as the base path of the UrlHelper . <?php namespace App\\I18n; use Locale; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Helper\\UrlHelper; class SetLocaleMiddleware implements MiddlewareInterface { private $helper; private $defaultLocale; private $fallbackLocale = 'en_US'; const REGEX_LOCALE = '#^/(?P<locale>[a-z]{2,3}|[a-z]{2}[-_][a-zA-Z]{2})(?:/|$)#'; public function __construct(UrlHelper $helper, string $defaultLocale = null) { $this->helper = $helper; if ($defaultLocale) { $this->defaultLocale = $defaultLocale; } } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $uri = $request->getUri(); $path = $uri->getPath(); if (! preg_match(self::REGEX_LOCALE, $path, $matches)) { Locale::setDefault($this->defaultLocale ?: $this->fallbackLocale); return $handler->handle($request); } $locale = $matches['locale']; Locale::setDefault(Locale::canonicalize($locale)); $this->helper->setBasePath($locale); $path = substr($path, strlen($locale) + 1); return $handler->handle($request->withUri( $uri->withPath($path ?: '/') )); } } Then you will need a factory for the SetLocaleMiddleware to inject the UrlHelper instance. <?php namespace App\\I18n; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Helper\\UrlHelper; /** * Configuration for setting a default locale should look like the following: * * <code> * 'i18n' => [ * 'default_locale' => 'de_DE', * ] * </code> */ class SetLocaleMiddlewareFactory { public function __invoke(ContainerInterface $container) { $config = $container->has('config') ? $container->get('config') : []; return new SetLocaleMiddleware( $container->get(UrlHelper::class), $config['i18n']['default_locale'] ?? null ); } } Next, map the middleware to its factory in either /config/autoload/dependencies.global.php or /config/autoload/middleware-pipeline.global.php : use App\\I18n\\SetLocaleMiddleware; use App\\I18n\\SetLocaleMiddlewareFactory; return [ 'dependencies' => [ /* ... */ 'factories' => [ SetLocaleMiddleware::class => SetLocaleMiddlewareFactory::class, /* ... */ ], ], ]; Finally, you will need to configure your middleware pipeline to ensure this middleware is executed on every request. Pipe the middleware early in your application, before routing is performed: use App\\I18n\\SetLocaleMiddleware; /* ... */ $app->pipe(SetLocaleMiddleware::class); /* ... */ $app->pipe(RouteMiddleware::class); /* ... */ $app->pipe(DispatchMiddleware::class); /* ... */ Url generation in the view Since the UrlHelper has the locale set as a base path, you don't need to worry about generating URLs within your view. Just use the helper to generate a URL and it will do the rest. <?= $this->url('your-route') ?> Helpers differ between template renderers The above example is specific to zend-view; syntax will differ for Twig and Plates. Redirecting within your request handlers If you want to add the locale parameter when creating URIs within your request handlers, you just need to inject the UrlHelper into your handler and use it for URL generation: <?php namespace App\\Handler; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\RedirectResponse; use Zend\\Expressive\\Helper\\UrlHelper; class RedirectHandler implements RequestHandlerInterface { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } public function handle(ServerRequestInterface $request) : ResponseInterface { $routeParams = [ /* ... */ ]; return new RedirectResponse( $this->helper->generate('your-route', $routeParams) ); } } Injecting the UrlHelper into your request handler will also require that the handler have a factory that manages the injection. As an example, the following would work for the above middleware: namespace App\\Handler; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Helper\\UrlHelper; class RedirectHandlerFactory { public function __invoke(ContainerInterface $container) { return new RedirectHandler( $container->get(UrlHelper::class) ); } }","title":"Setting a locale without a routing parameter"},{"location":"v3/cookbook/setting-locale-without-routing-parameter/#how-can-i-setup-the-locale-without-routing-parameters","text":"Localized web applications often set the locale (and therefore the language) based on a routing parameter, the session, or a specialized sub-domain. In this recipe we will concentrate on introspecting the URI path via middleware, which allows you to have a global mechanism for detecting the locale without requiring any changes to existing routes.","title":"How can I setup the locale without routing parameters?"},{"location":"v3/cookbook/setting-locale-without-routing-parameter/#setup-a-middleware-to-extract-the-locale-from-the-uri","text":"First, we need to setup middleware that extracts the locale param directly from the request URI's path. If it doesn't find one, it sets a default. If it does find one, it uses the value to setup the locale. It also: amends the request with a truncated path (removing the locale segment). adds the locale segment as the base path of the UrlHelper . <?php namespace App\\I18n; use Locale; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Helper\\UrlHelper; class SetLocaleMiddleware implements MiddlewareInterface { private $helper; private $defaultLocale; private $fallbackLocale = 'en_US'; const REGEX_LOCALE = '#^/(?P<locale>[a-z]{2,3}|[a-z]{2}[-_][a-zA-Z]{2})(?:/|$)#'; public function __construct(UrlHelper $helper, string $defaultLocale = null) { $this->helper = $helper; if ($defaultLocale) { $this->defaultLocale = $defaultLocale; } } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $uri = $request->getUri(); $path = $uri->getPath(); if (! preg_match(self::REGEX_LOCALE, $path, $matches)) { Locale::setDefault($this->defaultLocale ?: $this->fallbackLocale); return $handler->handle($request); } $locale = $matches['locale']; Locale::setDefault(Locale::canonicalize($locale)); $this->helper->setBasePath($locale); $path = substr($path, strlen($locale) + 1); return $handler->handle($request->withUri( $uri->withPath($path ?: '/') )); } } Then you will need a factory for the SetLocaleMiddleware to inject the UrlHelper instance. <?php namespace App\\I18n; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Helper\\UrlHelper; /** * Configuration for setting a default locale should look like the following: * * <code> * 'i18n' => [ * 'default_locale' => 'de_DE', * ] * </code> */ class SetLocaleMiddlewareFactory { public function __invoke(ContainerInterface $container) { $config = $container->has('config') ? $container->get('config') : []; return new SetLocaleMiddleware( $container->get(UrlHelper::class), $config['i18n']['default_locale'] ?? null ); } } Next, map the middleware to its factory in either /config/autoload/dependencies.global.php or /config/autoload/middleware-pipeline.global.php : use App\\I18n\\SetLocaleMiddleware; use App\\I18n\\SetLocaleMiddlewareFactory; return [ 'dependencies' => [ /* ... */ 'factories' => [ SetLocaleMiddleware::class => SetLocaleMiddlewareFactory::class, /* ... */ ], ], ]; Finally, you will need to configure your middleware pipeline to ensure this middleware is executed on every request. Pipe the middleware early in your application, before routing is performed: use App\\I18n\\SetLocaleMiddleware; /* ... */ $app->pipe(SetLocaleMiddleware::class); /* ... */ $app->pipe(RouteMiddleware::class); /* ... */ $app->pipe(DispatchMiddleware::class); /* ... */","title":"Setup a middleware to extract the locale from the URI"},{"location":"v3/cookbook/setting-locale-without-routing-parameter/#url-generation-in-the-view","text":"Since the UrlHelper has the locale set as a base path, you don't need to worry about generating URLs within your view. Just use the helper to generate a URL and it will do the rest. <?= $this->url('your-route') ?>","title":"Url generation in the view"},{"location":"v3/cookbook/setting-locale-without-routing-parameter/#redirecting-within-your-request-handlers","text":"If you want to add the locale parameter when creating URIs within your request handlers, you just need to inject the UrlHelper into your handler and use it for URL generation: <?php namespace App\\Handler; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\RedirectResponse; use Zend\\Expressive\\Helper\\UrlHelper; class RedirectHandler implements RequestHandlerInterface { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } public function handle(ServerRequestInterface $request) : ResponseInterface { $routeParams = [ /* ... */ ]; return new RedirectResponse( $this->helper->generate('your-route', $routeParams) ); } } Injecting the UrlHelper into your request handler will also require that the handler have a factory that manages the injection. As an example, the following would work for the above middleware: namespace App\\Handler; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Helper\\UrlHelper; class RedirectHandlerFactory { public function __invoke(ContainerInterface $container) { return new RedirectHandler( $container->get(UrlHelper::class) ); } }","title":"Redirecting within your request handlers"},{"location":"v3/cookbook/using-a-base-path/","text":"How can I tell my application about a base path? In some environments, your application may be running in a subdirectory of your web root. For example: var/ |- www/ | |- wordpress/ | |- expressive/ | | |- public/ | | | |- index.php where /var/www is the web root, and your Expressive application is in the expressive/ subdirectory. How can you make your application work correctly in this environment? .htaccess in the application root. If you are using Apache, your first step is to add an .htaccess file to your application root, with directives for rewriting to the public/ directory: RewriteEngine On RewriteRule (.*) ./public/$1 Using other web servers If you are using a web-server other than Apache, and know how to do a similar rewrite, we'd love to know! Please submit ideas/instructions to our issue tracker ! Use middleware to rewrite the path The above step ensures that clients can hit the website. Now we need to ensure that the application can route to middleware! To do this, we will add pipeline middleware to intercept the request, and rewrite the URL accordingly. At the time of writing, we have two suggestions: los/basepath provides the basic mechanics of rewriting the URL. mtymek/blast-base-url provides the URL rewriting mechanics, as well as utilities for generating URIs that retain the base path. los/basepath To use los/basepath , install it via Composer, copy the configuration files to your application, and then edit the configuration. To install and copy the configuration: $ composer require los/basepath $ cp vendor/los/basepath/config/los-basepath.global.php.dist config/autoload/los-basepath.global.php We recommend copying the global configuration to a local configuration file as well; this allows you to have the production settings in your global configuration, and development settings in a local configuration (which is excluded from git by default): $ cp config/autoload/los-basepath.global.php config/autoload/los-basepath.local.php Then edit one or both, to change the los_basepath settings: return [ 'los_basepath' => '<base path here>', /* ... */ ]; The base path should be the portion of the web root leading up to the index.php of your application. In the above example, this would be /expressive . mtymek/blast-base-url To use mtymek/blast-base-url , install it via Composer, and register some configuration. To install it: $ composer require mtymek/blast-base-url If you are using zend-component-installer , you will be prompted to configure this package automatically. If you don't choose to do so, you please refer to Blast\\BaseUrl\\ConfigProvider class to see how to wire it manually. If using programmatic pipelines, pipe the middleware early in your pipeline (before routing): $app->pipe(\\Blast\\BaseUrl\\BaseUrlMiddleware::class); For configuration-driven pipelines, add an entry in your config/autoload/middleware-pipeline.global.php file: 'middleware_pipeline' => [ ['middleware' => [Blast\\BaseUrl\\BaseUrlMiddleware::class], 'priority' => 1000], /* ... */ ], At this point, the middleware will take care of the rewriting for you. No configuration is necessary, as it does auto-detection of the base path based on the request URI and the operating system path to the application. The primary advantage of mtymek/blast-base-url is in its additional features: it injects Zend\\Expressive\\Helper\\UrlHelper with the base path, allowing you to create relative route-based URLs. it provides a new helper, Blast\\BaseUrl\\BasePathHelper , which allows you to create URLs relative to the base path; this is particularly useful for assets. If you are using zend-view as your templating engine, this view helper will be available out of the box. Usage of the BasePath helper is as follows: // where $basePathHelper is an instance of Blast\\BaseUrl\\BasePathHelper // as pulled from your container: echo $basePathHelper('/icons/favicon.ico'); // or, from zend-view's PhpRenderer: echo $this->basePath('/icons/favicon.ico');","title":"Using Expressive from a subdirectory"},{"location":"v3/cookbook/using-a-base-path/#how-can-i-tell-my-application-about-a-base-path","text":"In some environments, your application may be running in a subdirectory of your web root. For example: var/ |- www/ | |- wordpress/ | |- expressive/ | | |- public/ | | | |- index.php where /var/www is the web root, and your Expressive application is in the expressive/ subdirectory. How can you make your application work correctly in this environment?","title":"How can I tell my application about a base path?"},{"location":"v3/cookbook/using-a-base-path/#htaccess-in-the-application-root","text":"If you are using Apache, your first step is to add an .htaccess file to your application root, with directives for rewriting to the public/ directory: RewriteEngine On RewriteRule (.*) ./public/$1","title":".htaccess in the application root."},{"location":"v3/cookbook/using-a-base-path/#use-middleware-to-rewrite-the-path","text":"The above step ensures that clients can hit the website. Now we need to ensure that the application can route to middleware! To do this, we will add pipeline middleware to intercept the request, and rewrite the URL accordingly. At the time of writing, we have two suggestions: los/basepath provides the basic mechanics of rewriting the URL. mtymek/blast-base-url provides the URL rewriting mechanics, as well as utilities for generating URIs that retain the base path.","title":"Use middleware to rewrite the path"},{"location":"v3/cookbook/using-custom-view-helpers/","text":"How do you register custom view helpers when using zend-view? If you've selected zend-view as your preferred template renderer, you may want to define and use custom view helpers. How can you use them? Assuming you've used the Expressive skeleton to start your application, you will already have a factory defined for Zend\\View\\HelperPluginManager , and it will be injected into the PhpRenderer instance used. Since the HelperPluginManager is available, we can configure it. Open the file config/autoload/templates.global.php . In that file, you'll see three top-level keys: return [ 'dependencies' => [ /* ... */ ], 'templates' => [ /* ... */ ], 'view_helpers' => [ /* ... */ ], ]; The last is the one you want. In this, you can define service mappings, including aliases, invokables, factories, and abstract factories to define how helpers are named and created. See the zend-view custom helpers documentation for information on how to populate this configuration.","title":"Registering custom view helpers when using zend-view"},{"location":"v3/cookbook/using-custom-view-helpers/#how-do-you-register-custom-view-helpers-when-using-zend-view","text":"If you've selected zend-view as your preferred template renderer, you may want to define and use custom view helpers. How can you use them? Assuming you've used the Expressive skeleton to start your application, you will already have a factory defined for Zend\\View\\HelperPluginManager , and it will be injected into the PhpRenderer instance used. Since the HelperPluginManager is available, we can configure it. Open the file config/autoload/templates.global.php . In that file, you'll see three top-level keys: return [ 'dependencies' => [ /* ... */ ], 'templates' => [ /* ... */ ], 'view_helpers' => [ /* ... */ ], ]; The last is the one you want. In this, you can define service mappings, including aliases, invokables, factories, and abstract factories to define how helpers are named and created. See the zend-view custom helpers documentation for information on how to populate this configuration.","title":"How do you register custom view helpers when using zend-view?"},{"location":"v3/cookbook/using-zend-form-view-helpers/","text":"How can I use zend-form view helpers? If you've selected zend-view as your preferred template renderer, you'll likely want to use the various view helpers available in other components, such as: zend-form zend-i18n zend-navigation By default, only the view helpers directly available in zend-view are available; how can you add the others? ConfigProvider When you install zend-form, Composer should prompt you if you want to inject one or more ConfigProvider classes, including those from zend-hydrator, zend-inputfilter, and several others. Always answer \"yes\" to these; when you do, a Composer plugin will add entries for their ConfigProvider classes to your config/config.php file. If for some reason you are not prompted, or chose \"no\" when answering the prompts, you can add them manually. Add the following entries in the array used to create your ConfigAggregator instance within config/config.php : \\Zend\\Form\\ConfigProvider::class, \\Zend\\InputFilter\\ConfigProvider::class, \\Zend\\Filter\\ConfigProvider::class, \\Zend\\Validator\\ConfigProvider::class, \\Zend\\Hydrator\\ConfigProvider::class, If you installed Expressive via the skeleton, the service Zend\\View\\HelperPluginManager is registered for you, and represents the helper plugin manager injected into the PhpRenderer instance. This instance gets its helper configuration from the view_helpers top-level configuration key \u2014 which the zend-form ConfigProvider helps to populate! At this point, all view helpers provided by zend-form are registered and ready to use.","title":"Using zend-form view helpers"},{"location":"v3/cookbook/using-zend-form-view-helpers/#how-can-i-use-zend-form-view-helpers","text":"If you've selected zend-view as your preferred template renderer, you'll likely want to use the various view helpers available in other components, such as: zend-form zend-i18n zend-navigation By default, only the view helpers directly available in zend-view are available; how can you add the others?","title":"How can I use zend-form view helpers?"},{"location":"v3/cookbook/using-zend-form-view-helpers/#configprovider","text":"When you install zend-form, Composer should prompt you if you want to inject one or more ConfigProvider classes, including those from zend-hydrator, zend-inputfilter, and several others. Always answer \"yes\" to these; when you do, a Composer plugin will add entries for their ConfigProvider classes to your config/config.php file. If for some reason you are not prompted, or chose \"no\" when answering the prompts, you can add them manually. Add the following entries in the array used to create your ConfigAggregator instance within config/config.php : \\Zend\\Form\\ConfigProvider::class, \\Zend\\InputFilter\\ConfigProvider::class, \\Zend\\Filter\\ConfigProvider::class, \\Zend\\Validator\\ConfigProvider::class, \\Zend\\Hydrator\\ConfigProvider::class, If you installed Expressive via the skeleton, the service Zend\\View\\HelperPluginManager is registered for you, and represents the helper plugin manager injected into the PhpRenderer instance. This instance gets its helper configuration from the view_helpers top-level configuration key \u2014 which the zend-form ConfigProvider helps to populate! At this point, all view helpers provided by zend-form are registered and ready to use.","title":"ConfigProvider"},{"location":"v3/features/application/","text":"Applications In zend-expressive, you define a Zend\\Expressive\\Application instance and execute it. The Application instance is itself middleware that composes: a Zend\\Expressive\\MiddlewareFactory instance, used to prepare middleware arguments to pipe into: a Zend\\Stratigility\\MiddlewarePipe instance, representing the application middleware pipeline. a Zend\\Expressive\\Router\\RouteCollector instance, used to create Zend\\Expressive\\Router\\Route instances based on a combination of paths and HTTP methods, and which also injects created instances into the application's router. a Zend\\HttpHandlerRunner\\RequestHandlerRunner instance which will ultimately be responsible for marshaling the incoming request, passing it to the MiddlewarePipe , and emitting the response. You can define the Application instance in two ways: Direct instantiation, which requires providing several dependencies. Via a dependency injection container; we provide a factory for setting up all aspects of the instance via configuration and other defined services. Regardless of how you setup the instance, there are several methods you will likely interact with at some point or another. Instantiation Constructor If you wish to manually instantiate the Application instance, it has the following constructor: public function __construct( Zend\\Expressive\\MiddlewareFactory $factory, Zend\\Stratigility\\MiddlewarePipeInterface $pipeline, Zend\\Expressive\\Router\\RouteCollector $routes, Zend\\HttpHandlerRunner\\RequestHandlerRunner $runner ) { Container factory We also provide a factory that can be consumed by a PSR-11 dependency injection container; see the container factories documentation for details. Adding routable middleware We discuss routing vs piping elsewhere ; routing is the act of dynamically matching an incoming request against criteria, and it is one of the primary features of zend-expressive. Regardless of which router implementation you use, you can use the following Application methods to provide routable middleware: route() route() has the following signature: public function route( string $path, $middleware, array $methods = null, string $name = null ) : Zend\\Expressive\\Router\\Route where: $path must be a string path to match. $middleware must be: a service name that resolves to valid middleware in the container; a fully qualified class name of a constructor-less class that represents a PSR-15 MiddlewareInterface or RequestHandlerInterface instance; an array of any of the above; these will be composed in order into a Zend\\Stratigility\\MiddlewarePipe instance. $methods must be an array of HTTP methods valid for the given path and middleware. If null, it assumes any method is valid. $name is the optional name for the route, and is used when generating a URI from known routes. See the section on route naming for details. This method is typically only used if you want a single middleware to handle multiple HTTP request methods. get(), post(), put(), patch(), delete(), any() Each of the methods get() , post() , put() , patch() , delete() , and any() proxies to route() and has the signature: function ( string $path, $middleware, string $name = null ) : Zend\\Expressive\\Router\\Route Essentially, each calls route() and specifies an array consisting solely of the corresponding HTTP method for the $methods argument. Piping Because zend-expressive builds on zend-stratigility , and, more specifically, its MiddlewarePipe definition, you can also pipe (queue) middleware to the application. This is useful for adding middleware that should execute on each request, defining error handlers, and/or segregating applications by subpath. The signature of pipe() is: public function pipe($middlewareOrPath, $middleware = null) where: $middlewareOrPath is either a string URI path (for path segregation), PSR-15 MiddlewareInterface or RequestHandlerInterface , or the service name for a middleware or request handler to fetch from the composed container. $middleware is required if $middlewareOrPath is a string URI path. It can be one of: a service name that resolves to valid middleware in the container; a fully qualified class name of a constructor-less class that represents a PSR-15 MiddlewareInterface or RequestHandlerInterface instance; an array of any of the above; these will be composed in order into a Zend\\Stratigility\\MiddlewarePipe instance. Unlike Zend\\Stratigility\\MiddlewarePipe , Application::pipe() allows fetching middleware and request handlers by service name . This facility allows lazy-loading of middleware only when it is invoked. Internally, it wraps the call to fetch and dispatch the middleware inside a Zend\\Expressive\\Middleware\\LazyLoadingMiddleware instance. Read the section on piping vs routing for more information. Registering routing and dispatch middleware Routing and dispatch middleware must be piped to the application like any other middleware. You can do so using the following: $app->pipe(Zend\\Expressive\\Router\\Middleware\\RouteMiddleware::class); $app->pipe(Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware::class); We recommend piping the following middleware between the two as well: $app->pipe(Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware::class); $app->pipe(Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware::class); $app->pipe(Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware::class); These allow your application to return: HEAD requests for handlers that do not specifically allow HEAD ; these will return with a 200 status, and any headers normally returned with a GET request. OPTIONS requests for handlers that do not specifically allow OPTIONS ; these will return with a 200 status, and an Allow header indicating all allowed HTTP methods for the given route match. 405 statuses when the route matches, but not the HTTP method; these will also include an Allow header indicating all allowed HTTP methods. See the section on piping to see how you can register non-routed middleware and create layered middleware applications. Executing the application: run() When the application is completely setup, you can execute it with the run() method. The method proxies to the underlying RequestHandlerRunner , which will create a PSR-7 server request instance, pass it to the composed middleware pipeline, and then emit the response returned.","title":"Applications"},{"location":"v3/features/application/#applications","text":"In zend-expressive, you define a Zend\\Expressive\\Application instance and execute it. The Application instance is itself middleware that composes: a Zend\\Expressive\\MiddlewareFactory instance, used to prepare middleware arguments to pipe into: a Zend\\Stratigility\\MiddlewarePipe instance, representing the application middleware pipeline. a Zend\\Expressive\\Router\\RouteCollector instance, used to create Zend\\Expressive\\Router\\Route instances based on a combination of paths and HTTP methods, and which also injects created instances into the application's router. a Zend\\HttpHandlerRunner\\RequestHandlerRunner instance which will ultimately be responsible for marshaling the incoming request, passing it to the MiddlewarePipe , and emitting the response. You can define the Application instance in two ways: Direct instantiation, which requires providing several dependencies. Via a dependency injection container; we provide a factory for setting up all aspects of the instance via configuration and other defined services. Regardless of how you setup the instance, there are several methods you will likely interact with at some point or another.","title":"Applications"},{"location":"v3/features/application/#instantiation","text":"","title":"Instantiation"},{"location":"v3/features/application/#adding-routable-middleware","text":"We discuss routing vs piping elsewhere ; routing is the act of dynamically matching an incoming request against criteria, and it is one of the primary features of zend-expressive. Regardless of which router implementation you use, you can use the following Application methods to provide routable middleware:","title":"Adding routable middleware"},{"location":"v3/features/application/#executing-the-application-run","text":"When the application is completely setup, you can execute it with the run() method. The method proxies to the underlying RequestHandlerRunner , which will create a PSR-7 server request instance, pass it to the composed middleware pipeline, and then emit the response returned.","title":"Executing the application: run()"},{"location":"v3/features/emitters/","text":"Emitters To simplify the usage of Expressive, we added the run() method, which handles the incoming request, and emits a response. The latter aspect, emitting the response, is the responsibility of an emitter . An emitter accepts a response instance, and then does something with it, usually sending the response back to a browser. The zendframework/zend-httphandlerrunner package defines an EmitterInterface , and three emitter implementations. Two of these, Zend\\HttpHandlerRunner\\Emitter\\SapiEmitter and Zend\\HttpHandlerRunner\\Emitter\\SapiStreamEmitter , send headers and output using PHP's standard SAPI mechanisms (the header() method and the output buffer). We recognize that there are times when you may want to use alternate emitter implementations; for example, if you use React , the SAPI emitter will likely not work for you. To facilitate alternate emitters, we offer two facilities: First, a Zend\\HttpHandlerRunner\\RequestHandlerRunner instance is composed in the Application instance, and you can specify an alternate emitter during instantiation, or via the Zend\\HttpHandlerRunner\\Emitter\\EmitterInterface service when using the container factory. Second, we provide Zend\\HttpHandlerRunner\\Emitter\\EmitterStack , which allows you to compose multiple emitter strategies; the first to return a boolean true will cause execution of the stack to short-circuit. The RequestHandlerRunner service composes an EmitterStack by default, with an SapiEmitter composed at the bottom of the stack.","title":"Emitters"},{"location":"v3/features/emitters/#emitters","text":"To simplify the usage of Expressive, we added the run() method, which handles the incoming request, and emits a response. The latter aspect, emitting the response, is the responsibility of an emitter . An emitter accepts a response instance, and then does something with it, usually sending the response back to a browser. The zendframework/zend-httphandlerrunner package defines an EmitterInterface , and three emitter implementations. Two of these, Zend\\HttpHandlerRunner\\Emitter\\SapiEmitter and Zend\\HttpHandlerRunner\\Emitter\\SapiStreamEmitter , send headers and output using PHP's standard SAPI mechanisms (the header() method and the output buffer). We recognize that there are times when you may want to use alternate emitter implementations; for example, if you use React , the SAPI emitter will likely not work for you. To facilitate alternate emitters, we offer two facilities: First, a Zend\\HttpHandlerRunner\\RequestHandlerRunner instance is composed in the Application instance, and you can specify an alternate emitter during instantiation, or via the Zend\\HttpHandlerRunner\\Emitter\\EmitterInterface service when using the container factory. Second, we provide Zend\\HttpHandlerRunner\\Emitter\\EmitterStack , which allows you to compose multiple emitter strategies; the first to return a boolean true will cause execution of the stack to short-circuit. The RequestHandlerRunner service composes an EmitterStack by default, with an SapiEmitter composed at the bottom of the stack.","title":"Emitters"},{"location":"v3/features/error-handling/","text":"Error Handling We recommend that your code raise exceptions for conditions where it cannot gracefully recover. Additionally, we recommend that you have a reasonable PHP error_reporting setting that includes warnings and fatal errors: error_reporting(E_ALL & ~E_USER_DEPRECATED & ~E_DEPRECATED & ~E_STRICT & ~E_NOTICE); If you follow these guidelines, you can then write or use middleware that does the following: sets an error handler that converts PHP errors to ErrorException instances. wraps execution of the handler ( $handler->handle() ) with a try/catch block. As an example: function (ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { set_error_handler(function ($errno, $errstr, $errfile, $errline) { if (! (error_reporting() & $errno)) { // Error is not in mask return; } throw new ErrorException($errstr, 0, $errno, $errfile, $errline); }); try { $response = $handler->handle($request); return $response; } catch (Throwable $e) { } restore_error_handler(); $response = new TextResponse(sprintf( \"[%d] %s\\n\\n%s\", $e->getCode(), $e->getMessage(), $e->getTraceAsString() ), 500); } You would then pipe this as the outermost (or close to outermost) layer of your application: $app->pipe($errorMiddleware); So that you do not need to do this, we provide an error handler for you, via zend-stratigility: Zend\\Stratigility\\Middleware\\ErrorHandler . This implementation allows you to both: provide a response generator, invoked when an error is caught; and register listeners to trigger when errors are caught. We provide the factory Zend\\Expressive\\Container\\ErrorHandlerFactory for generating the instance; it should be mapped to the service Zend\\Stratigility\\Middleware\\ErrorHandler . We provide two error response generators for you: Zend\\Expressive\\Middleware\\ErrorResponseGenerator , which optionally will accept a Zend\\Expressive\\Template\\TemplateRendererInterface instance, and a template name. When present, these will be used to generate response content; otherwise, a plain text response is generated that notes the request method and URI. Since version 3.1.0, it also accepts a layout name, if you want to use one other than layout::default . Zend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator , which uses whoops to present detailed exception and request information; this implementation is intended for development purposes. Each also has an accompanying factory for generating the instance: Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory Map the service Zend\\Expressive\\Middleware\\ErrorResponseGenerator to one of these two factories in your configuration: use Zend\\Expressive\\Container; use Zend\\Expressive\\Middleware; use Zend\\Stratigility\\Middleware\\ErrorHandler; return [ 'dependencies' => [ 'factories' => [ ErrorHandler::class => Container\\ErrorHandlerFactory::class, Middleware\\ErrorResponseGenerator::class => Container\\ErrorResponseGeneratorFactory::class, ], ], ]; Use development mode configuration to enable whoops You can specify the above in one of your config/autoload/*.global.php files, to ensure you have a production-capable error response generator. If you are using zf-development-mode in your application (which is provided by default in the skeleton application), you can toggle usage of whoops by adding configuration to the file config/autoload/development.local.php.dist : $$$$FENCED_CODE_BLOCK_5e03bde9e94531.48235177 When you enable development mode, whoops will then be enabled; when you disable development mode, you'll be using your production generator. If you are not using zf-development-mode, you can define a config/autoload/*.local.php file with the above configuration whenever you want to enable whoops. Listening for errors When errors occur, you may want to listen for them in order to provide features such as logging. Zend\\Stratigility\\Middleware\\ErrorHandler provides the ability to do so via its attachListener() method. This method accepts a callable with the following signature: function ( Throwable $error, ServerRequestInterface $request, ResponseInterface $response ) : void The response provided is the response returned by your error response generator, allowing the listener the ability to introspect the generated response as well. As an example, you could create a logging listener as follows: namespace Acme; use Exception; use Psr\\Log\\LoggerInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Throwable; class LoggingErrorListener { /** * Log format for messages: * * STATUS [METHOD] path: message */ const LOG_FORMAT = '%d [%s] %s: %s'; private $logger; public function __construct(LoggerInterface $logger) { $this->logger = $logger; } public function __invoke(Throwable $error, ServerRequestInterface $request, ResponseInterface $response) { $this->logger->error(sprintf( self::LOG_FORMAT, $response->getStatusCode(), $request->getMethod(), (string) $request->getUri(), $error->getMessage() )); } } You could then use a delegator factory to create your logger listener and attach it to your error handler: namespace Acme; use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; use Zend\\Stratigility\\Middleware\\ErrorHandler; class LoggingErrorListenerDelegatorFactory { public function __invoke(ContainerInterface $container, string $name, callable $callback) : ErrorHandler { $listener = new LoggingErrorListener($container->get(LoggerInterface::class)); $errorHandler = $callback(); $errorHandler->attachListener($listener); return $errorHandler; } } Handling more specific error types You could also write more specific error handlers. As an example, you might want to catch UnauthorizedException instances specifically, and display a login page: function (ServerRequestInterface $request, RequestHandlerInterface $handler) use ($renderer) : ResponseInterface { try { $response = $handler->handle($request); return $response; } catch (UnauthorizedException $e) { } return new HtmlResponse( $renderer->render('error::unauthorized'), 401 ); } You could then push this into a middleware pipe only when it's needed: $app->get('/dashboard', [ $unauthorizedHandlerMiddleware, $middlewareThatChecksForAuthorization, $middlewareBehindAuthorizationWall, ], 'dashboard'); Page not found Error handlers work at the outermost layer, and are used to catch exceptions and errors in your application. At the innermost layer of your application, you should ensure you have middleware that is guaranteed to return a response; this prevents errors in your application in the event that the application exhausts the middleware queue. This in turn allows you to fully craft what sort of response is returned in such conditions. Generally speaking, reaching the innermost middleware layer indicates that no middleware was capable of handling the request, and thus an HTTP 404 Not Found condition. To simplify such responses, we provide Zend\\Expressive\\Handler\\NotFoundHandler . It will report a 404 response, optionally using a composed template renderer to do so. We provide a factory, Zend\\Expressive\\Container\\NotFoundHandlerFactory , for creating an instance, which we detail elsewhere . You should pipe it as the innermost layer of your application: // A basic application: $app->pipe(ErrorHandler::class); // . . . $app->pipe(RouteMiddleware::class); // . . . $app->pipe(DispatchMiddleware::class); $app->pipe(NotFoundHandler::class); If you wish to provide an alternate response status or use a canned response, you should provide your own handler and pipe it to your application.","title":"Error Handling"},{"location":"v3/features/error-handling/#error-handling","text":"We recommend that your code raise exceptions for conditions where it cannot gracefully recover. Additionally, we recommend that you have a reasonable PHP error_reporting setting that includes warnings and fatal errors: error_reporting(E_ALL & ~E_USER_DEPRECATED & ~E_DEPRECATED & ~E_STRICT & ~E_NOTICE); If you follow these guidelines, you can then write or use middleware that does the following: sets an error handler that converts PHP errors to ErrorException instances. wraps execution of the handler ( $handler->handle() ) with a try/catch block. As an example: function (ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { set_error_handler(function ($errno, $errstr, $errfile, $errline) { if (! (error_reporting() & $errno)) { // Error is not in mask return; } throw new ErrorException($errstr, 0, $errno, $errfile, $errline); }); try { $response = $handler->handle($request); return $response; } catch (Throwable $e) { } restore_error_handler(); $response = new TextResponse(sprintf( \"[%d] %s\\n\\n%s\", $e->getCode(), $e->getMessage(), $e->getTraceAsString() ), 500); } You would then pipe this as the outermost (or close to outermost) layer of your application: $app->pipe($errorMiddleware); So that you do not need to do this, we provide an error handler for you, via zend-stratigility: Zend\\Stratigility\\Middleware\\ErrorHandler . This implementation allows you to both: provide a response generator, invoked when an error is caught; and register listeners to trigger when errors are caught. We provide the factory Zend\\Expressive\\Container\\ErrorHandlerFactory for generating the instance; it should be mapped to the service Zend\\Stratigility\\Middleware\\ErrorHandler . We provide two error response generators for you: Zend\\Expressive\\Middleware\\ErrorResponseGenerator , which optionally will accept a Zend\\Expressive\\Template\\TemplateRendererInterface instance, and a template name. When present, these will be used to generate response content; otherwise, a plain text response is generated that notes the request method and URI. Since version 3.1.0, it also accepts a layout name, if you want to use one other than layout::default . Zend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator , which uses whoops to present detailed exception and request information; this implementation is intended for development purposes. Each also has an accompanying factory for generating the instance: Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory Map the service Zend\\Expressive\\Middleware\\ErrorResponseGenerator to one of these two factories in your configuration: use Zend\\Expressive\\Container; use Zend\\Expressive\\Middleware; use Zend\\Stratigility\\Middleware\\ErrorHandler; return [ 'dependencies' => [ 'factories' => [ ErrorHandler::class => Container\\ErrorHandlerFactory::class, Middleware\\ErrorResponseGenerator::class => Container\\ErrorResponseGeneratorFactory::class, ], ], ];","title":"Error Handling"},{"location":"v3/features/error-handling/#listening-for-errors","text":"When errors occur, you may want to listen for them in order to provide features such as logging. Zend\\Stratigility\\Middleware\\ErrorHandler provides the ability to do so via its attachListener() method. This method accepts a callable with the following signature: function ( Throwable $error, ServerRequestInterface $request, ResponseInterface $response ) : void The response provided is the response returned by your error response generator, allowing the listener the ability to introspect the generated response as well. As an example, you could create a logging listener as follows: namespace Acme; use Exception; use Psr\\Log\\LoggerInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Throwable; class LoggingErrorListener { /** * Log format for messages: * * STATUS [METHOD] path: message */ const LOG_FORMAT = '%d [%s] %s: %s'; private $logger; public function __construct(LoggerInterface $logger) { $this->logger = $logger; } public function __invoke(Throwable $error, ServerRequestInterface $request, ResponseInterface $response) { $this->logger->error(sprintf( self::LOG_FORMAT, $response->getStatusCode(), $request->getMethod(), (string) $request->getUri(), $error->getMessage() )); } } You could then use a delegator factory to create your logger listener and attach it to your error handler: namespace Acme; use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; use Zend\\Stratigility\\Middleware\\ErrorHandler; class LoggingErrorListenerDelegatorFactory { public function __invoke(ContainerInterface $container, string $name, callable $callback) : ErrorHandler { $listener = new LoggingErrorListener($container->get(LoggerInterface::class)); $errorHandler = $callback(); $errorHandler->attachListener($listener); return $errorHandler; } }","title":"Listening for errors"},{"location":"v3/features/error-handling/#handling-more-specific-error-types","text":"You could also write more specific error handlers. As an example, you might want to catch UnauthorizedException instances specifically, and display a login page: function (ServerRequestInterface $request, RequestHandlerInterface $handler) use ($renderer) : ResponseInterface { try { $response = $handler->handle($request); return $response; } catch (UnauthorizedException $e) { } return new HtmlResponse( $renderer->render('error::unauthorized'), 401 ); } You could then push this into a middleware pipe only when it's needed: $app->get('/dashboard', [ $unauthorizedHandlerMiddleware, $middlewareThatChecksForAuthorization, $middlewareBehindAuthorizationWall, ], 'dashboard');","title":"Handling more specific error types"},{"location":"v3/features/error-handling/#page-not-found","text":"Error handlers work at the outermost layer, and are used to catch exceptions and errors in your application. At the innermost layer of your application, you should ensure you have middleware that is guaranteed to return a response; this prevents errors in your application in the event that the application exhausts the middleware queue. This in turn allows you to fully craft what sort of response is returned in such conditions. Generally speaking, reaching the innermost middleware layer indicates that no middleware was capable of handling the request, and thus an HTTP 404 Not Found condition. To simplify such responses, we provide Zend\\Expressive\\Handler\\NotFoundHandler . It will report a 404 response, optionally using a composed template renderer to do so. We provide a factory, Zend\\Expressive\\Container\\NotFoundHandlerFactory , for creating an instance, which we detail elsewhere . You should pipe it as the innermost layer of your application: // A basic application: $app->pipe(ErrorHandler::class); // . . . $app->pipe(RouteMiddleware::class); // . . . $app->pipe(DispatchMiddleware::class); $app->pipe(NotFoundHandler::class); If you wish to provide an alternate response status or use a canned response, you should provide your own handler and pipe it to your application.","title":"Page not found"},{"location":"v3/features/middleware-types/","text":"Middleware Types Expressive allows you to compose applications out of pipeline and routed middleware. Pipeline middleware is middleware that defines the workflow of your application. These generally run on every execution of the application, and include such aspects as: Error handling Locale detection Session setup Authentication and authorization Routed middleware is middleware that responds only to specific URI paths and HTTP methods. As an example, you might want middleware that only responds to HTTP POST requests to the path /users . Expressive allows you to define middleware using any of the following: PSR-15 middleware instances. PSR-15 request handler instances. Service names resolving to one of the above middleware types. Callable middleware that implements the PSR-15 MiddlewareInterface signature. Middleware pipelines expressed as arrays of the above middleware types. PSR-15 middleware The PSR-15 specification covers HTTP server middleware and request handlers that consume PSR-7 HTTP messages. Expressive accepts both middleware that implements the MiddlewareInterface and request handlers that implement RequestHandlerInterface . As an example: use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; class SomeMiddleware implements MiddlewareInterface { public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // do something and return a response, or // delegate to another request handler capable // of returning a response via: // // return $handler->handle($request); } } You could also implement such middleware via an anonymous class. Callable middleware Sometimes you may not want to create a class for one-off middleware. As such, Expressive allows you to provide a PHP callable that uses the same signature as Psr\\Http\\Server\\MiddlewareInterface : use Psr\\Http\\Server\\RequestHandlerInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; function (ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // do something and return a response, or // delegate to another request handler capable // of returning a response via: // // return $handler->handle($request); } One note: neither argument require a typehint, and examples throughout the manual will omit the typehints when demonstrating callable middleware. Service-based middleware We encourage the use of a dependency injection container for providing your middleware. As such, Expressive also allows you to use service names for both pipeline and routed middleware. Generally, service names will be the specific middleware class names, but can be any valid string that resolves to a service. When Expressive is provided a service name for middleware, it internally decorates the middleware in a Zend\\Expressive\\Middleware\\LazyLoadingMiddleware instance, allowing it to be loaded only when dispatched. Middleware pipelines Expressive allows any pipeline or routed middleware to be self-contained middleware pipelines . To prevent the need for instantiating a Zend\\Stratigility\\MiddlewarePipe instance when defining the pipeline, Expressive allows you to provide an array of middleware: // Pipeline middleware: $app->pipe([ FirstMiddleware::class, SecondMiddleware::class, ]); // Routed middleware: $app->get('/foo', [ FirstMiddleware::class, SecondMiddleware::class, ]); The values in these arrays may be any valid middleware type as defined in this chapter.","title":"Middleware Types"},{"location":"v3/features/middleware-types/#middleware-types","text":"Expressive allows you to compose applications out of pipeline and routed middleware. Pipeline middleware is middleware that defines the workflow of your application. These generally run on every execution of the application, and include such aspects as: Error handling Locale detection Session setup Authentication and authorization Routed middleware is middleware that responds only to specific URI paths and HTTP methods. As an example, you might want middleware that only responds to HTTP POST requests to the path /users . Expressive allows you to define middleware using any of the following: PSR-15 middleware instances. PSR-15 request handler instances. Service names resolving to one of the above middleware types. Callable middleware that implements the PSR-15 MiddlewareInterface signature. Middleware pipelines expressed as arrays of the above middleware types.","title":"Middleware Types"},{"location":"v3/features/middleware-types/#psr-15-middleware","text":"The PSR-15 specification covers HTTP server middleware and request handlers that consume PSR-7 HTTP messages. Expressive accepts both middleware that implements the MiddlewareInterface and request handlers that implement RequestHandlerInterface . As an example: use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; class SomeMiddleware implements MiddlewareInterface { public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // do something and return a response, or // delegate to another request handler capable // of returning a response via: // // return $handler->handle($request); } } You could also implement such middleware via an anonymous class.","title":"PSR-15 middleware"},{"location":"v3/features/middleware-types/#callable-middleware","text":"Sometimes you may not want to create a class for one-off middleware. As such, Expressive allows you to provide a PHP callable that uses the same signature as Psr\\Http\\Server\\MiddlewareInterface : use Psr\\Http\\Server\\RequestHandlerInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; function (ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { // do something and return a response, or // delegate to another request handler capable // of returning a response via: // // return $handler->handle($request); } One note: neither argument require a typehint, and examples throughout the manual will omit the typehints when demonstrating callable middleware.","title":"Callable middleware"},{"location":"v3/features/middleware-types/#service-based-middleware","text":"We encourage the use of a dependency injection container for providing your middleware. As such, Expressive also allows you to use service names for both pipeline and routed middleware. Generally, service names will be the specific middleware class names, but can be any valid string that resolves to a service. When Expressive is provided a service name for middleware, it internally decorates the middleware in a Zend\\Expressive\\Middleware\\LazyLoadingMiddleware instance, allowing it to be loaded only when dispatched.","title":"Service-based middleware"},{"location":"v3/features/middleware-types/#middleware-pipelines","text":"Expressive allows any pipeline or routed middleware to be self-contained middleware pipelines . To prevent the need for instantiating a Zend\\Stratigility\\MiddlewarePipe instance when defining the pipeline, Expressive allows you to provide an array of middleware: // Pipeline middleware: $app->pipe([ FirstMiddleware::class, SecondMiddleware::class, ]); // Routed middleware: $app->get('/foo', [ FirstMiddleware::class, SecondMiddleware::class, ]); The values in these arrays may be any valid middleware type as defined in this chapter.","title":"Middleware pipelines"},{"location":"v3/features/modular-applications/","text":"Modular applications Zend Framework 2+ applications have a concept of modules , independent units that can provide configuration, services, and hooks into its MVC lifecycle. This functionality is provided by zend-modulemanager. Expressive provides similar functionality by incorporating two packages within the default skeleton application: zendframework/zend-config-aggregator , which provides features for aggregating configuration from a variety of sources, including: PHP files globbed from the filesystem that return an array of configuration. zend-config -compatible configuration files globbed from the filesystem. Configuration provider classes; these are invokable classes which return an array of configuration. zendframework/zend-component-installer , a Composer plugin that looks for an extra.zf.config-provider entry in a package to install, and, if found, adds an entry for that provider to the config/config.php file (if it uses zend-config-aggregator). These features allow you to install packages via composer and expose their configuration \u2014 which may include dependency information \u2014 to your application. Making your application modular When using the Expressive installer via the skeleton application, the first question asked is the installation type, which includes the options: Minimal (no default middleware, templates, or assets; configuration only) Flat (flat source code structure; default selection) Modular (modular source code structure; recommended) We recommend choosing the \"Modular\" option from the outset. If you do not, you can still create and use modules in your application; however, the initial \"App\" module will not be modular. Module structure Expressive does not force you to use any particular structure for your module; its only requirement is to expose default configuration using a \"config provider\", which is simply an invokable class that returns a configuration array. We generally recommend that a module have a PSR-4 structure, and that the module contain a src/ directory at the minimum, along with directories for other module-specific content, such as templates, tests, and assets: src/ Acme/ src/ ConfigProvider.php Helper/ AuthorizationHelper.php Middleware/ VerifyUser.php VerifyUserFactory.php templates/ verify-user.php test/ Helper/ AuthorizationHelperTest.php Middleware/ VerifyUserTest.php If you use the above structure, you would then add an entry in your composer.json file to provide autoloading: \"autoload\": { \"psr-4\": { \"Acme\\\\\": \"src/Acme/src/\" } } Don't forget to execute composer dump-autoload after making the change! Creating and enabling a module The only requirement for creating a module is that you define a \"config provider\", which is simply an invokable class that returns a configuration array. Generally, a config provider will return dependency information, and module-specific configuration: namespace Acme; class ConfigProvider { public function __invoke() { return [ 'dependencies' => $this->getDependencies(), 'acme' => [ 'some-setting' => 'default value', ], 'templates' => [ 'paths' => [ 'acme' => [__DIR__ . '/../templates'], ], ] ]; } public function getDependencies() { return [ 'invokables' => [ Helper\\AuthorizationHelper::class => Helper\\AuthorizationHelper::class, ], 'factories' => [ Middleware\\VerifyUser::class => Container\\VerifyUserFactory::class, ], ]; } } You would then add the config provider to the top (or towards the top) of your config/config.php : $aggregator = new ConfigAggregator([ Acme\\ConfigProvider::class, /* ... */ This approach allows your config/autoload/* files to take precedence over the module configuration, allowing you to override the values. Caching configuration In order to provide configuration caching, two things must occur: First, you must define a config_cache_enabled key in your configuration somewhere. Second, you must pass a second argument to the ConfigManager , the location of the cache file to use. The config_cache_enabled key can be defined in any of your configuration providers, including the autoloaded configuration files. We recommend defining them in two locations: config/autoload/global.php should define the value to true , as the production setting. config/autoload/local.php should also define the setting, and use a value appropriate to the current environment. In development, for instance, this would be false . // config/autoload/global.php return [ 'config_cache_enabled' => true, /* ... */ ]; // config/autoload/local.php return [ 'config_cache_enabled' => false, // <- development! /* ... */ ]; You would then alter your config/config.php file to add the second argument. The following example builds on the previous, and demonstrates having the AppConfig entry enabled. The configuration will be cached to data/config-cache.php in the application root: $configManager = new ConfigManager([ App\\AppConfig::class, new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'), ], 'data/config-cache.php'); When the configuration cache path is present, if the config_cache_enabled flag is enabled, then configuration will be read from the cached configuration, instead of parsing and merging the various configuration sources. Tooling support The skeleton ships with zend-expressive-tooling by default, which allows you to execute the following command in order to create a module skeleton, add and enable autoloading rules for it, and register it with your application: $ composer expressive module:create {ModuleName} We recommend using this tool when creating new modules. Final notes This approach may look simple, but it is flexible and powerful: You pass a list of config providers to the ConfigAggregator constructor. Configuration is merged in the same order as it is passed, with later entries having precedence. You can override module configuration using *.global.php and *.local.php files. If cached config is found, ConfigAggregator does not iterate over provider list. For more details, please refer to the zend-config-aggregator documentation .","title":"Modular Applications"},{"location":"v3/features/modular-applications/#modular-applications","text":"Zend Framework 2+ applications have a concept of modules , independent units that can provide configuration, services, and hooks into its MVC lifecycle. This functionality is provided by zend-modulemanager. Expressive provides similar functionality by incorporating two packages within the default skeleton application: zendframework/zend-config-aggregator , which provides features for aggregating configuration from a variety of sources, including: PHP files globbed from the filesystem that return an array of configuration. zend-config -compatible configuration files globbed from the filesystem. Configuration provider classes; these are invokable classes which return an array of configuration. zendframework/zend-component-installer , a Composer plugin that looks for an extra.zf.config-provider entry in a package to install, and, if found, adds an entry for that provider to the config/config.php file (if it uses zend-config-aggregator). These features allow you to install packages via composer and expose their configuration \u2014 which may include dependency information \u2014 to your application.","title":"Modular applications"},{"location":"v3/features/modular-applications/#making-your-application-modular","text":"When using the Expressive installer via the skeleton application, the first question asked is the installation type, which includes the options: Minimal (no default middleware, templates, or assets; configuration only) Flat (flat source code structure; default selection) Modular (modular source code structure; recommended) We recommend choosing the \"Modular\" option from the outset. If you do not, you can still create and use modules in your application; however, the initial \"App\" module will not be modular.","title":"Making your application modular"},{"location":"v3/features/modular-applications/#module-structure","text":"Expressive does not force you to use any particular structure for your module; its only requirement is to expose default configuration using a \"config provider\", which is simply an invokable class that returns a configuration array. We generally recommend that a module have a PSR-4 structure, and that the module contain a src/ directory at the minimum, along with directories for other module-specific content, such as templates, tests, and assets: src/ Acme/ src/ ConfigProvider.php Helper/ AuthorizationHelper.php Middleware/ VerifyUser.php VerifyUserFactory.php templates/ verify-user.php test/ Helper/ AuthorizationHelperTest.php Middleware/ VerifyUserTest.php If you use the above structure, you would then add an entry in your composer.json file to provide autoloading: \"autoload\": { \"psr-4\": { \"Acme\\\\\": \"src/Acme/src/\" } } Don't forget to execute composer dump-autoload after making the change!","title":"Module structure"},{"location":"v3/features/modular-applications/#creating-and-enabling-a-module","text":"The only requirement for creating a module is that you define a \"config provider\", which is simply an invokable class that returns a configuration array. Generally, a config provider will return dependency information, and module-specific configuration: namespace Acme; class ConfigProvider { public function __invoke() { return [ 'dependencies' => $this->getDependencies(), 'acme' => [ 'some-setting' => 'default value', ], 'templates' => [ 'paths' => [ 'acme' => [__DIR__ . '/../templates'], ], ] ]; } public function getDependencies() { return [ 'invokables' => [ Helper\\AuthorizationHelper::class => Helper\\AuthorizationHelper::class, ], 'factories' => [ Middleware\\VerifyUser::class => Container\\VerifyUserFactory::class, ], ]; } } You would then add the config provider to the top (or towards the top) of your config/config.php : $aggregator = new ConfigAggregator([ Acme\\ConfigProvider::class, /* ... */ This approach allows your config/autoload/* files to take precedence over the module configuration, allowing you to override the values.","title":"Creating and enabling a module"},{"location":"v3/features/modular-applications/#caching-configuration","text":"In order to provide configuration caching, two things must occur: First, you must define a config_cache_enabled key in your configuration somewhere. Second, you must pass a second argument to the ConfigManager , the location of the cache file to use. The config_cache_enabled key can be defined in any of your configuration providers, including the autoloaded configuration files. We recommend defining them in two locations: config/autoload/global.php should define the value to true , as the production setting. config/autoload/local.php should also define the setting, and use a value appropriate to the current environment. In development, for instance, this would be false . // config/autoload/global.php return [ 'config_cache_enabled' => true, /* ... */ ]; // config/autoload/local.php return [ 'config_cache_enabled' => false, // <- development! /* ... */ ]; You would then alter your config/config.php file to add the second argument. The following example builds on the previous, and demonstrates having the AppConfig entry enabled. The configuration will be cached to data/config-cache.php in the application root: $configManager = new ConfigManager([ App\\AppConfig::class, new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'), ], 'data/config-cache.php'); When the configuration cache path is present, if the config_cache_enabled flag is enabled, then configuration will be read from the cached configuration, instead of parsing and merging the various configuration sources.","title":"Caching configuration"},{"location":"v3/features/modular-applications/#tooling-support","text":"The skeleton ships with zend-expressive-tooling by default, which allows you to execute the following command in order to create a module skeleton, add and enable autoloading rules for it, and register it with your application: $ composer expressive module:create {ModuleName} We recommend using this tool when creating new modules.","title":"Tooling support"},{"location":"v3/features/modular-applications/#final-notes","text":"This approach may look simple, but it is flexible and powerful: You pass a list of config providers to the ConfigAggregator constructor. Configuration is merged in the same order as it is passed, with later entries having precedence. You can override module configuration using *.global.php and *.local.php files. If cached config is found, ConfigAggregator does not iterate over provider list. For more details, please refer to the zend-config-aggregator documentation .","title":"Final notes"},{"location":"v3/features/container/aura-di/","text":"Using Aura.Di Aura.Di provides a serializable dependency injection container with the following features: constructor and setter injection. inheritance of constructor parameter and setter method values from parent classes. inheritance of setter method values from interfaces and traits. lazy-loaded instances, services, includes/requires, and values. instance factories. optional auto-resolution of typehinted constructor parameter values. Installing Aura.Di Aura.Di implements PSR-11 as of version 3. To use Aura.Di as a dependency injection container, we recommend using zendframework/zend-auradi-config , which helps you to configure its container. First, install the package: $ composer require zendframework/zend-auradi-config Configuration To configure Aura.Di, create the file config/container.php with the following contents: <?php use Zend\\AuraDi\\Config\\Config; use Zend\\AuraDi\\Config\\ContainerFactory; $config = require __DIR__ . '/config.php'; $factory = new ContainerFactory(); return $factory(new Config($config)); Your bootstrap (typically public/index.php ) will then look like this: chdir(dirname(__DIR__)); require 'vendor/autoload.php'; $container = require 'config/container.php'; $app = $container->get(Zend\\Expressive\\Application::class); require 'config/pipeline.php'; require 'config/routes.php'; $app->run(); For more information, please see the zend-auradi-config documentation","title":"Using Aura.Di"},{"location":"v3/features/container/aura-di/#using-auradi","text":"Aura.Di provides a serializable dependency injection container with the following features: constructor and setter injection. inheritance of constructor parameter and setter method values from parent classes. inheritance of setter method values from interfaces and traits. lazy-loaded instances, services, includes/requires, and values. instance factories. optional auto-resolution of typehinted constructor parameter values.","title":"Using Aura.Di"},{"location":"v3/features/container/aura-di/#installing-auradi","text":"Aura.Di implements PSR-11 as of version 3. To use Aura.Di as a dependency injection container, we recommend using zendframework/zend-auradi-config , which helps you to configure its container. First, install the package: $ composer require zendframework/zend-auradi-config","title":"Installing Aura.Di"},{"location":"v3/features/container/aura-di/#configuration","text":"To configure Aura.Di, create the file config/container.php with the following contents: <?php use Zend\\AuraDi\\Config\\Config; use Zend\\AuraDi\\Config\\ContainerFactory; $config = require __DIR__ . '/config.php'; $factory = new ContainerFactory(); return $factory(new Config($config)); Your bootstrap (typically public/index.php ) will then look like this: chdir(dirname(__DIR__)); require 'vendor/autoload.php'; $container = require 'config/container.php'; $app = $container->get(Zend\\Expressive\\Application::class); require 'config/pipeline.php'; require 'config/routes.php'; $app->run(); For more information, please see the zend-auradi-config documentation","title":"Configuration"},{"location":"v3/features/container/config/","text":"Container configuration This chapter is primarily written for container providers, so that they know what configuration features must be compatible, and what compatibility ultimately means within the project. PSR-11 defines an interface for dependency injection containers, and that interface is geared towards consumption of the container \u2014 not population of it. Expressive consumes a PSR-11 container, but also provides configuration for a container: it defines what services it needs, and how to create them. As such, any container consumed by Expressive must also understand its configuration format, and deliver consistent understanding of that format when providing services based on it. This document describes the configuration format, and details expectations for implementations. The format Container configuration is provided within the dependencies key of configuration. That key is structured as follows: return [ 'dependencies' => [ 'services' => [ // name => instance pairs 'config' => $config, ], 'aliases' => [ // alias => target pairs 'page-handler' => SomePageHandler::class, ], 'factories' => [ // service => factory pairs SomePageHandler::class => SomePageHandlerFactory::class, ], 'invokables' => [ // service => instantiable class pairs SomeInstantiableClass::class => SomeInstantiableClass::class, 'an-alias-for' => SomeInstantiableClass::class, ], 'delegators' => [ // service => array of delegator factory pairs SomeInstantiableClass::class => [ InjectListenersDelegator::class, InjectLoggerDelegator::class, ], ], ], ]; Services Services are actual instances you want to retrieve later from the container. These are generally provided at initial creation; the config service is populated in this way. When retrieving a service mapped in this way, you will always receive the initial instance. Aliases Aliases map a service alias to another service, and are provided as key/value pairs. As an example: 'aliases' => [ 'Zend\\Expressive\\Delegate\\DefaultDelegate' => \\Zend\\Expressive\\Handler\\NotFoundHandler::class, ], In this case, if the service named \"Zend\\Expressive\\Delegate\\DefaultDelegate\" is requested, the container should resolve that to the service Zend\\Expressive\\Handler\\NotFoundHandler and return that instead. Aliases may reference any other service defined in the container. These include services defined under the keys: services factories invokables or even other aliases When returning an aliased service, the container MUST return the same instance as if the target service were retrieved. When aliases may reference other aliases, the rule applies to the final resolved service, and not any intermediary aliases. Factories Factories map a service name to the factory capable of producing the instance. A factory is any PHP callable capable of producing the instance: Function names Closures Class instances that define the method __invoke() Callable references to static methods Array callables referencing static or instance methods They may also be the class name of a directly instantiable class (no constructor arguments) that defines __invoke() . Generally, this latter convention is used, as class names are serializable, while closures, objects, and array callables often are not. Factories are guaranteed to receive the PSR-11 container as an argument, allowing you to pull other services from the container as necessary to fulfill dependencies of the class being created and returned. Additionally, containers SHOULD pass the service name requested as the second argument; factories can determine whether that argument is necessary. A typical factory will generally ignore the second argument: use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class SomePageHandlerFactory { public function __invoke(ContainerInterface $container) { return new SomePageHandler( $container->get(TemplateRendererInterface::class) ); } } You can, however, re-use a factory for multiple services by accepting the second argument and varying creation based on it: use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class PageFactory { public function __invoke(ContainerInterface $container, string $serviceName) { $name = strtolower($serviceName); return new PageHandler( $container->get(TemplateRendererInterface::class), $name ); }; } The above could be mapped for several services: return [ 'dependencies' => [ 'factories' => [ 'hello-world' => PageFactory::class, 'about' => PageFactory::class, ], ], ]; In general, services should be cached by the container after initial creation; factories should only be called once for any given service name. Invokables Invokables refer to any class that may be instantiated without any constructor arguments. In other words, one should be able to create an instance solely be calling new $className() . Configuration for invokables looks verbose; it's a map of the service name to the class name to instantiate, and, generally, these are the same values. However, you can also provide a different service name. In those situations, containers MUST treat the service name as an alias to the final class name, and allow retrieving the service by EITHER the alias OR the class name. As an example, given the following configuration: 'dependencies' => [ 'invokables' => [ 'HelloWorld' => PageAction::class, ], ], the container should allow retrieval of both the services \"HelloWorld\" as well as the \"PageAction\" class. Delegator Factories Delegator factories are factories that may be used to decorate or manipulate a service before returning it from the container. They are covered in detail in another chapter , and delegator factories have the following signature: use Psr\\Container\\ContainerInterface; function ( ContainerInterface $container, string $serviceName, callable $callback ) Configuration for delegator factories is using the \"delegators\" sub-key of the \"dependencies\" configuration. Each entry is a service name pointing to an array of delegator factories. Delegator factories are called in the order they appear in configuration. For the first delegator factory, the $callback argument will be essentially the return value of $container->get() for the given service if there were no delegator factories attached to it ; in other words, it would be the invokable or service returned by a factory , after alias resolution. Delegators DO NOT operate on items in the services configuration! All items in the services configuration are considered complete, and will always be served as-is. Each delegator then returns a value, and that value will be what $callback returns for the next delegator. If the delegator is the last in the list, then what it returns becomes the final value for the service in the container; subsequent calls to $container->get() for that service will return that value. Delegators MUST return a value! For container implementors, delegators MUST only be called when initially creating the service, and not each time a service is retrieved. Common use cases for delegators include: Decorating an instance so that it may be used in another context (e.g., decorating a PHP callable to be used as PSR-15 middleware). Injecting collaborators (e.g., adding listeners to the ErrorHandler ). Conditionally replacing an instance based on configuration (e.g., swapping debug-enabled middleware for production middleware). Other capabilities Selection of a dependency injection container should be based on capabilities that implementation provides. This may be performance, or it may be additional features beyond those specified here. We encourage application developers to make full use of the container they select. The only caveat is that the above features MUST be supported by implementations for compatibility purposes, and the above are the only features package providers may count on when providing container configuration. Examples of how the above capabilities may be implemented include: zendframework/zend-auradi-config zendframework/zend-pimple-config jsoumelidis/zend-sf-di-config","title":"Container configuration"},{"location":"v3/features/container/config/#container-configuration","text":"This chapter is primarily written for container providers, so that they know what configuration features must be compatible, and what compatibility ultimately means within the project. PSR-11 defines an interface for dependency injection containers, and that interface is geared towards consumption of the container \u2014 not population of it. Expressive consumes a PSR-11 container, but also provides configuration for a container: it defines what services it needs, and how to create them. As such, any container consumed by Expressive must also understand its configuration format, and deliver consistent understanding of that format when providing services based on it. This document describes the configuration format, and details expectations for implementations.","title":"Container configuration"},{"location":"v3/features/container/config/#the-format","text":"Container configuration is provided within the dependencies key of configuration. That key is structured as follows: return [ 'dependencies' => [ 'services' => [ // name => instance pairs 'config' => $config, ], 'aliases' => [ // alias => target pairs 'page-handler' => SomePageHandler::class, ], 'factories' => [ // service => factory pairs SomePageHandler::class => SomePageHandlerFactory::class, ], 'invokables' => [ // service => instantiable class pairs SomeInstantiableClass::class => SomeInstantiableClass::class, 'an-alias-for' => SomeInstantiableClass::class, ], 'delegators' => [ // service => array of delegator factory pairs SomeInstantiableClass::class => [ InjectListenersDelegator::class, InjectLoggerDelegator::class, ], ], ], ];","title":"The format"},{"location":"v3/features/container/config/#services","text":"Services are actual instances you want to retrieve later from the container. These are generally provided at initial creation; the config service is populated in this way. When retrieving a service mapped in this way, you will always receive the initial instance.","title":"Services"},{"location":"v3/features/container/config/#aliases","text":"Aliases map a service alias to another service, and are provided as key/value pairs. As an example: 'aliases' => [ 'Zend\\Expressive\\Delegate\\DefaultDelegate' => \\Zend\\Expressive\\Handler\\NotFoundHandler::class, ], In this case, if the service named \"Zend\\Expressive\\Delegate\\DefaultDelegate\" is requested, the container should resolve that to the service Zend\\Expressive\\Handler\\NotFoundHandler and return that instead. Aliases may reference any other service defined in the container. These include services defined under the keys: services factories invokables or even other aliases When returning an aliased service, the container MUST return the same instance as if the target service were retrieved. When aliases may reference other aliases, the rule applies to the final resolved service, and not any intermediary aliases.","title":"Aliases"},{"location":"v3/features/container/config/#factories","text":"Factories map a service name to the factory capable of producing the instance. A factory is any PHP callable capable of producing the instance: Function names Closures Class instances that define the method __invoke() Callable references to static methods Array callables referencing static or instance methods They may also be the class name of a directly instantiable class (no constructor arguments) that defines __invoke() . Generally, this latter convention is used, as class names are serializable, while closures, objects, and array callables often are not. Factories are guaranteed to receive the PSR-11 container as an argument, allowing you to pull other services from the container as necessary to fulfill dependencies of the class being created and returned. Additionally, containers SHOULD pass the service name requested as the second argument; factories can determine whether that argument is necessary. A typical factory will generally ignore the second argument: use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class SomePageHandlerFactory { public function __invoke(ContainerInterface $container) { return new SomePageHandler( $container->get(TemplateRendererInterface::class) ); } } You can, however, re-use a factory for multiple services by accepting the second argument and varying creation based on it: use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class PageFactory { public function __invoke(ContainerInterface $container, string $serviceName) { $name = strtolower($serviceName); return new PageHandler( $container->get(TemplateRendererInterface::class), $name ); }; } The above could be mapped for several services: return [ 'dependencies' => [ 'factories' => [ 'hello-world' => PageFactory::class, 'about' => PageFactory::class, ], ], ]; In general, services should be cached by the container after initial creation; factories should only be called once for any given service name.","title":"Factories"},{"location":"v3/features/container/config/#invokables","text":"Invokables refer to any class that may be instantiated without any constructor arguments. In other words, one should be able to create an instance solely be calling new $className() . Configuration for invokables looks verbose; it's a map of the service name to the class name to instantiate, and, generally, these are the same values. However, you can also provide a different service name. In those situations, containers MUST treat the service name as an alias to the final class name, and allow retrieving the service by EITHER the alias OR the class name. As an example, given the following configuration: 'dependencies' => [ 'invokables' => [ 'HelloWorld' => PageAction::class, ], ], the container should allow retrieval of both the services \"HelloWorld\" as well as the \"PageAction\" class.","title":"Invokables"},{"location":"v3/features/container/config/#delegator-factories","text":"Delegator factories are factories that may be used to decorate or manipulate a service before returning it from the container. They are covered in detail in another chapter , and delegator factories have the following signature: use Psr\\Container\\ContainerInterface; function ( ContainerInterface $container, string $serviceName, callable $callback ) Configuration for delegator factories is using the \"delegators\" sub-key of the \"dependencies\" configuration. Each entry is a service name pointing to an array of delegator factories. Delegator factories are called in the order they appear in configuration. For the first delegator factory, the $callback argument will be essentially the return value of $container->get() for the given service if there were no delegator factories attached to it ; in other words, it would be the invokable or service returned by a factory , after alias resolution. Delegators DO NOT operate on items in the services configuration! All items in the services configuration are considered complete, and will always be served as-is. Each delegator then returns a value, and that value will be what $callback returns for the next delegator. If the delegator is the last in the list, then what it returns becomes the final value for the service in the container; subsequent calls to $container->get() for that service will return that value. Delegators MUST return a value! For container implementors, delegators MUST only be called when initially creating the service, and not each time a service is retrieved. Common use cases for delegators include: Decorating an instance so that it may be used in another context (e.g., decorating a PHP callable to be used as PSR-15 middleware). Injecting collaborators (e.g., adding listeners to the ErrorHandler ). Conditionally replacing an instance based on configuration (e.g., swapping debug-enabled middleware for production middleware).","title":"Delegator Factories"},{"location":"v3/features/container/config/#other-capabilities","text":"Selection of a dependency injection container should be based on capabilities that implementation provides. This may be performance, or it may be additional features beyond those specified here. We encourage application developers to make full use of the container they select. The only caveat is that the above features MUST be supported by implementations for compatibility purposes, and the above are the only features package providers may count on when providing container configuration. Examples of how the above capabilities may be implemented include: zendframework/zend-auradi-config zendframework/zend-pimple-config jsoumelidis/zend-sf-di-config","title":"Other capabilities"},{"location":"v3/features/container/delegator-factories/","text":"Delegator Factories Expressive supports the concept of delegator factories , which allow decoration of services created by your dependency injection container, across all dependency injection containers supported by Expressive. Delegator factories accept the following arguments: The container itself; The name of the service whose creation is being decorated; A callback that will produce the service being decorated. As an example, let's say we have a UserRepository class that composes some sort of event manager. We might want to attach listeners to that event manager, but not wish to alter the basic creation logic for the repository itself. As such, we might write a delegator factory as follows: namespace Acme; use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; class UserRepositoryListenerDelegatorFactory { public function __invoke(ContainerInterface $container, string $name, callable $callback) : UserRepository { $listener = new LoggerListener($container->get(LoggerInterface::class)); $repository = $callback(); $repository->getEventManager()->attach($listener); return $repository; } } To notify the container about this delegator factory, we would add the following configuration to our application: 'dependencies' => [ 'delegators' => [ Acme\\UserRepository::class => [ Acme\\UserRepositoryListenerDelegatorFactory::class, ], ], ], Note that you specify delegator factories using the service name being decorated as the key, with an array of delegator factories as a value. You may attach multiple delegator factories to any given service , which can be a very powerful feature. At the time of writing, this feature works for each of the Aura.Di, Pimple, and zend-servicemanager container implementations.","title":"Delegator Factories"},{"location":"v3/features/container/delegator-factories/#delegator-factories","text":"Expressive supports the concept of delegator factories , which allow decoration of services created by your dependency injection container, across all dependency injection containers supported by Expressive. Delegator factories accept the following arguments: The container itself; The name of the service whose creation is being decorated; A callback that will produce the service being decorated. As an example, let's say we have a UserRepository class that composes some sort of event manager. We might want to attach listeners to that event manager, but not wish to alter the basic creation logic for the repository itself. As such, we might write a delegator factory as follows: namespace Acme; use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; class UserRepositoryListenerDelegatorFactory { public function __invoke(ContainerInterface $container, string $name, callable $callback) : UserRepository { $listener = new LoggerListener($container->get(LoggerInterface::class)); $repository = $callback(); $repository->getEventManager()->attach($listener); return $repository; } } To notify the container about this delegator factory, we would add the following configuration to our application: 'dependencies' => [ 'delegators' => [ Acme\\UserRepository::class => [ Acme\\UserRepositoryListenerDelegatorFactory::class, ], ], ], Note that you specify delegator factories using the service name being decorated as the key, with an array of delegator factories as a value. You may attach multiple delegator factories to any given service , which can be a very powerful feature. At the time of writing, this feature works for each of the Aura.Di, Pimple, and zend-servicemanager container implementations.","title":"Delegator Factories"},{"location":"v3/features/container/factories/","text":"Provided Factories Expressive provides several factories compatible with PSR-11 Container to facilitate setting up common dependencies. The following is a list of provided factories, what they will create, the suggested service name, and any additional dependencies they may require. zend-expressive The zend-expressive package ships Zend\\Expressive\\ConfigProvider , which defines configuration that references each of these factories, using the suggested names; this provider is registered by default when using the skeleton application. All factories, unless noted otherwise, are in the Zend\\Expressive\\Container namespace, and define an __invoke() method that accepts an Psr\\Container\\ContainerInterface instance as the sole argument. ApplicationFactory Provides : Zend\\Expressive\\Application Suggested Name : Zend\\Expressive\\Application Requires : Zend\\Expressive\\MiddlewareFactory Zend\\Expressive\\ApplicationPipeline , which should resolve to a Zend\\Stratigility\\MiddlewarePipe instance. Zend\\Expressive\\Router\\RouteCollector Zend\\HttpHandlerRunner\\RequestHandlerRunner Optional : no optional services are used. ApplicationPipelineFactory Provides : a Zend\\Stratigility\\MiddlewarePipe for use with the Application instance. Suggested Name : Zend\\Expressive\\ApplicationPipeline Requires : no additional services are required. Optional : no optional services are used. EmitterFactory Provides : Zend\\HttpHandlerRunner\\Emitter\\EmitterInterface Suggested Name : Zend\\HttpHandlerRunner\\Emitter\\EmitterInterface Requires : no additional services are required. Optional : no optional services are used. This factory creates an instance of Zend\\HttpHandlerRunner\\Emitter\\EmitterStack , pushing a Zend\\HttpHandlerRunner\\Emitter\\SapiEmitter to it. ErrorHandlerFactory Provides : Zend\\Stratigility\\Middleware\\ErrorHandler Suggested Name : Zend\\Stratigility\\Middleware\\ErrorHandler Requires : Psr\\Http\\Message\\ResponseInterface , which should resolve to a callable capable of producing a ResponseInterface instance (and not directly to an instance itself) Optional : Zend\\Expressive\\Middleware\\ErrorResponseGenerator . If not provided, the error handler will not compose an error response generator, making it largely useless other than to provide an empty response. ErrorResponseGeneratorFactory Provides : Zend\\Expressive\\Middleware\\ErrorResponseGenerator Suggested Name : Zend\\Expressive\\Middleware\\ErrorResponseGenerator Requires : no additional services are required. Optional : config , an array or ArrayAccess instance. This will be used to seed the ErrorResponseGenerator instance with a template name to use for errors (see more below), and/or a \"debug\" flag value. Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the error response generator will provide a plain text response instead of a templated one. When the config service is present, the factory can utilize two values: debug , a flag indicating whether or not to provide debug information when creating an error response. zend-expressive.error_handler.template_error , a name of an alternate template to use (instead of the default represented in the Zend\\Expressive\\Middleware\\ErrorResponseGenerator::TEMPLATE_DEFAULT constant, which evaluates to error::error ). Since 3.1.0 : zend-expressive.error_handler.layout , a name of an alternate layout to use (instead of the default represented in the Zend\\Expressive\\Middleware\\ErrorResponseGenerator::LAYOUT_DEFAULT constant, which evaluates to layout::default ). As an example: 'debug' => true, 'zend-expressive' => [ 'error_handler' => [ 'template_error' => 'name of error template', 'layout' => 'layout::alternate', ], ], MiddlewareContainerFactory Provides : a Zend\\Expressive\\MiddlewareContainer Suggested Name : Zend\\Expressive\\MiddlewareContainer Requires : no additional services are required. Optional : no optional services are used. This factory returns an instance of Zend\\Expressive\\MiddlewareContainer injected with the container instance itself. The MiddlewareContainer is a PSR-11 container itself, but ensures that instances pulled are PSR-15 MiddlewareInterface instances: It decorates PSR-15 RequestHandlerInterface instances using Zend\\Stratigility\\RequestHandlerMiddleware . If a requested service is not in the underlying PSR-11 container, but the class exists, it will attempt to instantiate it directly. Any service retrieved that is not a MiddlewareInterface instance will result in an exception, ensuring that nothing invalid is piped or routed. MiddlewareFactoryFactory Provides : a Zend\\Expressive\\MiddlewareFactory Suggested Name : Zend\\Expressive\\MiddlewareFactory Requires : Zend\\Expressive\\MiddlewareContainer Optional : no optional services are used. The MiddlewareFactory is used by Zend\\Expressive\\Application to prepare $middleware arguments to pipe() , route() , et al, ensuring they are MiddlewareInterface implementations. It handles the following types: MiddlewareInterface types are considered valid always. RequestHandlerInterface types are decorated using Zend\\Stratigility\\Middleware\\RequestHandlerMiddleware . callable types are decorated using Zend\\Stratigility\\middleware() . string types are decorated using a Zend\\Expressive\\Middleware\\LazyLoadingMiddleware instance (which will also receive the MiddlewareContainer. ) Or an array of any of the above types. NotFoundHandlerFactory Provides : Zend\\Expressive\\Handler\\NotFoundHandler Suggested Name : Zend\\Expressive\\Handler\\NotFoundHandler Requires : Psr\\Http\\Message\\ResponseInterface , which should resolve to a callable capable of producing a ResponseInterface instance (and not directly to an instance itself) Optional : config , an array or ArrayAccess instance. This will be used to seed the NotFoundHandler instance with a template name to use. Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the handler will provide a plain text response instead of a templated one. When the config service is present, the factory can utilize two values: zend-expressive.error_handler.template_404 , a name of an alternate template to use (instead of the default represented in the Zend\\Expressive\\Delegate\\NotFoundDelegate::TEMPLATE_DEFAULT constant, which evaluates to error::404 ). zend-expressive.error_handler.layout , a name of an alternate template to use (instead of the default represented in the Zend\\Expressive\\Delegate\\NotFoundDelegate::TEMPLATE_DEFAULT constant, which evaluates to layout::default ). As an example: 'zend-expressive' => [ 'error_handler' => [ 'template_404' => 'name of 404 template', 'layout' => 'layout::alternate', ], ], RequestHandlerRunnerFactory Provides : Zend\\HttpHandler\\RequestHandlerRunner Suggested Name : Zend\\HttpHandler\\RequestHandlerRunner Requires : Zend\\Expressive\\ApplicationPipeline , which should resolve to the Zend\\Stratigility\\MiddlewarePipe instance the Application will use. Zend\\HttpHandlerRunner\\Emitter\\EmitterInterface Psr\\Http\\Message\\ServerRequestInterface , which should resolve to a callable capable of producing a ServerRequestInterface instance (and not directly to an instance itself) Zend\\Expressive\\Response\\ServerRequestErrorResponseGenerator Optional : no optional services are used. This factory generates the RequestHandlerRunner instance used by the Application instance to \"run\" the application. It marshals a request instance, passes it to the application pipeline to handle, and emits the returned response. If an error occurs during request generation, it uses the ServerRequestErrorResponseGenerator to generate the response to emit. ResponseFactoryFactory Provides : a PHP callable capable of producing Psr\\Http\\Message\\ResponseInterface instances. Suggested Name : Psr\\Http\\Message\\ResponseInterface Requires : no additional services are required. Optional : no optional services are used. By default, this uses zend-diactoros to produce a response, and will raise an exception if that package is not installed. You can provide an alternate factory if you want to use an alternate PSR-7 implementation. ServerRequestErrorResponseGeneratorFactory Provides : Zend\\Expressive\\Response\\ServerRequestErrorResponseGenerator Suggested Name : Zend\\Expressive\\Response\\ServerRequestErrorResponseGenerator Requires : Psr\\Http\\Message\\ResponseInterface , which should resolve to a callable capable of producing a ResponseInterface instance (and not directly to an instance itself) Optional : config , an array or ArrayAccess instance. This will be used to seed the ErrorResponseGenerator instance with a template name to use for errors (see more below), and/or a \"debug\" flag value. Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the error response generator will provide a plain text response instead of a templated one. When the config service is present, the factory can utilize two values: debug , a flag indicating whether or not to provide debug information when creating an error response. zend-expressive.error_handler.template_error , a name of an alternate template to use (instead of the default represented in the Zend\\Expressive\\Middleware\\ErrorResponseGenerator::TEMPLATE_DEFAULT constant). As an example: 'debug' => true, 'zend-expressive' => [ 'error_handler' => [ 'template_error' => 'name of error template', ], ], ServerRequestFactoryFactory Provides : a PHP callable capable of producing Psr\\Http\\Message\\ServerRequestInterface instances. Suggested Name : Psr\\Http\\Message\\ServerRequestInterface Requires : no additional services are required. Optional : no optional services are used. By default, this uses zend-diactoros to produce a request, and will raise an exception if that package is not installed. You can provide an alternate factory if you want to use an alternate PSR-7 implementation. StreamFactoryFactory Provides : a PHP callable capable of producing Psr\\Http\\Message\\StreamInterface instances. Suggested Name : Psr\\Http\\Message\\StreamInterface Requires : no additional services are required. Optional : no optional services are used. By default, this uses zend-diactoros to produce a stream, and will raise an exception if that package is not installed. You can provide an alternate factory if you want to use an alternate PSR-7 implementation. WhoopsErrorResponseGeneratorFactory Provides : Zend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator Suggested Name : Zend\\Expressive\\Middleware\\ErrorResponseGenerator Requires : Zend\\Expressive\\Whoops (see WhoopsFactory , below) WhoopsFactory Provides : Whoops\\Run Suggested Name : Zend\\Expressive\\Whoops Requires : Zend\\Expressive\\WhoopsPageHandler Optional : config , an array or ArrayAccess instance. This will be used to seed additional page handlers, specifically the JsonResponseHandler (see more below). This factory creates and configures a Whoops\\Run instance so that it will work properly with Zend\\Expressive\\Application ; this includes disabling immediate write-to-output, disabling immediate quit, etc. The PrettyPageHandler returned for the Zend\\Expressive\\WhoopsPageHandler service will be injected. It consumes the following config structure: 'whoops' => [ 'json_exceptions' => [ 'display' => true, 'show_trace' => true, 'ajax_only' => true, ], ], If no whoops top-level key is present in the configuration, a default instance with no JsonResponseHandler composed will be created. WhoopsPageHandlerFactory Provides : Whoops\\Handler\\PrettyPageHandler Suggested Name : Zend\\Expressive\\WhoopsPageHandler Optional : config , an array or ArrayAccess instance. This will be used to further configure the PrettyPageHandler instance, specifically with editor configuration (for linking files such that they open in the configured editor). It consumes the following config structure: 'whoops' => [ 'editor' => 'editor name, editor service name, or callable', ], The editor value must be a known editor name (see the Whoops documentation for pre-configured editor types), a callable, or a service name to use. zend-expressive-router The zend-expressive-router package ships Zend\\Expressive\\Router\\ConfigProvider , which defines configuration that references each of these factories, using the suggested names; this provider is registered by default when using the skeleton application. Individual router implementation packages are expected to provide the Zend\\Expressive\\Router\\RouterInterface service. All factories listed below are under the Zend\\Expressive\\Router\\Middleware namespace (unless otherwise specified), and define an __invoke() method that accepts a Psr\\Container\\ContainerInterface instance as the sole argument. DispatchMiddlewareFactory Provides : Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware Suggested Name : Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware Requires : no additional services are required. Optional : no optional services are used. ImplicitHeadMiddlewareFactory Provides : Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware Suggested Name : Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware Requires : Zend\\Expressive\\Router\\RouterInterface Psr\\Http\\Message\\StreamInterface , which should resolve to a callable capable of producing a StreamInterface instance (and not directly to an instance itself) Optional : no optional services are used. ImplicitOptionsMiddlewareFactory Provides : Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware Suggested Name : Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware Requires : Psr\\Http\\Message\\ResponseInterface , which should resolve to a callable capable of producing a ResponseInterface instance (and not directly to an instance itself) Optional : no optional services are used. MethodNotAllowedMiddlewareFactory Provides : Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware Suggested Name : Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware Requires : Psr\\Http\\Message\\ResponseInterface , which should resolve to a callable capable of producing a ResponseInterface instance (and not directly to an instance itself) Optional : no optional services are used. RouteCollectorFactory Provides : Zend\\Expressive\\Router\\RouteCollector Suggested Name : Zend\\Expressive\\Router\\RouteCollector Requires : Zend\\Expressive\\Router\\RouterInterface Optional : no optional services are used. RouteMiddlewareFactory Provides : Zend\\Expressive\\Router\\Middleware\\RouteMiddleware Suggested Name : Zend\\Expressive\\Router\\Middleware\\RouteMiddleware Requires : Zend\\Expressive\\Router\\RouterInterface Optional : no optional services are used. Factories provided by template engine packages The following factories are provided by individual template engine packages. Generally speaking, these will be provided to your container configuration during installation. PlatesRendererFactory Provides : Zend\\Expressive\\Plates\\PlatesRenderer FactoryName : Zend\\Expressive\\Plates\\PlatesRendererFactory Suggested Name : Zend\\Expressive\\Template\\TemplateRendererInterface Requires : no additional services are required. Optional : config , an array or ArrayAccess instance. This will be used to further configure the Plates instance, specifically with the filename extension to use, and paths to inject. It consumes the following config structure: 'templates' => [ 'extension' => 'file extension used by templates; defaults to html', 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ] One note: Due to a limitation in the Plates engine, you can only map one path per namespace when using Plates. TwigRendererFactory Provides : Zend\\Expressive\\Twig\\TwigRenderer FactoryName : Zend\\Expressive\\Twig\\TwigRendererFactory Suggested Name : Zend\\Expressive\\Template\\TemplateRendererInterface Requires : no additional services are required. Optional : Zend\\Expressive\\Router\\RouterInterface ; if found, it will be used to seed a Zend\\Expressive\\Twig\\TwigExtension instance for purposes of rendering application URLs. config , an array or ArrayAccess instance. This will be used to further configure the Twig instance, specifically with the filename extension, paths to assets (and default asset version to use), and template paths to inject. It consumes the following config structure: 'debug' => boolean, 'templates' => [ 'cache_dir' => 'path to cached templates', 'assets_url' => 'base URL for assets', 'assets_version' => 'base version for assets', 'extension' => 'file extension used by templates; defaults to html.twig', 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ] When debug is true, it disables caching, enables debug mode, enables strict variables, and enables auto reloading. The assets_* values are used to seed the TwigExtension instance (assuming the router was found). ZendViewRendererFactory Provides : Zend\\Expressive\\ZendView\\ZendViewRenderer FactoryName : Zend\\Expressive\\ZendView\\ZendViewRendererFactory Suggested Name : Zend\\Expressive\\Template\\TemplateRendererInterface Requires : no additional services are required. Optional : config , an array or ArrayAccess instance. This will be used to further configure the ZendView instance, specifically with the layout template name, entries for a TemplateMapResolver , and and template paths to inject. Zend\\View\\Renderer\\PhpRenderer , in order to allow providing custom extensions and/or re-using an existing configuration; otherwise, a default instance is created. Zend\\View\\HelperPluginManager ; if present, will be used to inject the PhpRenderer instance; otherwise, a default instance is created. Zend\\Expressive\\Helper\\UrlHelper , in order to provide a URL helper compatible with zend-expressive-router. If you will not be generating URLs, this can be omitted. Zend\\Expressive\\Helper\\ServerUrlHelper , in order to provide a server URL helper (which provides the scheme and authority for a generated URL) compatible with zend-expressive-router. If you will not be generating URLs, this can be omitted. It consumes the following config structure: 'templates' => [ 'layout' => 'name of layout view to use, if any', 'map' => [ // template => filename pairs ], 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ] When creating the PhpRenderer instance, it will inject it with a Zend\\View\\HelperPluginManager instance (either pulled from the container, or instantiated directly). It injects the helper plugin manager with custom url and serverurl helpers, Zend\\Expressive\\ZendView\\UrlHelper and Zend\\Expressive\\ZendView\\ServerUrlHelper , respectively.","title":"Container Factories"},{"location":"v3/features/container/factories/#provided-factories","text":"Expressive provides several factories compatible with PSR-11 Container to facilitate setting up common dependencies. The following is a list of provided factories, what they will create, the suggested service name, and any additional dependencies they may require.","title":"Provided Factories"},{"location":"v3/features/container/factories/#zend-expressive","text":"The zend-expressive package ships Zend\\Expressive\\ConfigProvider , which defines configuration that references each of these factories, using the suggested names; this provider is registered by default when using the skeleton application. All factories, unless noted otherwise, are in the Zend\\Expressive\\Container namespace, and define an __invoke() method that accepts an Psr\\Container\\ContainerInterface instance as the sole argument.","title":"zend-expressive"},{"location":"v3/features/container/factories/#zend-expressive-router","text":"The zend-expressive-router package ships Zend\\Expressive\\Router\\ConfigProvider , which defines configuration that references each of these factories, using the suggested names; this provider is registered by default when using the skeleton application. Individual router implementation packages are expected to provide the Zend\\Expressive\\Router\\RouterInterface service. All factories listed below are under the Zend\\Expressive\\Router\\Middleware namespace (unless otherwise specified), and define an __invoke() method that accepts a Psr\\Container\\ContainerInterface instance as the sole argument.","title":"zend-expressive-router"},{"location":"v3/features/container/factories/#factories-provided-by-template-engine-packages","text":"The following factories are provided by individual template engine packages. Generally speaking, these will be provided to your container configuration during installation.","title":"Factories provided by template engine packages"},{"location":"v3/features/container/intro/","text":"Containers Expressive promotes and advocates the usage of Dependency Injection / Inversion of Control (also referred to as DI \u2014 or DIC \u2014 and IoC, respectively) containers when writing your applications. These should be used for the following: Defining application dependencies: routers, template engines, error handlers, even the Application instance itself. Defining middleware and related dependencies. The application skeleton wires together dependency configuration, which is then used to create a container. This in turn is used to seed a Zend\\Expressive\\MiddlewareContainer for purposes of retrieving middleware for the Application instance (via another intermediary, Zend\\Expressive\\MiddlewareFactory ). When the application is ready to execute middleware or a handler, it will fetch it from the container. This approach encourages the idea of defining middleware-specific dependencies, and factories for ensuring they are injected. To facilitate this and allow you as a developer to choose the container you prefer, zend-expressive typehints against PSR-11 Container , and throughout this manual, we attempt to show using a variety of containers in examples. At this time, we document support for the following specific containers: zend-servicemanager pimple-interop aura.di Service Names We recommend using fully-qualified class names whenever possible as service names, with one exception: in cases where a service provides an implementation of an interface used for typehints, use the interface name. Following these practices encourages the following: Consumers have a reasonable idea of what the service should return. Using interface names as service names promotes re-use and substitution. In a few cases, we define \"virtual service\" names. These are cases where there is no clear typehint to follow. For example, we may want to imply specific configuration is necessary; Whoops requires specific configuration to work correctly with Expressive, and thus we do not want a generic service name for it. We try to keep these to a minimum, however.","title":"Introduction"},{"location":"v3/features/container/intro/#containers","text":"Expressive promotes and advocates the usage of Dependency Injection / Inversion of Control (also referred to as DI \u2014 or DIC \u2014 and IoC, respectively) containers when writing your applications. These should be used for the following: Defining application dependencies: routers, template engines, error handlers, even the Application instance itself. Defining middleware and related dependencies. The application skeleton wires together dependency configuration, which is then used to create a container. This in turn is used to seed a Zend\\Expressive\\MiddlewareContainer for purposes of retrieving middleware for the Application instance (via another intermediary, Zend\\Expressive\\MiddlewareFactory ). When the application is ready to execute middleware or a handler, it will fetch it from the container. This approach encourages the idea of defining middleware-specific dependencies, and factories for ensuring they are injected. To facilitate this and allow you as a developer to choose the container you prefer, zend-expressive typehints against PSR-11 Container , and throughout this manual, we attempt to show using a variety of containers in examples. At this time, we document support for the following specific containers: zend-servicemanager pimple-interop aura.di","title":"Containers"},{"location":"v3/features/container/middleware-container/","text":"The Middleware Container While the skeleton creates a general PSR-11 container in which to map all of your dependencies, this can pose problems when you are attempting to pull middleware and request handlers; you could potentially, accidentally, pull something of a different type entirely, which may not work in either context! To prevent this from happening, we provide Zend\\Expressive\\MiddlewareContainer . It decorates your application container, and adds the following behavior: has() will return true if a service does not exist in the container, but is a class that exists. get() : will instantiate a class directly if the service does not exist, but is a class that exists. decorate PSR-15 RequestHandlerInterface implementations using Zend\\Stratigiliity\\RequestHandlerMiddleware . raise an exception if the instance to return is not a PSR-15 MiddlewareInterface implementation. Internally, this class is used by the MiddlewareFactory and the Zend\\Expressive\\Middleware\\LazyLoadingMiddleware class; you should never need to interact with it directly, unless the above features are of interest to you.","title":"The Middleware Container"},{"location":"v3/features/container/middleware-container/#the-middleware-container","text":"While the skeleton creates a general PSR-11 container in which to map all of your dependencies, this can pose problems when you are attempting to pull middleware and request handlers; you could potentially, accidentally, pull something of a different type entirely, which may not work in either context! To prevent this from happening, we provide Zend\\Expressive\\MiddlewareContainer . It decorates your application container, and adds the following behavior: has() will return true if a service does not exist in the container, but is a class that exists. get() : will instantiate a class directly if the service does not exist, but is a class that exists. decorate PSR-15 RequestHandlerInterface implementations using Zend\\Stratigiliity\\RequestHandlerMiddleware . raise an exception if the instance to return is not a PSR-15 MiddlewareInterface implementation. Internally, this class is used by the MiddlewareFactory and the Zend\\Expressive\\Middleware\\LazyLoadingMiddleware class; you should never need to interact with it directly, unless the above features are of interest to you.","title":"The Middleware Container"},{"location":"v3/features/container/middleware-factory/","text":"The Middleware Factory With version 3, we made a conscious choice to use strong type-hinting wherever possible. However, we also recognize that doing so can sometimes be an inconvenience to the user and lead to an explosion in code verbosity. One area in particular that concerned us was the Application instance itself, and the various methods it exposes for piping and routing middleware. If we made each of these strictly typed, users would be forced to write code that looks like the following: use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\Middleware\\LazyLoadingMiddleware; use Zend\\Stratigility\\MiddlewarePipe; use function Zend\\Stratigility\\middleware; use function Zend\\Stratigility\\path; return function (Application $app, ContainerInterface $container) : void { $app->pipe(path( '/foo', new LazyLoadingMiddleware(App\\FooMiddleware::class, $container) )); $app->pipe(middleware(function ($request, $handler) { // ... })); $booksPipeline = new MiddlewarePipe(); $booksPipeline->pipe(new LazyLoadingMiddleware( Zend\\ProblemDetails\\ProblemDetailsMiddleware::class, $container )); $booksPipeline->pipe(new LazyLoadingMiddleware( App\\SessionMiddleware::class, $container )); $booksPipeline->pipe(new LazyLoadingMiddleware( App\\AuthenticationMiddleware::class, $container )); $booksPipeline->pipe(new LazyLoadingMiddleware( App\\AuthorizationMiddleware::class, $container )); $booksPipeline->pipe(new LazyLoadingMiddleware( Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware::class $container )); $booksPipeline->pipe(new LazyLoadingMiddleware( App\\ValidationMiddleware::class $container )); $booksPipeline->pipe(new LazyLoadingMiddleware( App\\Handler\\CreateBookHandler::class $container )); $app->post('/books/{id:\\d+}', $booksPipeline); }; Additionally, this would pose an enormous burden when migrating to version 3. For these reasons, we developed the class Zend\\Expressive\\MiddlewareFactory . It composes a MiddlewareContainer in order to back the following operations. callable $middleware = $factory->callable(function ($request, $handler) { }); This method takes a callable middleware, and decorates it as a Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator instance. handler $middleware = $factory->handler($requestHandler); This method takes a PSR-15 request handler instance and decorates it as a Zend\\Stratigility\\Middleware\\RequestHandlerMiddleware instance. lazy $middleware = $factory->lazy(App\\Middleware\\FooMiddleware::class); This method decorates the service name using Zend\\Expressive\\Middlware\\LazyLoadingMiddleware , passing the composed MiddlewareContainer to the instance during instantiation. pipeline $pipeline = $factory->pipeline( $middlewareInstance, 'MiddlewareServiceName', function ($request, $handler) { }, $requestHandlerInstance ); Creates and returns a Zend\\Stratigility\\MiddlewarePipe , after passing each argument to prepare() first. (You may pass an array of values instead of individual arguments as well.) prepare $middleware = $factory->prepare($middleware); Inspects the provided middleware argument, with the following behavior: MiddlewareInterface instances are returned verbatim. RequestHandlerInterface instances are decorated using handler() . callable arguments are decorated using callable() . string arguments are decorated using lazy() . array arguments are decorated using pipeline() . Usage in bootstrapping The skeleton defines two files config/pipeline.php and config/routes.php . These are expected to return a callable with the following signature: use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\MiddlewareFactory; return function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void { }; Note that the MiddlewareFactory is passed to these callables; this gives you the ability to use it for more complex piping and routing needs, including creating nested pipelines. As an example, we'll rewrite our initial example to use the MiddlewareFactory : use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\MiddlewareFactory; use function Zend\\Stratigility\\path; return function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void { $app->pipe(path('/foo', $factory->prepare(App\\FooMiddleware::class))); $app->pipe($factory->prepare(function ($request, $handler) { // ... })); $app->post('/books/{id:\\d+}', $factory->pipeline( ProblemDetailsMiddleware::class, App\\SessionMiddleware::class, App\\AuthenticationMiddleware::class, App\\AuthorizationMiddleware::class, Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware::class, App\\ValidationMiddleware::class, App\\Handler\\CreateBookHandler::class )); }; Further simplifications Internally, Application 's pipe() and various routing methods make use of the MiddlewareFactory already; pipe() also already makes use of path() as well. As such, usage of the MiddlewareFactory is not strictly necessary in the above example; it is used for illustrative purposes only.","title":"The Middleware Factory"},{"location":"v3/features/container/middleware-factory/#the-middleware-factory","text":"With version 3, we made a conscious choice to use strong type-hinting wherever possible. However, we also recognize that doing so can sometimes be an inconvenience to the user and lead to an explosion in code verbosity. One area in particular that concerned us was the Application instance itself, and the various methods it exposes for piping and routing middleware. If we made each of these strictly typed, users would be forced to write code that looks like the following: use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\Middleware\\LazyLoadingMiddleware; use Zend\\Stratigility\\MiddlewarePipe; use function Zend\\Stratigility\\middleware; use function Zend\\Stratigility\\path; return function (Application $app, ContainerInterface $container) : void { $app->pipe(path( '/foo', new LazyLoadingMiddleware(App\\FooMiddleware::class, $container) )); $app->pipe(middleware(function ($request, $handler) { // ... })); $booksPipeline = new MiddlewarePipe(); $booksPipeline->pipe(new LazyLoadingMiddleware( Zend\\ProblemDetails\\ProblemDetailsMiddleware::class, $container )); $booksPipeline->pipe(new LazyLoadingMiddleware( App\\SessionMiddleware::class, $container )); $booksPipeline->pipe(new LazyLoadingMiddleware( App\\AuthenticationMiddleware::class, $container )); $booksPipeline->pipe(new LazyLoadingMiddleware( App\\AuthorizationMiddleware::class, $container )); $booksPipeline->pipe(new LazyLoadingMiddleware( Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware::class $container )); $booksPipeline->pipe(new LazyLoadingMiddleware( App\\ValidationMiddleware::class $container )); $booksPipeline->pipe(new LazyLoadingMiddleware( App\\Handler\\CreateBookHandler::class $container )); $app->post('/books/{id:\\d+}', $booksPipeline); }; Additionally, this would pose an enormous burden when migrating to version 3. For these reasons, we developed the class Zend\\Expressive\\MiddlewareFactory . It composes a MiddlewareContainer in order to back the following operations.","title":"The Middleware Factory"},{"location":"v3/features/container/middleware-factory/#callable","text":"$middleware = $factory->callable(function ($request, $handler) { }); This method takes a callable middleware, and decorates it as a Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator instance.","title":"callable"},{"location":"v3/features/container/middleware-factory/#handler","text":"$middleware = $factory->handler($requestHandler); This method takes a PSR-15 request handler instance and decorates it as a Zend\\Stratigility\\Middleware\\RequestHandlerMiddleware instance.","title":"handler"},{"location":"v3/features/container/middleware-factory/#lazy","text":"$middleware = $factory->lazy(App\\Middleware\\FooMiddleware::class); This method decorates the service name using Zend\\Expressive\\Middlware\\LazyLoadingMiddleware , passing the composed MiddlewareContainer to the instance during instantiation.","title":"lazy"},{"location":"v3/features/container/middleware-factory/#pipeline","text":"$pipeline = $factory->pipeline( $middlewareInstance, 'MiddlewareServiceName', function ($request, $handler) { }, $requestHandlerInstance ); Creates and returns a Zend\\Stratigility\\MiddlewarePipe , after passing each argument to prepare() first. (You may pass an array of values instead of individual arguments as well.)","title":"pipeline"},{"location":"v3/features/container/middleware-factory/#prepare","text":"$middleware = $factory->prepare($middleware); Inspects the provided middleware argument, with the following behavior: MiddlewareInterface instances are returned verbatim. RequestHandlerInterface instances are decorated using handler() . callable arguments are decorated using callable() . string arguments are decorated using lazy() . array arguments are decorated using pipeline() .","title":"prepare"},{"location":"v3/features/container/middleware-factory/#usage-in-bootstrapping","text":"The skeleton defines two files config/pipeline.php and config/routes.php . These are expected to return a callable with the following signature: use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\MiddlewareFactory; return function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void { }; Note that the MiddlewareFactory is passed to these callables; this gives you the ability to use it for more complex piping and routing needs, including creating nested pipelines. As an example, we'll rewrite our initial example to use the MiddlewareFactory : use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\MiddlewareFactory; use function Zend\\Stratigility\\path; return function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void { $app->pipe(path('/foo', $factory->prepare(App\\FooMiddleware::class))); $app->pipe($factory->prepare(function ($request, $handler) { // ... })); $app->post('/books/{id:\\d+}', $factory->pipeline( ProblemDetailsMiddleware::class, App\\SessionMiddleware::class, App\\AuthenticationMiddleware::class, App\\AuthorizationMiddleware::class, Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware::class, App\\ValidationMiddleware::class, App\\Handler\\CreateBookHandler::class )); };","title":"Usage in bootstrapping"},{"location":"v3/features/container/pimple/","text":"Using Pimple Pimple is a widely used, code-driven, dependency injection container provided as a standalone component by SensioLabs. It features: combined parameter and service storage. ability to define factories for specific classes. lazy-loading via factories. Pimple only supports programmatic creation at this time. Installing and configuring Pimple Pimple implements PSR-11 Container as of version 3.2. To use Pimple as a dependency injection container, we recommend using zendframework/zend-pimple-config , which helps you to configure the PSR-11 container. First install the package: $ composer require zendframework/zend-pimple-config Now, create the file config/container.php with the following contents: <?php use Zend\\Pimple\\Config\\Config; use Zend\\Pimple\\Config\\ContainerFactory; $config = require __DIR__ . '/config.php'; $factory = new ContainerFactory(); return $factory(new Config($config)); For more information, please see the zend-pimple-config documentation . Your bootstrap (typically public/index.php ) will then look like this: chdir(dirname(__DIR__)); require 'vendor/autoload.php'; $container = require 'config/container.php'; $app = $container->get(Zend\\Expressive\\Application::class); require 'config/pipeline.php'; require 'config/routes.php'; $app->run();","title":"Using Pimple"},{"location":"v3/features/container/pimple/#using-pimple","text":"Pimple is a widely used, code-driven, dependency injection container provided as a standalone component by SensioLabs. It features: combined parameter and service storage. ability to define factories for specific classes. lazy-loading via factories. Pimple only supports programmatic creation at this time.","title":"Using Pimple"},{"location":"v3/features/container/pimple/#installing-and-configuring-pimple","text":"Pimple implements PSR-11 Container as of version 3.2. To use Pimple as a dependency injection container, we recommend using zendframework/zend-pimple-config , which helps you to configure the PSR-11 container. First install the package: $ composer require zendframework/zend-pimple-config Now, create the file config/container.php with the following contents: <?php use Zend\\Pimple\\Config\\Config; use Zend\\Pimple\\Config\\ContainerFactory; $config = require __DIR__ . '/config.php'; $factory = new ContainerFactory(); return $factory(new Config($config)); For more information, please see the zend-pimple-config documentation . Your bootstrap (typically public/index.php ) will then look like this: chdir(dirname(__DIR__)); require 'vendor/autoload.php'; $container = require 'config/container.php'; $app = $container->get(Zend\\Expressive\\Application::class); require 'config/pipeline.php'; require 'config/routes.php'; $app->run();","title":"Installing and configuring Pimple"},{"location":"v3/features/container/zend-servicemanager/","text":"Using zend-servicemanager zend-servicemanager is a code-driven dependency injection container provided as a standalone component by Zend Framework. It features: lazy-loading of invokable (constructor-less) classes. ability to define factories for specific classes. ability to define generalized factories for classes with identical construction patterns (aka abstract factories ). ability to create lazy-loading proxies. ability to intercept before or after instantiation to alter the construction workflow (aka delegator factories ). interface injection (via initializers ). zend-servicemanager may either be created and populated programmatically, or via configuration. Configuration uses the following structure: [ 'services' => [ 'service name' => $serviceInstance, ], 'invokables' => [ 'service name' => 'class to instantiate', ], 'factories' => [ 'service name' => 'callable, Zend\\ServiceManager\\FactoryInterface instance, or name of factory class returning the service', ], 'abstract_factories' => [ 'class name of Zend\\ServiceManager\\AbstractFactoryInterface implementation', ], 'delegators' => [ 'service name' => [ 'class name of Zend\\ServiceManager\\DelegatorFactoryInterface implementation', ], ], 'lazy_services' => [ 'class_map' => [ 'service name' => 'Class\\Name\\Of\\Service', ], ], 'initializers' => [ 'callable, Zend\\ServiceManager\\InitializerInterface implementation, or name of initializer class', ], ] Read more about zend-servicemanager in its documentation . Installing zend-servicemanager To use zend-servicemanager with zend-expressive, you can install it via composer: $ composer require zendframework/zend-servicemanager Configuring zend-servicemanager You can configure zend-servicemanager either programmatically or via configuration. We'll show you both methods. Programmatically To use zend-servicemanager programatically, you'll need to create a Zend\\ServiceManager\\ServiceManager instance, and then start populating it. For this example, we'll assume your application configuration (used by several factories to configure instances) is in config/config.php , and that that file returns an array. We'll create a config/container.php file that creates and returns a Zend\\ServiceManager\\ServiceManager instance as follows: use Zend\\ServiceManager\\ServiceManager; $container = new ServiceManager(); // Application and configuration $container->setService('config', include 'config/config.php'); $container->setFactory( Zend\\Expressive\\Application::class, Zend\\Expressive\\Container\\ApplicationFactory::class ); // Routing // In most cases, you can instantiate the router you want to use without using a // factory: $container->setInvokableClass( Zend\\Expressive\\Router\\RouterInterface::class, Zend\\Expressive\\Router\\AuraRouter::class ); // Templating // In most cases, you can instantiate the template renderer you want to use // without using a factory: $container->setInvokableClass( Zend\\Expressive\\Template\\TemplateRendererInterface::class, Zend\\Expressive\\Plates\\PlatesRenderer::class ); // These next two can be added in any environment; they won't be used unless // you add the WhoopsErrorResponseGenerator as the ErrorResponseGenerator // implementation: $container->setFactory( 'Zend\\Expressive\\Whoops', Zend\\Expressive\\Container\\WhoopsFactory::class ); $container->setFactory( 'Zend\\Expressive\\WhoopsPageHandler', Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class ); // Error Handling // All environments: $container->setFactory( Zend\\Expressive\\Middleware\\ErrorHandler::class, Zend\\Expressive\\Container\\ErrorHandlerFactory::class ); // If in development: $container->setFactory( Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class, Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class ); // If in production: $container->setFactory( Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class, Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class ); return $container; Your bootstrap (typically public/index.php ) will then look like this: chdir(dirname(__DIR__)); require 'vendor/autoload.php'; $container = require 'config/container.php'; $app = $container->get(\\Zend\\Expressive\\Application::class); require 'config/pipeline.php'; require 'config/routes.php'; // All versions: $app->run(); Configuration-Driven Container Alternately, you can use a configuration file to define the container. As before, we'll define our configuration in config/config.php , and our config/container.php file will still return our service manager instance; we'll define the service configuration in config/dependencies.php : return [ 'services' => [ 'config' => include __DIR__ . '/config.php', ], 'aliases' => [ 'Zend\\Expressive\\Delegate\\DefaultDelegate' => 'Zend\\Expressive\\Delegate\\NotFoundDelegate', ], 'invokables' => [ Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\AuraRouter::class, Zend\\Expressive\\Template\\TemplateRendererInterface::class => Zend\\Expressive\\Plates\\PlatesRenderer::class ], 'factories' => [ Zend\\Expressive\\Application::class => Zend\\Expressive\\Container\\ApplicationFactory::class, 'Zend\\Expressive\\Whoops' => Zend\\Expressive\\Container\\WhoopsFactory::class, 'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class, Zend\\Stratigility\\Middleware\\ErrorHandler::class => Zend\\Expressive\\Container\\ErrorHandlerFactory::class, Zend\\Expressive\\Delegate\\NotFoundDelegate::class => Zend\\Expressive\\Container\\NotFoundDelegateFactory::class, Zend\\Expressive\\Middleware\\NotFoundHandler::class => Zend\\Expressive\\Container\\NotFoundHandlerFactory::class, ], ]; config/container.php becomes: use Zend\\ServiceManager\\Config; use Zend\\ServiceManager\\ServiceManager; return new ServiceManager(new Config(include 'config/dependencies.php')); There is one problem, however: you may want to vary error handling strategies based on whether or not you're in production: You have two choices on how to approach this: Selectively inject the factory in the bootstrap. Define the final handler service in an environment specific file and use file globbing to merge files. In the first case, you would change the config/container.php example to look like this: use Zend\\ServiceManager\\Config; use Zend\\ServiceManager\\ServiceManager; $container = new ServiceManager(new Config(include 'config/container.php')); switch ($variableOrConstantIndicatingEnvironment) { case 'development': $container->setFactory( Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class, Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class ); break; case 'production': default: $container->setFactory( Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class, Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class ); } return $container; In the second case, you will need to install zend-config: $ composer require zendframework/zend-config Then, create the directory config/autoload/ , and create two files, dependencies.global.php and dependencies.local.php . In your .gitignore , add an entry for config/autoload/*local.php to ensure \"local\" (environment-specific) files are excluded from the repository. config/dependencies.php will look like this: use Zend\\Config\\Factory as ConfigFactory; return ConfigFactory::fromFiles( glob('config/autoload/dependencies.{global,local}.php', GLOB_BRACE) ); config/autoload/dependencies.global.php will look like this: return [ 'services' => [ 'config' => include __DIR__ . '/config.php', ], 'aliases' => [ 'Zend\\Expressive\\Delegate\\DefaultDelegate' => Zend\\Expressive\\Delegate\\NotFoundDelegate::class, ], 'invokables' => [ Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\AuraRouter::class, Zend\\Expressive\\Template\\TemplateRendererInterface::class => Zend\\Expressive\\Plates\\PlatesRenderer::class ], 'factories' => [ Zend\\Expressive\\Application::class => Zend\\Expressive\\Container\\ApplicationFactory::class, 'Zend\\Expressive\\Whoops' => Zend\\Expressive\\Container\\WhoopsFactory::class, 'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class, Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class => Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class, Zend\\Stratigility\\Middleware\\ErrorHandler::class => Zend\\Expressive\\Container\\ErrorHandlerFactory::class, 'Zend\\Expressive\\Delegate\\NotFoundDelegate' => Zend\\Expressive\\Container\\NotFoundDelegateFactory::class, Zend\\Expressive\\Middleware\\NotFoundHandler::class => Zend\\Expressive\\Container\\NotFoundHandlerFactory::class, ], ]; config/autoload/dependencies.local.php on your development machine can look like this: return [ 'factories' => [ 'Zend\\Expressive\\Whoops' => Zend\\Expressive\\Container\\WhoopsFactory::class, 'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class, Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class => Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class, ], ]; Using the above approach allows you to keep the bootstrap file minimal and agnostic of environment. (Note: you can take a similar approach with the application configuration.)","title":"Using zend-servicemanager"},{"location":"v3/features/container/zend-servicemanager/#using-zend-servicemanager","text":"zend-servicemanager is a code-driven dependency injection container provided as a standalone component by Zend Framework. It features: lazy-loading of invokable (constructor-less) classes. ability to define factories for specific classes. ability to define generalized factories for classes with identical construction patterns (aka abstract factories ). ability to create lazy-loading proxies. ability to intercept before or after instantiation to alter the construction workflow (aka delegator factories ). interface injection (via initializers ). zend-servicemanager may either be created and populated programmatically, or via configuration. Configuration uses the following structure: [ 'services' => [ 'service name' => $serviceInstance, ], 'invokables' => [ 'service name' => 'class to instantiate', ], 'factories' => [ 'service name' => 'callable, Zend\\ServiceManager\\FactoryInterface instance, or name of factory class returning the service', ], 'abstract_factories' => [ 'class name of Zend\\ServiceManager\\AbstractFactoryInterface implementation', ], 'delegators' => [ 'service name' => [ 'class name of Zend\\ServiceManager\\DelegatorFactoryInterface implementation', ], ], 'lazy_services' => [ 'class_map' => [ 'service name' => 'Class\\Name\\Of\\Service', ], ], 'initializers' => [ 'callable, Zend\\ServiceManager\\InitializerInterface implementation, or name of initializer class', ], ] Read more about zend-servicemanager in its documentation .","title":"Using zend-servicemanager"},{"location":"v3/features/container/zend-servicemanager/#installing-zend-servicemanager","text":"To use zend-servicemanager with zend-expressive, you can install it via composer: $ composer require zendframework/zend-servicemanager","title":"Installing zend-servicemanager"},{"location":"v3/features/container/zend-servicemanager/#configuring-zend-servicemanager","text":"You can configure zend-servicemanager either programmatically or via configuration. We'll show you both methods.","title":"Configuring zend-servicemanager"},{"location":"v3/features/helpers/body-parse/","text":"Body Parsing Middleware Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware provides generic PSR-15 middleware for parsing the request body into parameters, and returning a new request instance that composes them. The subcomponent provides a strategy pattern around matching the request Content-Type , and then parsing it, giving you a flexible approach that can grow with your accepted content types. By default, this middleware will detect the following content types: application/x-www-form-urlencoded (standard web-based forms, without file uploads) application/json , application/*+json (JSON payloads) Registering the middleware You can register it programmatically: $app->pipe(BodyParamsMiddleware::class); Since body parsing does not necessarily need to happen for every request, you can also choose to incorporate it in route-specific middleware pipelines: $app->post('/login', [ BodyParamsMiddleware::class, LoginMiddleware::class, ]); Using route-based middleware pipelines has the advantage of ensuring that the body parsing middleware only executes for routes that require the processing. While the middleware has some checks to ensure it only triggers for HTTP methods that accept bodies, those checks are still overhead that you might want to avoid; the above strategy of using the middleware only with specific routes can accomplish that. Strategies If you want to intercept and parse other payload types, you can add strategies to the middleware. Strategies implement Zend\\Expressive\\Helper\\BodyParams\\StrategyInterface : namespace Zend\\Expressive\\Helper\\BodyParams; use Psr\\Http\\Message\\ServerRequestInterface; interface StrategyInterface { /** * Match the content type to the strategy criteria. */ public function match(string $contentType) : bool; /** * Parse the body content and return a new request. */ public function parse(ServerRequestInterface $request) : ServerRequestInterface; } You then register them with the middleware using the addStrategy() method: $bodyParams->addStrategy(new MyCustomBodyParamsStrategy()); To automate the registration, we recommend writing a factory for the BodyParamsMiddleware , and replacing the invokables registration with a registration in the factories section of the middleware-pipeline.config.php file: use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware; class MyCustomBodyParamsStrategyFactory { public function __invoke($container) { $bodyParams = new BodyParamsMiddleware(); $bodyParams->addStrategy(new MyCustomBodyParamsStrategy()); return $bodyParams; } } // In config/autoload/middleware-pipeline.config.php: use Zend\\Expressive\\Helper; return [ 'dependencies' => [ 'invokables' => [ // Remove this line: Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class, /* ... */ ], 'factories' => [ // Add this line: Helper\\BodyParams\\BodyParamsMiddleware::class => MyCustomBodyParamsStrategyFactory::class, /* ... */ ], ], ]; Alternately, use a delegator factory . Removing the default strategies By default, BodyParamsMiddleware composes the following strategies: Zend\\Expressive\\Helper\\BodyParams\\FormUrlEncodedStrategy Zend\\Expressive\\Helper\\BodyParams\\JsonStrategy These provide the most basic approaches to parsing the request body. They operate in the order they do to ensure the most common content type \u2014 application/x-www-form-urlencoded \u2014 matches first, as the middleware delegates parsing to the first match. If you do not want to use these default strategies, you can clear them from the middleware using clearStrategies() : $bodyParamsMiddleware->clearStrategies(); Note: if you do this, all strategies will be removed! As such, we recommend doing this only immediately before registering any custom strategies you might be using.","title":"Body Parsing Middleware"},{"location":"v3/features/helpers/body-parse/#body-parsing-middleware","text":"Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware provides generic PSR-15 middleware for parsing the request body into parameters, and returning a new request instance that composes them. The subcomponent provides a strategy pattern around matching the request Content-Type , and then parsing it, giving you a flexible approach that can grow with your accepted content types. By default, this middleware will detect the following content types: application/x-www-form-urlencoded (standard web-based forms, without file uploads) application/json , application/*+json (JSON payloads)","title":"Body Parsing Middleware"},{"location":"v3/features/helpers/body-parse/#registering-the-middleware","text":"You can register it programmatically: $app->pipe(BodyParamsMiddleware::class); Since body parsing does not necessarily need to happen for every request, you can also choose to incorporate it in route-specific middleware pipelines: $app->post('/login', [ BodyParamsMiddleware::class, LoginMiddleware::class, ]); Using route-based middleware pipelines has the advantage of ensuring that the body parsing middleware only executes for routes that require the processing. While the middleware has some checks to ensure it only triggers for HTTP methods that accept bodies, those checks are still overhead that you might want to avoid; the above strategy of using the middleware only with specific routes can accomplish that.","title":"Registering the middleware"},{"location":"v3/features/helpers/body-parse/#strategies","text":"If you want to intercept and parse other payload types, you can add strategies to the middleware. Strategies implement Zend\\Expressive\\Helper\\BodyParams\\StrategyInterface : namespace Zend\\Expressive\\Helper\\BodyParams; use Psr\\Http\\Message\\ServerRequestInterface; interface StrategyInterface { /** * Match the content type to the strategy criteria. */ public function match(string $contentType) : bool; /** * Parse the body content and return a new request. */ public function parse(ServerRequestInterface $request) : ServerRequestInterface; } You then register them with the middleware using the addStrategy() method: $bodyParams->addStrategy(new MyCustomBodyParamsStrategy()); To automate the registration, we recommend writing a factory for the BodyParamsMiddleware , and replacing the invokables registration with a registration in the factories section of the middleware-pipeline.config.php file: use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware; class MyCustomBodyParamsStrategyFactory { public function __invoke($container) { $bodyParams = new BodyParamsMiddleware(); $bodyParams->addStrategy(new MyCustomBodyParamsStrategy()); return $bodyParams; } } // In config/autoload/middleware-pipeline.config.php: use Zend\\Expressive\\Helper; return [ 'dependencies' => [ 'invokables' => [ // Remove this line: Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class, /* ... */ ], 'factories' => [ // Add this line: Helper\\BodyParams\\BodyParamsMiddleware::class => MyCustomBodyParamsStrategyFactory::class, /* ... */ ], ], ]; Alternately, use a delegator factory .","title":"Strategies"},{"location":"v3/features/helpers/body-parse/#removing-the-default-strategies","text":"By default, BodyParamsMiddleware composes the following strategies: Zend\\Expressive\\Helper\\BodyParams\\FormUrlEncodedStrategy Zend\\Expressive\\Helper\\BodyParams\\JsonStrategy These provide the most basic approaches to parsing the request body. They operate in the order they do to ensure the most common content type \u2014 application/x-www-form-urlencoded \u2014 matches first, as the middleware delegates parsing to the first match. If you do not want to use these default strategies, you can clear them from the middleware using clearStrategies() : $bodyParamsMiddleware->clearStrategies(); Note: if you do this, all strategies will be removed! As such, we recommend doing this only immediately before registering any custom strategies you might be using.","title":"Removing the default strategies"},{"location":"v3/features/helpers/content-length/","text":"Content-Length Middleware In some cases, you may want to include an explicit Content-Length response header, without having to inject it manually. To facilitate this, we provide Zend\\Expressive\\Helper\\ContentLengthMiddleware . When to use this middleware In most cases, you do not need to provide an explicit Content-Length value in your responses. While the HTTP/1.1 specification indicates the header SHOULD be provided, most clients will not degrade to HTTP/1.0 if the header is omitted. The one exception that has been reported is when working with New Relic , which requires valid Content-Length headers for some of its analytics; in such cases, enabling this middleware will fix those situations. This middleware delegates the request, and operates on the returned response. It will return a new response with the Content-Length header injected under the following conditions: No Content-Length header is already present AND the body size is non-null. To register it in your application, you will need to do two things: register the middleware with the container, and register the middleware in either your application pipeline, or within routed middleware. To add it to your container, add the following configuration: // In a `config/autoload/*.global.php` file, or a `ConfigProvider` class: use Zend\\Expressive\\Helper; return [ 'dependencies' => [ 'invokables' => [ Helper\\ContentLengthMiddleware::class => Helper\\ContentLengthMiddleware::class, ], ], ]; To register it as pipeline middleware to execute on any request: // In `config/pipeline.php`: use Zend\\Expressive\\Helper; $app->pipe(Helper\\ContentLengthMiddleware::class); To register it within a routed middleware pipeline: // In `config/routes.php`: use Zend\\Expressive\\Helper; $app->get('/download/tarball', [ Helper\\ContentLengthMiddleware::class, Download\\Tarball::class, ], 'download-tar'); Caveats One caveat to note is that if you use this middleware, but also write directly to the output buffer (e.g., via a var_dump , or if display_errors is on and an uncaught error or exception occurs), the output will not appear as you expect. Generally in such situations, the contents of the output buffer will appear, up to the specified Content-Length value. This can lead to truncated error content and/or truncated application content. We recommend that if you use this feature, you also use a PHP error and/or exception handler that logs errors in order to prevent truncated output.","title":"Content-Length Middleware"},{"location":"v3/features/helpers/content-length/#content-length-middleware","text":"In some cases, you may want to include an explicit Content-Length response header, without having to inject it manually. To facilitate this, we provide Zend\\Expressive\\Helper\\ContentLengthMiddleware .","title":"Content-Length Middleware"},{"location":"v3/features/helpers/content-length/#caveats","text":"One caveat to note is that if you use this middleware, but also write directly to the output buffer (e.g., via a var_dump , or if display_errors is on and an uncaught error or exception occurs), the output will not appear as you expect. Generally in such situations, the contents of the output buffer will appear, up to the specified Content-Length value. This can lead to truncated error content and/or truncated application content. We recommend that if you use this feature, you also use a PHP error and/or exception handler that logs errors in order to prevent truncated output.","title":"Caveats"},{"location":"v3/features/helpers/intro/","text":"Helpers Some tasks and features will be common to many if not all applications. For those, Expressive provides helpers . These are typically utility classes that may integrate features or simply provide standalone benefits. Currently, these include: Body Parsing Middleware Content-Length Middleware (since zend-expressive-helpers 4.1.0) UrlHelper ServerUrlHelper Installation If you started your project using the Expressive skeleton package, the helpers are already installed. If not, you can install them as follows: $ composer require zendframework/zend-expressive-helpers","title":"Introduction"},{"location":"v3/features/helpers/intro/#helpers","text":"Some tasks and features will be common to many if not all applications. For those, Expressive provides helpers . These are typically utility classes that may integrate features or simply provide standalone benefits. Currently, these include: Body Parsing Middleware Content-Length Middleware (since zend-expressive-helpers 4.1.0) UrlHelper ServerUrlHelper","title":"Helpers"},{"location":"v3/features/helpers/intro/#installation","text":"If you started your project using the Expressive skeleton package, the helpers are already installed. If not, you can install them as follows: $ composer require zendframework/zend-expressive-helpers","title":"Installation"},{"location":"v3/features/helpers/server-url-helper/","text":"ServerUrlHelper Zend\\Expressive\\Helper\\ServerUrlHelper provides the ability to generate a full URI by passing only the path to the helper; it will then use that path with the current Psr\\Http\\Message\\UriInterface instance provided to it in order to generate a fully qualified URI. Usage When you have an instance, use either its generate() method, or call the instance as an invokable: // Using the generate() method: $url = $helper->generate('/foo'); // is equivalent to invocation: $url = $helper('/foo'); The helper is particularly useful when used in conjunction with the UrlHelper , as you can then create fully qualified URIs for use with headers, API hypermedia links, etc.: $url = $serverUrl($url('resource', ['id' => 'sha1'])); The signature for the ServerUrlHelper generate() and __invoke() methods is: function ($path = null) : string Where: $path , when provided, can be a string path to use to generate a URI. Creating an instance In order to use the helper, you will need to inject it with the current UriInterface from the request instance. To automate this, we provide Zend\\Expressive\\Helper\\ServerUrlMiddleware , which composes a ServerUrl instance, and, when invoked, injects it with the URI instance. As such, you will need to register the ServerUrlMiddleware as pipeline middleware, anytime before the routing middleware: use Zend\\Expressive\\Helper\\ServerUrlMiddleware; // Programmatically: $app->pipe(ServerUrlMiddleware::class); $app->pipe(RouteMiddleware::class); // ... $app->pipe(DispatchMiddleware::class); Skeleton configures helpers If you started your project using the Expressive skeleton package, the ServerUrlHelper and ServerUrlMiddleware factories are already registered for you, as is the ServerUrlMiddleware pipeline middleware. Using the helper in middleware Compose the helper in your middleware (or elsewhere), and then use it to generate URI paths: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterfacel use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Helper\\ServerUrlHelper; class FooMiddleware implements MiddlewareInterface { private $helper; public function __construct(ServerUrlHelper $helper) { $this->helper = $helper; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $response = $handler->handle($request); return $response->withHeader( 'Link', $this->helper->generate() . '; rel=\"self\"' ); } }","title":"ServerUrlHelper"},{"location":"v3/features/helpers/server-url-helper/#serverurlhelper","text":"Zend\\Expressive\\Helper\\ServerUrlHelper provides the ability to generate a full URI by passing only the path to the helper; it will then use that path with the current Psr\\Http\\Message\\UriInterface instance provided to it in order to generate a fully qualified URI.","title":"ServerUrlHelper"},{"location":"v3/features/helpers/server-url-helper/#usage","text":"When you have an instance, use either its generate() method, or call the instance as an invokable: // Using the generate() method: $url = $helper->generate('/foo'); // is equivalent to invocation: $url = $helper('/foo'); The helper is particularly useful when used in conjunction with the UrlHelper , as you can then create fully qualified URIs for use with headers, API hypermedia links, etc.: $url = $serverUrl($url('resource', ['id' => 'sha1'])); The signature for the ServerUrlHelper generate() and __invoke() methods is: function ($path = null) : string Where: $path , when provided, can be a string path to use to generate a URI.","title":"Usage"},{"location":"v3/features/helpers/server-url-helper/#creating-an-instance","text":"In order to use the helper, you will need to inject it with the current UriInterface from the request instance. To automate this, we provide Zend\\Expressive\\Helper\\ServerUrlMiddleware , which composes a ServerUrl instance, and, when invoked, injects it with the URI instance. As such, you will need to register the ServerUrlMiddleware as pipeline middleware, anytime before the routing middleware: use Zend\\Expressive\\Helper\\ServerUrlMiddleware; // Programmatically: $app->pipe(ServerUrlMiddleware::class); $app->pipe(RouteMiddleware::class); // ... $app->pipe(DispatchMiddleware::class);","title":"Creating an instance"},{"location":"v3/features/helpers/server-url-helper/#using-the-helper-in-middleware","text":"Compose the helper in your middleware (or elsewhere), and then use it to generate URI paths: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterfacel use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Helper\\ServerUrlHelper; class FooMiddleware implements MiddlewareInterface { private $helper; public function __construct(ServerUrlHelper $helper) { $this->helper = $helper; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $response = $handler->handle($request); return $response->withHeader( 'Link', $this->helper->generate() . '; rel=\"self\"' ); } }","title":"Using the helper in middleware"},{"location":"v3/features/helpers/template-variable-container/","text":"Template Variable Container Since zend-expressive-helpers 5.3.0 zend-expressive-template provides the method Zend\\Expressive\\Template\\TemplateRendererInterface::addDefaultParam() for providing template variables that should be available to any template. One common use case for this is to set things such as the current user, current section of the website, currently matched route, etc. Unfortunately, because the method changes the internal state of the renderer, this can cause problems in an async environment, such as Swoole , where those changes will persist for parallel and subsequent requests. To provide a stateless alternative, you can create a Zend\\Expressive\\Helper\\Template\\TemplateVariableContainer and persist it as a request attribute. This allows you to set template variables that are pipeline-specific, and later extract and merge them with handler-specific values when rendering. To facilitate this further, we provide Zend\\Expressive\\Helper\\Template\\TemplateVariableContainerMiddleware , which will populate the attribute for you if it has not yet been. The container is immutable , and any changes will result in a new instance. As such, any middleware that is providing additional values or removing values must call $request->withAttribute() to replace the instance, per the examples below. When to use the TemplateVariableContainer If you are calling addDefaultParam() only in your factory for creating your template renderer instance, or within delegator factories on the renderer, you do not need to make any changes. If you are using our Swoole integrations or other async application runners, and either currently or plan to set template parameters withing pipeline middleware you definitely need to use the TemplateVariableContainer in order to prevent state problems. We actually recommend using this approach even if you are not using Swoole or other async application runners, as the approach is more explicit and easily tested, and, as noted, does not depend on state within the renderer itself. Usage As an example, consider the following pipeline: // In config/pipeline.php use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\Handler\\NotFoundHandler; use Zend\\Expressive\\Helper\\ServerUrlMiddleware; use Zend\\Expressive\\Helper\\Template\\TemplateVariableContainerMiddleware; use Zend\\Expressive\\Helper\\UrlHelperMiddleware; use Zend\\Expressive\\MiddlewareFactory; use Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware; use Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware; use Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware; use Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware; use Zend\\Expressive\\Router\\Middleware\\RouteMiddleware; use Zend\\Stratigility\\Middleware\\ErrorHandler; use function Zend\\Stratigility\\path; return function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void { $app->pipe(ErrorHandler::class); $app->pipe(ServerUrlMiddleware::class); // The following entry is specific to this example: $app->pipe(path( '/api/doc', $factory->lazy(TemplateVariableContainerMiddleware::class) )); $app->pipe(RouteMiddleware::class); $app->pipe(ImplicitHeadMiddleware::class); $app->pipe(ImplicitOptionsMiddleware::class); $app->pipe(MethodNotAllowedMiddleware::class); $app->pipe(UrlHelperMiddleware::class); $app->pipe(DispatchMiddleware::class); $app->pipe(NotFoundHandler::class); }; Any middleware or handler that responds to a path beginning with /api/doc will now have a Zend\\Expressive\\Helper\\Template\\TemplateVariableContainer attribute that contains an instance of that class. Within middleware that responds on that path, you can then do the following: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Helper\\Template\\TemplateVariableContainer; use Zend\\Expressive\\Router\\RouteResult; class InjectUserAndRouteVariablesMiddleware implements MiddlewareInterface { public function process( ServerRequestInterface $request, RequestHandlerInterface $handler ) : ResponseInterface { $container = $request->getAttribute( TemplateVariableContainer::class, new TemplateVariableContainer() ); // Since containers are immutable, we re-populate the request: $request = $request->withAttribute( TemplateVariableContainer::class, $container->merge([ 'user' => $user, 'route' => $request->getAttribute(RouteResult::class), ]) ); return $handler->handle($request); } } In a handler, you will call mergeForTemplate() with any local variables you want to use, including those that might override the defaults: use Psr\\Http\\Message\\ResponseFactoryInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\StreamFactoryInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Helper\\Template\\TemplateVariableContainer; use Zend\\Expressive\\Template\\TemplateRendererInterface; class SomeHandler implements RequestHandlerInterface { private $renderer; private $responseFactory; private $streamFactory; public function __construct( TemplateRendererInterface $renderer, ResponseFactoryInterface $responseFactory, StreamFactoryInterface $streamFactory ) { $this->renderer = $renderer; $this->responseFactory = $responseFactory; $this->streamFactory = $streamFactory; } public function handle(ServerRequestInterface $request) : ResponseInterface { $value = $request->getParsedBody()['key'] ?? null; $content = $this->renderer->render( 'some::template', $request ->getAttribute(TemplateVariableContainer::class) ->mergeForTemplate([ 'local' => $value, ]) ); $body = $this->streamFactory()->createStream($content); return $this->responseFactory()->createResponse(200)->withBody($body); } } The TemplateVariableContainer contains the following methods: count() : int : return a count of variables in the container. get(string $key) : mixed : return the value associated with $key ; if not present, a null is returned. has(string $key) : bool : does the container have an entry associated with $key ? with(string $key, mixed $value) : self : return a new container instance containing the key/value pair provided. without(string $key) : self : return a new container instance that does not contain the given $key . merge(array $values) : self : return a new container that merge the $values provided with those in the original container. This is useful for setting many values at once. mergeForTemplate(array $values) : array : merge $values with any values in the container, and return the result. This method has no side effects, and should be used when preparing variables to pass to the renderer. Route template variable middleware Since zend-expressive-helpers 5.3.0 Zend\\Expressive\\Helper\\Template\\RouteTemplateVariableMiddleware will inject the currently matched route into the template variable container . This middleware relies on the TemplateVariableContainerMiddleware preceding it in the middleware pipeline, or having the TemplateVariableContainer request attribute present; if neither is present, it will generate a new instance. It then populates the container's route parameter using the results of retrieving the Zend\\Expressive\\Router\\RouteResult request attribute; the value will be either an instance of that class, or null . Templates rendered using the container can then access that value, and test for routing success/failure status, pull the matched route name, route, and/or parameters from it. This middleware can replace the UrlHelperMiddleware in your pipeline.","title":"Template Variable Container"},{"location":"v3/features/helpers/template-variable-container/#template-variable-container","text":"Since zend-expressive-helpers 5.3.0 zend-expressive-template provides the method Zend\\Expressive\\Template\\TemplateRendererInterface::addDefaultParam() for providing template variables that should be available to any template. One common use case for this is to set things such as the current user, current section of the website, currently matched route, etc. Unfortunately, because the method changes the internal state of the renderer, this can cause problems in an async environment, such as Swoole , where those changes will persist for parallel and subsequent requests. To provide a stateless alternative, you can create a Zend\\Expressive\\Helper\\Template\\TemplateVariableContainer and persist it as a request attribute. This allows you to set template variables that are pipeline-specific, and later extract and merge them with handler-specific values when rendering. To facilitate this further, we provide Zend\\Expressive\\Helper\\Template\\TemplateVariableContainerMiddleware , which will populate the attribute for you if it has not yet been. The container is immutable , and any changes will result in a new instance. As such, any middleware that is providing additional values or removing values must call $request->withAttribute() to replace the instance, per the examples below.","title":"Template Variable Container"},{"location":"v3/features/helpers/template-variable-container/#usage","text":"As an example, consider the following pipeline: // In config/pipeline.php use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\Handler\\NotFoundHandler; use Zend\\Expressive\\Helper\\ServerUrlMiddleware; use Zend\\Expressive\\Helper\\Template\\TemplateVariableContainerMiddleware; use Zend\\Expressive\\Helper\\UrlHelperMiddleware; use Zend\\Expressive\\MiddlewareFactory; use Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware; use Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware; use Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware; use Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware; use Zend\\Expressive\\Router\\Middleware\\RouteMiddleware; use Zend\\Stratigility\\Middleware\\ErrorHandler; use function Zend\\Stratigility\\path; return function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void { $app->pipe(ErrorHandler::class); $app->pipe(ServerUrlMiddleware::class); // The following entry is specific to this example: $app->pipe(path( '/api/doc', $factory->lazy(TemplateVariableContainerMiddleware::class) )); $app->pipe(RouteMiddleware::class); $app->pipe(ImplicitHeadMiddleware::class); $app->pipe(ImplicitOptionsMiddleware::class); $app->pipe(MethodNotAllowedMiddleware::class); $app->pipe(UrlHelperMiddleware::class); $app->pipe(DispatchMiddleware::class); $app->pipe(NotFoundHandler::class); }; Any middleware or handler that responds to a path beginning with /api/doc will now have a Zend\\Expressive\\Helper\\Template\\TemplateVariableContainer attribute that contains an instance of that class. Within middleware that responds on that path, you can then do the following: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Helper\\Template\\TemplateVariableContainer; use Zend\\Expressive\\Router\\RouteResult; class InjectUserAndRouteVariablesMiddleware implements MiddlewareInterface { public function process( ServerRequestInterface $request, RequestHandlerInterface $handler ) : ResponseInterface { $container = $request->getAttribute( TemplateVariableContainer::class, new TemplateVariableContainer() ); // Since containers are immutable, we re-populate the request: $request = $request->withAttribute( TemplateVariableContainer::class, $container->merge([ 'user' => $user, 'route' => $request->getAttribute(RouteResult::class), ]) ); return $handler->handle($request); } } In a handler, you will call mergeForTemplate() with any local variables you want to use, including those that might override the defaults: use Psr\\Http\\Message\\ResponseFactoryInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\StreamFactoryInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Helper\\Template\\TemplateVariableContainer; use Zend\\Expressive\\Template\\TemplateRendererInterface; class SomeHandler implements RequestHandlerInterface { private $renderer; private $responseFactory; private $streamFactory; public function __construct( TemplateRendererInterface $renderer, ResponseFactoryInterface $responseFactory, StreamFactoryInterface $streamFactory ) { $this->renderer = $renderer; $this->responseFactory = $responseFactory; $this->streamFactory = $streamFactory; } public function handle(ServerRequestInterface $request) : ResponseInterface { $value = $request->getParsedBody()['key'] ?? null; $content = $this->renderer->render( 'some::template', $request ->getAttribute(TemplateVariableContainer::class) ->mergeForTemplate([ 'local' => $value, ]) ); $body = $this->streamFactory()->createStream($content); return $this->responseFactory()->createResponse(200)->withBody($body); } } The TemplateVariableContainer contains the following methods: count() : int : return a count of variables in the container. get(string $key) : mixed : return the value associated with $key ; if not present, a null is returned. has(string $key) : bool : does the container have an entry associated with $key ? with(string $key, mixed $value) : self : return a new container instance containing the key/value pair provided. without(string $key) : self : return a new container instance that does not contain the given $key . merge(array $values) : self : return a new container that merge the $values provided with those in the original container. This is useful for setting many values at once. mergeForTemplate(array $values) : array : merge $values with any values in the container, and return the result. This method has no side effects, and should be used when preparing variables to pass to the renderer.","title":"Usage"},{"location":"v3/features/helpers/template-variable-container/#route-template-variable-middleware","text":"Since zend-expressive-helpers 5.3.0 Zend\\Expressive\\Helper\\Template\\RouteTemplateVariableMiddleware will inject the currently matched route into the template variable container . This middleware relies on the TemplateVariableContainerMiddleware preceding it in the middleware pipeline, or having the TemplateVariableContainer request attribute present; if neither is present, it will generate a new instance. It then populates the container's route parameter using the results of retrieving the Zend\\Expressive\\Router\\RouteResult request attribute; the value will be either an instance of that class, or null . Templates rendered using the container can then access that value, and test for routing success/failure status, pull the matched route name, route, and/or parameters from it. This middleware can replace the UrlHelperMiddleware in your pipeline.","title":"Route template variable middleware"},{"location":"v3/features/helpers/url-helper/","text":"UrlHelper Zend\\Expressive\\Helper\\UrlHelper provides the ability to generate a URI path based on a given route defined in the Zend\\Expressive\\Router\\RouterInterface . If injected with a route result, and the route being used was also the one matched during routing, you can provide a subset of routing parameters, and any not provided will be pulled from those matched. Usage When you have an instance, use either its generate() method, or call the instance as an invokable: // Using the generate() method: $url = $helper->generate('resource', ['id' => 'sha1']); // is equivalent to invocation: $url = $helper('resource', ['id' => 'sha1']); The signature for both is: function ( $routeName, array $routeParams = [], $queryParams = [], $fragmentIdentifier = null, array $options = [] ) : string Where: $routeName is the name of a route defined in the composed router. You may omit this argument if you want to generate the path for the currently matched request. $routeParams is an array of substitutions to use for the provided route, with the following behavior: If a RouteResult is composed in the helper, and the $routeName matches it, the provided $params will be merged with any matched parameters, with those provided taking precedence. If a RouteResult is not composed, or if the composed result does not match the provided $routeName , then only the $params provided will be used for substitutions. If no $params are provided, and the $routeName matches the currently matched route, then any matched parameters found will be used. parameters found will be used. If no $params are provided, and the $routeName does not match the currently matched route, or if no route result is present, then no substitutions will be made. $queryParams is an array of query string arguments to include in the generated URI. $fragmentIdentifier is a string to use as the URI fragment. $options is an array of options to provide to the router for purposes of controlling URI generation. As an example, zend-router can consume \"translator\" and \"text_domain\" options in order to provide translated URIs. Each method will raise an exception if: No $routeName is provided, and no RouteResult is composed. No $routeName is provided, a RouteResult is composed, but that result represents a matching failure. The given $routeName is not defined in the router. Signature changes The signature listed above is current as of version 3.0.0 of zendframework/zend-expressive-helpers. Prior to that version, the helper only accepted the route name and route parameters. Other methods available getRouteResult() : ?Zend\\Expressive\\Router\\RouteResult (since zend-expressive-helpers 5.2.0): if you want access to the result of routing \u2014 and, consequently, the matched route name, matched route parameters, and matched route \u2014 you can use this method. The method returns null if no route result has been injected yet \u2014 which typically happens in the UrlHelperMiddleware , discussed in the next section. As an example: php $templateParams = []; $routeResult = $this->urlHelper->getRouteResult(); if ($routeResult->isSuccess()) { $templateParams['route'] = $routeResult->getMatchedRouteName(); $templateParams['route_params'] = $routeResult->getMatchedParams(); } Registering the pipeline middleware For the UrlHelper to work, you must first register the UrlHelperMiddleware as pipeline middleware following the routing middleware, and before the dispatch middleware: use Zend\\Expressive\\Helper\\UrlHelperMiddleware; // Programmatically: $app->pipe(RouteMiddleware::class); // ... $app->pipe(UrlHelperMiddleware::class); $app->pipe(DispatchMiddleware::class); Skeleton configures helpers If you started your project using the Expressive skeleton package, the UrlHelper and UrlHelperMiddleware factories are already registered for you, as is the UrlHelperMiddleware pipeline middleware. Using the helper in middleware Compose the helper in your middleware (or elsewhere), and then use it to generate URI paths: <?php use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Helper\\UrlHelper; class FooMiddleware implements MiddlewareInterface { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $response = $handler->handle($request); return $response->withHeader( 'Link', $this->helper->generate('resource', ['id' => 'sha1']) ); } } Base Path support If your application is running under a subdirectory, or if you are running pipeline middleware that is intercepting on a subpath, the paths generated by the router may not reflect the base path , and thus be invalid. To accommodate this, the UrlHelper supports injection of the base path; when present, it will be prepended to the path generated by the router. As an example, perhaps you have middleware running to intercept a language prefix in the URL; this middleware could then inject the UrlHelper with the detected language, before stripping it off the request URI instance to pass on to the router: <?php use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Helper\\UrlHelper; class LocaleMiddleware implements MiddlewareInterface { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $uri = $request->getUri(); $path = $uri->getPath(); if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) { return $handler->handle($request); } $locale = $matches['locale']; Locale::setDefault(Locale::canonicalize($locale)); $this->helper->setBasePath($locale); return $handler->handle($request->withUri( $uri->withPath(substr($path, strlen($locale) + 1)) )); } } (Note: if the base path injected is not prefixed with / , the helper will add the slash.) Paths generated by the UriHelper from this point forward will have the detected language prefix. Router-specific helpers Since zend-expressive-router 3.1.0 and zend-expressive-helpers 5.1.0. Occasionally, you may want to provide a different router instance to nested pipeline middleware; in particular, this may occur when you want to segregate a pipeline by path . In such situations, you cannot reuse the UrlHelper instance, as a different router is in play; additionally, it may need to define a base path so that any generated URIs contain the full path information (since path segregation strips the specified path prefix from the request). To facilitate such scenarios, the factories for the UrlHelper and UrlHelperMiddleware allow providing optional arguments to allow varying behavior: UrlHelperFactory allows passing an alternate router service name. UrlHelperMiddlewareFactory allows passing an alternate URL helper service name. As an example, let us consider a module named Auth where we want to define a path-segregated middleware pipeline that has its own router and route middleware. We might define its dependency configuration as follows: namespace Auth; use Zend\\Expressive\\Helper\\UrlHelperFactory; use Zend\\Expressive\\Helper\\UrlHelperMiddlewareFactory; use Zend\\Expressive\\Router\\FastRouteRouter; use Zend\\Expressive\\Router\\Middleware\\RouteMiddlewareFactory; return [ 'dependencies' => [ 'factories' => [ // module-specific class name => factory Router::class => FastRouteRouterFactory::class, RouteMiddleware::class => new RouteMiddlewareFactory(Router::class), UrlHelper::class => new UrlHelperFactory('/auth', Router::class), UrlHelperMiddleware::class => new UrlHelperMiddlewareFactory(UrlHelper::class), ], ], ]; We could then create a path-segregated pipeline like the following: $app->pipe('/auth', [ \\Auth\\RouteMiddleware::class, // module-specific routing middleware! ImplicitHeadMiddleware::class, ImplicitOptionsMiddleware::class, MethodNotAllowedMiddleware::class, \\Auth\\UrlHelperMiddleware::class, // module-specific URL helper middleware! DispatchMiddleware::class, ]); Any handlers that the module-specific router routes to can then also compose the same UrlHelper instance via their factories: namespace Auth; use Psr\\Container\\ContainerInterface; class SomeHandlerFactory { public function __invoke(ContainerInterface $container) : SomeHandler { return new SomeHandler( $container->get(UrlHelper::class) // module-specific URL helper! ); } } This instance will then be properly configured to generate links using the module-specific router.","title":"UrlHelper"},{"location":"v3/features/helpers/url-helper/#urlhelper","text":"Zend\\Expressive\\Helper\\UrlHelper provides the ability to generate a URI path based on a given route defined in the Zend\\Expressive\\Router\\RouterInterface . If injected with a route result, and the route being used was also the one matched during routing, you can provide a subset of routing parameters, and any not provided will be pulled from those matched.","title":"UrlHelper"},{"location":"v3/features/helpers/url-helper/#usage","text":"When you have an instance, use either its generate() method, or call the instance as an invokable: // Using the generate() method: $url = $helper->generate('resource', ['id' => 'sha1']); // is equivalent to invocation: $url = $helper('resource', ['id' => 'sha1']); The signature for both is: function ( $routeName, array $routeParams = [], $queryParams = [], $fragmentIdentifier = null, array $options = [] ) : string Where: $routeName is the name of a route defined in the composed router. You may omit this argument if you want to generate the path for the currently matched request. $routeParams is an array of substitutions to use for the provided route, with the following behavior: If a RouteResult is composed in the helper, and the $routeName matches it, the provided $params will be merged with any matched parameters, with those provided taking precedence. If a RouteResult is not composed, or if the composed result does not match the provided $routeName , then only the $params provided will be used for substitutions. If no $params are provided, and the $routeName matches the currently matched route, then any matched parameters found will be used. parameters found will be used. If no $params are provided, and the $routeName does not match the currently matched route, or if no route result is present, then no substitutions will be made. $queryParams is an array of query string arguments to include in the generated URI. $fragmentIdentifier is a string to use as the URI fragment. $options is an array of options to provide to the router for purposes of controlling URI generation. As an example, zend-router can consume \"translator\" and \"text_domain\" options in order to provide translated URIs. Each method will raise an exception if: No $routeName is provided, and no RouteResult is composed. No $routeName is provided, a RouteResult is composed, but that result represents a matching failure. The given $routeName is not defined in the router.","title":"Usage"},{"location":"v3/features/helpers/url-helper/#using-the-helper-in-middleware","text":"Compose the helper in your middleware (or elsewhere), and then use it to generate URI paths: <?php use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Helper\\UrlHelper; class FooMiddleware implements MiddlewareInterface { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $response = $handler->handle($request); return $response->withHeader( 'Link', $this->helper->generate('resource', ['id' => 'sha1']) ); } }","title":"Using the helper in middleware"},{"location":"v3/features/helpers/url-helper/#base-path-support","text":"If your application is running under a subdirectory, or if you are running pipeline middleware that is intercepting on a subpath, the paths generated by the router may not reflect the base path , and thus be invalid. To accommodate this, the UrlHelper supports injection of the base path; when present, it will be prepended to the path generated by the router. As an example, perhaps you have middleware running to intercept a language prefix in the URL; this middleware could then inject the UrlHelper with the detected language, before stripping it off the request URI instance to pass on to the router: <?php use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Helper\\UrlHelper; class LocaleMiddleware implements MiddlewareInterface { private $helper; public function __construct(UrlHelper $helper) { $this->helper = $helper; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $uri = $request->getUri(); $path = $uri->getPath(); if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) { return $handler->handle($request); } $locale = $matches['locale']; Locale::setDefault(Locale::canonicalize($locale)); $this->helper->setBasePath($locale); return $handler->handle($request->withUri( $uri->withPath(substr($path, strlen($locale) + 1)) )); } } (Note: if the base path injected is not prefixed with / , the helper will add the slash.) Paths generated by the UriHelper from this point forward will have the detected language prefix.","title":"Base Path support"},{"location":"v3/features/helpers/url-helper/#router-specific-helpers","text":"Since zend-expressive-router 3.1.0 and zend-expressive-helpers 5.1.0. Occasionally, you may want to provide a different router instance to nested pipeline middleware; in particular, this may occur when you want to segregate a pipeline by path . In such situations, you cannot reuse the UrlHelper instance, as a different router is in play; additionally, it may need to define a base path so that any generated URIs contain the full path information (since path segregation strips the specified path prefix from the request). To facilitate such scenarios, the factories for the UrlHelper and UrlHelperMiddleware allow providing optional arguments to allow varying behavior: UrlHelperFactory allows passing an alternate router service name. UrlHelperMiddlewareFactory allows passing an alternate URL helper service name. As an example, let us consider a module named Auth where we want to define a path-segregated middleware pipeline that has its own router and route middleware. We might define its dependency configuration as follows: namespace Auth; use Zend\\Expressive\\Helper\\UrlHelperFactory; use Zend\\Expressive\\Helper\\UrlHelperMiddlewareFactory; use Zend\\Expressive\\Router\\FastRouteRouter; use Zend\\Expressive\\Router\\Middleware\\RouteMiddlewareFactory; return [ 'dependencies' => [ 'factories' => [ // module-specific class name => factory Router::class => FastRouteRouterFactory::class, RouteMiddleware::class => new RouteMiddlewareFactory(Router::class), UrlHelper::class => new UrlHelperFactory('/auth', Router::class), UrlHelperMiddleware::class => new UrlHelperMiddlewareFactory(UrlHelper::class), ], ], ]; We could then create a path-segregated pipeline like the following: $app->pipe('/auth', [ \\Auth\\RouteMiddleware::class, // module-specific routing middleware! ImplicitHeadMiddleware::class, ImplicitOptionsMiddleware::class, MethodNotAllowedMiddleware::class, \\Auth\\UrlHelperMiddleware::class, // module-specific URL helper middleware! DispatchMiddleware::class, ]); Any handlers that the module-specific router routes to can then also compose the same UrlHelper instance via their factories: namespace Auth; use Psr\\Container\\ContainerInterface; class SomeHandlerFactory { public function __invoke(ContainerInterface $container) : SomeHandler { return new SomeHandler( $container->get(UrlHelper::class) // module-specific URL helper! ); } } This instance will then be properly configured to generate links using the module-specific router.","title":"Router-specific helpers"},{"location":"v3/features/middleware/implicit-methods-middleware/","text":"ImplicitHeadMiddleware and ImplicitOptionsMiddleware Expressive offers middleware for implicitly supporting HEAD and OPTIONS requests. The HTTP/1.1 specifications indicate that all server implementations must support HEAD requests for any given URI, and that they should support OPTIONS requests. To make this possible, we have added features to our routing layer, and middleware that can detect implicit support for these methods (i.e., the route was not registered explicitly with the method). Both middleware detailed here are provided in the zend-expressive-router package. ImplicitHeadMiddleware Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware provides support for handling HEAD requests to routed middleware when the route does not explicitly allow for the method. It should be registered between the routing and dispatch middleware. The zend-expressive-router package provides a factory for creating an instance, and registers it by default via its configuration provider. If you want to provide a response instance with additional headers or a custom status code, you will need to provide your own factory. Within your application pipeline, add the middleware between the routing and dispatch middleware, generally immediately following the routing middleware: $app->pipe(RouteMiddleware::class); $app->pipe(ImplicitHeadMiddleware::class); // ... $app->pipe(DispatchMiddleware::class); (Note: if you used the Expressive skeleton, this middleware is likely already in your pipeline.) When in place, it will do the following: If the request method is HEAD , AND the request composes a RouteResult attribute, AND the route result indicates a routing failure due to HTTP method used, THEN the middleware will return a response. In all other cases, it returns the result of delegating to the next middleware layer. When the middleware decides it can answer the request, one of two things may occur. First, if the route does not support the GET method, then the middleware returns an empty response. However, if GET is supported, it will dispatch the next layer, but with a GET request instead of HEAD ; additionally, it will inject the returned response with an empty response body before returning it. Detecting forwarded requests When the next layer is dispatched, the request will have an additional attribute, Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware::FORWARDED_HTTP_METHOD_ATTRIBUTE , with a value of HEAD . As such, you can check for this value in order to vary the headers returned if desired. ImplicitOptionsMiddleware Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware provides support for handling OPTIONS requests to routed middleware when the route does not explicitly allow for the method. Like the ImplicitHeadMiddleware , it should be registered between the routing and dispatch middleware. The zend-expressive-router package provides a factory for creating an instance, and registers it by default via its configuration provider. If you want to provide a response instance with additional headers or a custom status code, you will need to provide your own factory. Within your application pipeline, add the middleware between the routing and dispatch middleware, generally immediately following the routing middleware or ImplicitHeadMiddleware : $app->pipe(RouteMiddleware::class); $app->pipe(ImplicitOptionsMiddleware::class); // ... $app->pipe(DispatchMiddleware::class); (Note: if you used the Expressive skeleton, this middleware is likely already in your pipeline.) When in place, it will do the following: If the request method is OPTIONS , AND the request composes a RouteResult attribute, AND the route result indicates a routing failure due to HTTP method used, THEN the middleware will return a 200 response with an Allow header indicating methods the route allows. In all other cases, it returns the result of delegating to the next middleware layer. One thing to note: the allowed methods reported by the route and/or route result, and returned via the Allow header, may vary based on router implementation. In most cases, it should be an aggregate of all routes using the same path specification; however, it could be only the methods supported explicitly by the matched route.","title":"Implicit HEAD and OPTIONS Middleware"},{"location":"v3/features/middleware/implicit-methods-middleware/#implicitheadmiddleware-and-implicitoptionsmiddleware","text":"Expressive offers middleware for implicitly supporting HEAD and OPTIONS requests. The HTTP/1.1 specifications indicate that all server implementations must support HEAD requests for any given URI, and that they should support OPTIONS requests. To make this possible, we have added features to our routing layer, and middleware that can detect implicit support for these methods (i.e., the route was not registered explicitly with the method). Both middleware detailed here are provided in the zend-expressive-router package.","title":"ImplicitHeadMiddleware and ImplicitOptionsMiddleware"},{"location":"v3/features/middleware/implicit-methods-middleware/#implicitheadmiddleware","text":"Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware provides support for handling HEAD requests to routed middleware when the route does not explicitly allow for the method. It should be registered between the routing and dispatch middleware. The zend-expressive-router package provides a factory for creating an instance, and registers it by default via its configuration provider. If you want to provide a response instance with additional headers or a custom status code, you will need to provide your own factory. Within your application pipeline, add the middleware between the routing and dispatch middleware, generally immediately following the routing middleware: $app->pipe(RouteMiddleware::class); $app->pipe(ImplicitHeadMiddleware::class); // ... $app->pipe(DispatchMiddleware::class); (Note: if you used the Expressive skeleton, this middleware is likely already in your pipeline.) When in place, it will do the following: If the request method is HEAD , AND the request composes a RouteResult attribute, AND the route result indicates a routing failure due to HTTP method used, THEN the middleware will return a response. In all other cases, it returns the result of delegating to the next middleware layer. When the middleware decides it can answer the request, one of two things may occur. First, if the route does not support the GET method, then the middleware returns an empty response. However, if GET is supported, it will dispatch the next layer, but with a GET request instead of HEAD ; additionally, it will inject the returned response with an empty response body before returning it.","title":"ImplicitHeadMiddleware"},{"location":"v3/features/middleware/implicit-methods-middleware/#implicitoptionsmiddleware","text":"Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware provides support for handling OPTIONS requests to routed middleware when the route does not explicitly allow for the method. Like the ImplicitHeadMiddleware , it should be registered between the routing and dispatch middleware. The zend-expressive-router package provides a factory for creating an instance, and registers it by default via its configuration provider. If you want to provide a response instance with additional headers or a custom status code, you will need to provide your own factory. Within your application pipeline, add the middleware between the routing and dispatch middleware, generally immediately following the routing middleware or ImplicitHeadMiddleware : $app->pipe(RouteMiddleware::class); $app->pipe(ImplicitOptionsMiddleware::class); // ... $app->pipe(DispatchMiddleware::class); (Note: if you used the Expressive skeleton, this middleware is likely already in your pipeline.) When in place, it will do the following: If the request method is OPTIONS , AND the request composes a RouteResult attribute, AND the route result indicates a routing failure due to HTTP method used, THEN the middleware will return a 200 response with an Allow header indicating methods the route allows. In all other cases, it returns the result of delegating to the next middleware layer. One thing to note: the allowed methods reported by the route and/or route result, and returned via the Allow header, may vary based on router implementation. In most cases, it should be an aggregate of all routes using the same path specification; however, it could be only the methods supported explicitly by the matched route.","title":"ImplicitOptionsMiddleware"},{"location":"v3/features/middleware/method-not-allowed-middleware/","text":"Returning Method Not Allowed When the path matches, but the HTTP method does not, your application should return a 405 Method Not Allowed status in response. To enable that functionality, we provide Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware via the zend-expressive-router package. This middleware triggers when the following conditions occur: The request composes a RouteResult attribute (i.e., routing middleware has completed), AND the route result indicates a routing failure due to HTTP method used (i.e., RouteResult::isMethodFailure() returns true ). When these conditions occur, the middleware will generate a response: with a 405 Method Not Allowed status, AND an Allow header indicating the HTTP methods allowed. Pipe the middleware after the routing middleware; if using one or more of the implicit methods middleware , this middleware must be piped after them, as it will respond for any HTTP method! $app->pipe(RouteMiddleware::class); $app->pipe(ImplicitHeadMiddleware::class); $app->pipe(ImplicitOptionsMiddleware::class); $app->pipe(MethodNotAllowedMiddleware::class); // ... $app->pipe(DispatchMiddleware::class); (Note: if you used the Expressive skeleton, this middleware is likely already in your pipeline.)","title":"Returning Method Not Allowed"},{"location":"v3/features/middleware/method-not-allowed-middleware/#returning-method-not-allowed","text":"When the path matches, but the HTTP method does not, your application should return a 405 Method Not Allowed status in response. To enable that functionality, we provide Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware via the zend-expressive-router package. This middleware triggers when the following conditions occur: The request composes a RouteResult attribute (i.e., routing middleware has completed), AND the route result indicates a routing failure due to HTTP method used (i.e., RouteResult::isMethodFailure() returns true ). When these conditions occur, the middleware will generate a response: with a 405 Method Not Allowed status, AND an Allow header indicating the HTTP methods allowed. Pipe the middleware after the routing middleware; if using one or more of the implicit methods middleware , this middleware must be piped after them, as it will respond for any HTTP method! $app->pipe(RouteMiddleware::class); $app->pipe(ImplicitHeadMiddleware::class); $app->pipe(ImplicitOptionsMiddleware::class); $app->pipe(MethodNotAllowedMiddleware::class); // ... $app->pipe(DispatchMiddleware::class); (Note: if you used the Expressive skeleton, this middleware is likely already in your pipeline.)","title":"Returning Method Not Allowed"},{"location":"v3/features/middleware/routing-and-dispatch-middleware/","text":"Routing and Dispatch Middleware Within Expressive, we differentiate routing from dispatching . Routing is the act of matching a request to middleware; this typically involves inspecting the path and HTTP method used, but may also consider aspects such as headers, protocol, and more. Dispatching occurs after routing; it examines the results of routing, processing the middleware matched. Expressive goes so far as to separate the two actions into separate middleware . This is done to allow additional middleware to execute between them. For example, as you'll learn in the next two chapters, we can look for routing failures and answer HEAD and OPTIONS requests, or return a 405 Method Not Allowed status without ever hitting the dispatch middleware. When you read about the UrlHelper , you'll discover it has associated middleware that can receive the results of routing in order to facilitate URI generation. Keeping the two actions separated as distinct middleware provides a ton of power and flexibility in building your applications. We provide two middleware around these actions, each in the Zend\\Expressive\\Router\\Middleware namespace and provided by the zendframework/zend-expressive-router package: RouteMiddleware , which consumes a router in order to route a request. DispatchMiddleware , which dispatches the route result. RouteMiddleware Zend\\Expressive\\Router\\Middleware\\RouteMiddleware receives a Zend\\Expressive\\Router\\RouterInterface instance to its constructor. When it is processed, it passes the request to the router in order to receive a Zend\\Expressive\\Router\\RouteResult instance. When the result indicates a match, the middleware creates an updated request instance that includes each of the route match parameters as attributes. Regardless of the result, it will create an updated request instance that includes the result as the attribute Zend\\Expressive\\Router\\RouteResult . It then invokes the handler; all later middleware can then access the route result using: $result = $request->getAttribute(\\Zend\\Expressive\\Router\\RouteResult::class); DispatchMiddleware Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware defines only the process() method required by the PSR-15 MiddlewareInterface . Internally, it: checks for a RouteResult in the request, AND processes it, passing the request and handler. If there is no RouteResult , it delegates to the handler without doing anything else.","title":"Routing and Dispatch Middleware"},{"location":"v3/features/middleware/routing-and-dispatch-middleware/#routing-and-dispatch-middleware","text":"Within Expressive, we differentiate routing from dispatching . Routing is the act of matching a request to middleware; this typically involves inspecting the path and HTTP method used, but may also consider aspects such as headers, protocol, and more. Dispatching occurs after routing; it examines the results of routing, processing the middleware matched. Expressive goes so far as to separate the two actions into separate middleware . This is done to allow additional middleware to execute between them. For example, as you'll learn in the next two chapters, we can look for routing failures and answer HEAD and OPTIONS requests, or return a 405 Method Not Allowed status without ever hitting the dispatch middleware. When you read about the UrlHelper , you'll discover it has associated middleware that can receive the results of routing in order to facilitate URI generation. Keeping the two actions separated as distinct middleware provides a ton of power and flexibility in building your applications. We provide two middleware around these actions, each in the Zend\\Expressive\\Router\\Middleware namespace and provided by the zendframework/zend-expressive-router package: RouteMiddleware , which consumes a router in order to route a request. DispatchMiddleware , which dispatches the route result.","title":"Routing and Dispatch Middleware"},{"location":"v3/features/middleware/routing-and-dispatch-middleware/#routemiddleware","text":"Zend\\Expressive\\Router\\Middleware\\RouteMiddleware receives a Zend\\Expressive\\Router\\RouterInterface instance to its constructor. When it is processed, it passes the request to the router in order to receive a Zend\\Expressive\\Router\\RouteResult instance. When the result indicates a match, the middleware creates an updated request instance that includes each of the route match parameters as attributes. Regardless of the result, it will create an updated request instance that includes the result as the attribute Zend\\Expressive\\Router\\RouteResult . It then invokes the handler; all later middleware can then access the route result using: $result = $request->getAttribute(\\Zend\\Expressive\\Router\\RouteResult::class);","title":"RouteMiddleware"},{"location":"v3/features/middleware/routing-and-dispatch-middleware/#dispatchmiddleware","text":"Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware defines only the process() method required by the PSR-15 MiddlewareInterface . Internally, it: checks for a RouteResult in the request, AND processes it, passing the request and handler. If there is no RouteResult , it delegates to the handler without doing anything else.","title":"DispatchMiddleware"},{"location":"v3/features/router/aura/","text":"Using Aura.Router Aura.Router provides a plethora of methods for further configuring the router instance. One of the more useful configuration is to provide default specifications: A regular expression that applies the same for a given routing match: php // Parameters named \"id\" will only match digits by default: $router->addTokens([ 'id' => '\\d+', ]); A default parameter and/or its default value to always provide: php // mediatype defaults to \"application/xhtml+xml\" and will be available in all // requests: $router->addValues([ 'mediatype' => 'application/xhtml+xml', ]); Only match if secure (i.e., under HTTPS): php $router->setSecure(true); In order to specify these, you need access to the underlying Aura.Router instance, however, and the RouterInterface does not provide an accessor! The answer, then, is to use dependency injection. This can be done in two ways: programmatically, or via a factory to use in conjunction with your container instance. Installing Aura.Router To use Aura.Router, you will first need to install the Aura.Router integration: $ composer require zendframework/zend-expressive-aurarouter Quick Start At its simplest, you can instantiate a Zend\\Expressive\\Router\\AuraRouter instance with no arguments; it will create the underlying Aura.Router objects required and compose them for you: use Zend\\Expressive\\Router\\AuraRouter; $router = new AuraRouter(); Programmatic Creation If you need greater control over the Aura.Router setup and configuration, you can create the instances necessary and inject them into Zend\\Expressive\\Router\\AuraRouter during instantiation. <?php use Aura\\Router\\RouterFactory; use Zend\\Expressive\\AppFactory; use Zend\\Expressive\\Router\\AuraRouter as AuraBridge; $auraRouter = (new RouterFactory())->newInstance(); $auraRouter->setSecure(true); $auraRouter->addValues([ 'mediatype' => 'application/xhtml+xml', ]); $router = new AuraBridge($auraRouter); // First argument is the container to use, if not using the default; // second is the router. $app = AppFactory::create(null, $router); Piping the route middleware As a reminder, you will need to ensure that middleware is piped in the order in which it needs to be executed; please see the section on \"Controlling middleware execution order\" in the piping documentation . This is particularly salient when defining routes before injecting the router in the application instance! Factory-Driven Creation We provide and enable a factory for generating your Aura.Router instance when you install the zend-expressive-aurarouter package. This will generally serve your needs. If you want to provide custom setup or configuration, you can do so. In this example, we will be defining two factories: A factory to register as and generate an Aura\\Router\\Router instance. A factory registered as Zend\\Expressive\\Router\\RouterInterface , which creates and returns a Zend\\Expressive\\Router\\AuraRouter instance composing the Aura\\Router\\Router instance. The factory might look like this: // in src/App/Container/AuraRouterFactory.php: namespace App\\Container; use Aura\\Router\\RouterFactory; use Psr\\Container\\ContainerInterface; class AuraRouterFactory { /** * @param ContainerInterface $container * @return \\Aura\\Router\\Router */ public function __invoke(ContainerInterface $container) { $router = (new RouterFactory())->newInstance(); $router->setSecure(true); $router->addValues([ 'mediatype' => 'application/xhtml+xml', ]); return $router; } } // in src/App/Container/RouterFactory.php namespace App\\Container; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Router\\AuraRouter as AuraBridge; class RouterFactory { /** * @param ContainerInterface $container * @return AuraBridge */ public function __invoke(ContainerInterface $container) { return new AuraBridge($container->get('Aura\\Router\\Router')); } } From here, you will need to register your factories with your IoC container: // in a config/autoload/ file, or within a ConfigProvider class: return [ 'factories' => [ \\Aura\\Router\\Router::class => \\App\\Container\\AuraRouterFactory::class, \\Zend\\Expressive\\Router\\RouterInterface::class => \\App\\Container\\RouterFactory::class, ], ];","title":"Using Aura"},{"location":"v3/features/router/aura/#using-aurarouter","text":"Aura.Router provides a plethora of methods for further configuring the router instance. One of the more useful configuration is to provide default specifications: A regular expression that applies the same for a given routing match: php // Parameters named \"id\" will only match digits by default: $router->addTokens([ 'id' => '\\d+', ]); A default parameter and/or its default value to always provide: php // mediatype defaults to \"application/xhtml+xml\" and will be available in all // requests: $router->addValues([ 'mediatype' => 'application/xhtml+xml', ]); Only match if secure (i.e., under HTTPS): php $router->setSecure(true); In order to specify these, you need access to the underlying Aura.Router instance, however, and the RouterInterface does not provide an accessor! The answer, then, is to use dependency injection. This can be done in two ways: programmatically, or via a factory to use in conjunction with your container instance.","title":"Using Aura.Router"},{"location":"v3/features/router/aura/#installing-aurarouter","text":"To use Aura.Router, you will first need to install the Aura.Router integration: $ composer require zendframework/zend-expressive-aurarouter","title":"Installing Aura.Router"},{"location":"v3/features/router/aura/#quick-start","text":"At its simplest, you can instantiate a Zend\\Expressive\\Router\\AuraRouter instance with no arguments; it will create the underlying Aura.Router objects required and compose them for you: use Zend\\Expressive\\Router\\AuraRouter; $router = new AuraRouter();","title":"Quick Start"},{"location":"v3/features/router/aura/#programmatic-creation","text":"If you need greater control over the Aura.Router setup and configuration, you can create the instances necessary and inject them into Zend\\Expressive\\Router\\AuraRouter during instantiation. <?php use Aura\\Router\\RouterFactory; use Zend\\Expressive\\AppFactory; use Zend\\Expressive\\Router\\AuraRouter as AuraBridge; $auraRouter = (new RouterFactory())->newInstance(); $auraRouter->setSecure(true); $auraRouter->addValues([ 'mediatype' => 'application/xhtml+xml', ]); $router = new AuraBridge($auraRouter); // First argument is the container to use, if not using the default; // second is the router. $app = AppFactory::create(null, $router);","title":"Programmatic Creation"},{"location":"v3/features/router/aura/#factory-driven-creation","text":"We provide and enable a factory for generating your Aura.Router instance when you install the zend-expressive-aurarouter package. This will generally serve your needs. If you want to provide custom setup or configuration, you can do so. In this example, we will be defining two factories: A factory to register as and generate an Aura\\Router\\Router instance. A factory registered as Zend\\Expressive\\Router\\RouterInterface , which creates and returns a Zend\\Expressive\\Router\\AuraRouter instance composing the Aura\\Router\\Router instance. The factory might look like this: // in src/App/Container/AuraRouterFactory.php: namespace App\\Container; use Aura\\Router\\RouterFactory; use Psr\\Container\\ContainerInterface; class AuraRouterFactory { /** * @param ContainerInterface $container * @return \\Aura\\Router\\Router */ public function __invoke(ContainerInterface $container) { $router = (new RouterFactory())->newInstance(); $router->setSecure(true); $router->addValues([ 'mediatype' => 'application/xhtml+xml', ]); return $router; } } // in src/App/Container/RouterFactory.php namespace App\\Container; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Router\\AuraRouter as AuraBridge; class RouterFactory { /** * @param ContainerInterface $container * @return AuraBridge */ public function __invoke(ContainerInterface $container) { return new AuraBridge($container->get('Aura\\Router\\Router')); } } From here, you will need to register your factories with your IoC container: // in a config/autoload/ file, or within a ConfigProvider class: return [ 'factories' => [ \\Aura\\Router\\Router::class => \\App\\Container\\AuraRouterFactory::class, \\Zend\\Expressive\\Router\\RouterInterface::class => \\App\\Container\\RouterFactory::class, ], ];","title":"Factory-Driven Creation"},{"location":"v3/features/router/fast-route/","text":"Using FastRoute FastRoute provides a number of different combinations for how to both parse routes and match incoming requests against them. Internally, we use the standard route parser ( FastRoute\\RouterParser\\Std ) to parse routes, a RouteCollector to collect them, and the \"Group Count Based\" dispatcher to match incoming requests against routes. If you wish to use a different combination \u2014 e.g., to use the Group Position Based route matcher \u2014 you will need to create your own instances and inject them into the Zend\\Expressive\\Router\\FastRouteRouter class, at instantiation. The FastRouteRouter bridge class accepts two arguments at instantiation: A FastRoute\\RouteCollector instance A callable that will return a FastRoute\\Dispatcher\\RegexBasedAbstract instance. Injection can be done either programmatically or via a factory to use in conjunction with your container instance. Installing FastRoute To use FastRoute, you will first need to install the FastRoute integration: $ composer require zendframework/zend-expressive-fastroute The package provides a factory for the router, and wires it to your container by default. This will serve the majority of use cases. If you want to provide custom setup or configuration, you can do so. In this example, we will be defining three factories: A factory to register as and generate a FastRoute\\RouteCollector instance. A factory to register as FastRoute\\DispatcherFactory and return a callable factory that returns a RegexBasedAbstract instance. A factory registered as Zend\\Expressive\\Router\\RouterInterface , which creates and returns a Zend\\Expressive\\Router\\FastRouteRouter instance composing the two services. The factories might look like the following: <?php // in src/App/Container/FastRouteCollectorFactory.php: namespace App\\Container; use FastRoute\\RouteCollector; use FastRoute\\RouteGenerator; use FastRoute\\RouteParser\\Std as RouteParser; use Psr\\Container\\ContainerInterface; class FastRouteCollectorFactory { /** * @param ContainerInterface $container * @return RouteCollector */ public function __invoke(ContainerInterface $container) { return new RouteCollector( new RouteParser(), new RouteGenerator() ); } } // in src/App/Container/FastRouteDispatcherFactory.php: namespace App\\Container; use FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher; use Psr\\Container\\ContainerInterface; class FastRouteDispatcherFactory { /** * @param ContainerInterface $container * @return callable */ public function __invoke(ContainerInterface $container) { return function ($data) { return new FastRouteDispatcher($data); }; } } // in src/App/Container/RouterFactory.php namespace App\\Container; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge; class RouterFactory { /** * @param ContainerInterface $container * @return FastRouteBridge */ public function __invoke(ContainerInterface $container) { return new FastRouteBridge( $container->get(FastRoute\\RouteCollector::class), $container->get(FastRoute\\DispatcherFactory::class) ); } } From here, you will need to register your factories with your IoC container. // in a config/autoload/ file, or within a ConfigProvider class: return [ 'factories' => [ \\FastRoute\\RouteCollector::class => \\App\\Container\\FastRouteCollectorFactory::class, \\FastRoute\\DispatcherFactory::class => \\App\\Container\\FastRouteDispatcherFactory::class, \\Zend\\Expressive\\Router\\RouterInterface::class => \\App\\Container\\RouterFactory::class, ], ]; FastRoute caching support zend-expressive-fastroute comes with support for FastRoute native dispatch data caching. Enabling this feature requires changes to your configuration. Typically, router configuration occurs in config/autoload/routes.global.php ; as such, we will reference that file when indicating configuration changes. The changes required are: You will need to delegate creation of the router instance to a new factory. You will need to add a new configuration entry, $config['router']['fastroute'] . The options in this entry will be used by the factory to build the router instance in order to toggle caching support and to specify a custom cache file. As an example: // File config/autoload/routes.global.php return [ 'dependencies' => [ //.. 'invokables' => [ /* ... */ // Comment out or remove the following line: // Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouter::class, /* ... */ ], 'factories' => [ /* ... */ // Add this line; the specified factory now creates the router instance: Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouterFactory::class, /* ... */ ], ], // Add the following to enable caching support: 'router' => [ 'fastroute' => [ // Enable caching support: 'cache_enabled' => true, // Optional (but recommended) cache file path: 'cache_file' => 'data/cache/fastroute.php.cache', ], ], 'routes' => [ /* ... */ ], ] The FastRoute-specific caching options are as follows: cache_enabled (bool) is used to toggle caching support. It's advisable to enable caching in a production environment and leave it disabled for the development environment. Commenting or omitting this option is equivalent to having it set to false . We recommend enabling it in config/autoload/routes.global.php , and, in development, disabling it within config/autoload/routes.local.php or config/autoload/local.php . cache_file (string) is an optional parameter that represents the path of the dispatch data cache file. It can be provided as an absolute file path or as a path relative to the zend-expressive working directory. It defaults to data/cache/fastroute.php.cache , where data/cache/ is the cache directory defined within the zend-expressive skeleton application. An explicit absolute file path is recommended since the php include construct will skip searching the include_path and the current directory. If you choose a custom path, make sure that the directory exists and is writable by the owner of the PHP process. As with any other zend-expressive cached configuration, you will need to purge this file in order to enable any newly added route when FastRoute caching is enabled.","title":"Using FastRoute"},{"location":"v3/features/router/fast-route/#using-fastroute","text":"FastRoute provides a number of different combinations for how to both parse routes and match incoming requests against them. Internally, we use the standard route parser ( FastRoute\\RouterParser\\Std ) to parse routes, a RouteCollector to collect them, and the \"Group Count Based\" dispatcher to match incoming requests against routes. If you wish to use a different combination \u2014 e.g., to use the Group Position Based route matcher \u2014 you will need to create your own instances and inject them into the Zend\\Expressive\\Router\\FastRouteRouter class, at instantiation. The FastRouteRouter bridge class accepts two arguments at instantiation: A FastRoute\\RouteCollector instance A callable that will return a FastRoute\\Dispatcher\\RegexBasedAbstract instance. Injection can be done either programmatically or via a factory to use in conjunction with your container instance.","title":"Using FastRoute"},{"location":"v3/features/router/fast-route/#installing-fastroute","text":"To use FastRoute, you will first need to install the FastRoute integration: $ composer require zendframework/zend-expressive-fastroute The package provides a factory for the router, and wires it to your container by default. This will serve the majority of use cases. If you want to provide custom setup or configuration, you can do so. In this example, we will be defining three factories: A factory to register as and generate a FastRoute\\RouteCollector instance. A factory to register as FastRoute\\DispatcherFactory and return a callable factory that returns a RegexBasedAbstract instance. A factory registered as Zend\\Expressive\\Router\\RouterInterface , which creates and returns a Zend\\Expressive\\Router\\FastRouteRouter instance composing the two services. The factories might look like the following: <?php // in src/App/Container/FastRouteCollectorFactory.php: namespace App\\Container; use FastRoute\\RouteCollector; use FastRoute\\RouteGenerator; use FastRoute\\RouteParser\\Std as RouteParser; use Psr\\Container\\ContainerInterface; class FastRouteCollectorFactory { /** * @param ContainerInterface $container * @return RouteCollector */ public function __invoke(ContainerInterface $container) { return new RouteCollector( new RouteParser(), new RouteGenerator() ); } } // in src/App/Container/FastRouteDispatcherFactory.php: namespace App\\Container; use FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher; use Psr\\Container\\ContainerInterface; class FastRouteDispatcherFactory { /** * @param ContainerInterface $container * @return callable */ public function __invoke(ContainerInterface $container) { return function ($data) { return new FastRouteDispatcher($data); }; } } // in src/App/Container/RouterFactory.php namespace App\\Container; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge; class RouterFactory { /** * @param ContainerInterface $container * @return FastRouteBridge */ public function __invoke(ContainerInterface $container) { return new FastRouteBridge( $container->get(FastRoute\\RouteCollector::class), $container->get(FastRoute\\DispatcherFactory::class) ); } } From here, you will need to register your factories with your IoC container. // in a config/autoload/ file, or within a ConfigProvider class: return [ 'factories' => [ \\FastRoute\\RouteCollector::class => \\App\\Container\\FastRouteCollectorFactory::class, \\FastRoute\\DispatcherFactory::class => \\App\\Container\\FastRouteDispatcherFactory::class, \\Zend\\Expressive\\Router\\RouterInterface::class => \\App\\Container\\RouterFactory::class, ], ];","title":"Installing FastRoute"},{"location":"v3/features/router/interface/","text":"Routing Interface Expressive defines Zend\\Expressive\\Router\\RouterInterface , which is used by the Zend\\Expressive\\Router\\RouteMiddleware \u2014 as well as the Zend\\Expressive\\Router\\RouteCollector consumed by Zend\\Expressive\\Application \u2014 in order to provide dynamic routing capabilities to middleware. The interface serves as an abstraction to allow routers with varying capabilities to be used with an application. The interface is defined as follows: namespace Zend\\Expressive\\Router; use Psr\\Http\\Message\\ServerRequestInterface as Request; /** * Interface defining required router capabilities. */ interface RouterInterface { /** * Add a route. * * This method adds a route against which the underlying implementation may * match. Implementations MUST aggregate route instances, but MUST NOT use * the details to inject the underlying router until `match()` and/or * `generateUri()` is called. This is required to allow consumers to * modify route instances before matching (e.g., to provide route options, * inject a name, etc.). * * The method MUST raise Exception\\RuntimeException if called after either `match()` * or `generateUri()` have already been called, to ensure integrity of the * router between invocations of either of those methods. * * @throws Exception\\RuntimeException when called after match() or * generateUri() have been called. */ public function addRoute(Route $route) : void; /** * Match a request against the known routes. * * Implementations will aggregate required information from the provided * request instance, and pass them to the underlying router implementation; * when done, they will then marshal a `RouteResult` instance indicating * the results of the matching operation and return it to the caller. */ public function match(Request $request) : RouteResult; /** * Generate a URI from the named route. * * Takes the named route and any substitutions, and attempts to generate a * URI from it. Additional router-dependent options may be passed. * * The URI generated MUST NOT be escaped. If you wish to escape any part of * the URI, this should be performed afterwards; consider passing the URI * to league/uri to encode it. * * @see https://github.com/auraphp/Aura.Router/blob/3.x/docs/generating-paths.md * @see https://docs.zendframework.com/zend-router/routing/ * @throws Exception\\RuntimeException if unable to generate the given URI. */ public function generateUri(string $name, array $substitutions = [], array $options = []) : string; } Developers may create and use their own implementations. We recommend registering your implementation as the service Zend\\Expressive\\Router\\RouterInterface in your container to ensure other factories provided by zend-expressive will receive your custom service. Implementors should also read the following sections detailing the Route and RouteResult classes, to ensure that their implementations interoperate correctly. Routes Routes are defined via Zend\\Expressive\\Router\\Route , and aggregate the following information: Path to match. Middleware to use when the route is matched. The value must implement Psr\\Http\\Server\\MiddlewareInterface . HTTP methods allowed for the route; if none are provided, all are assumed. Optionally, a name by which to reference the route. The Route class has the following signature: namespace Zend\\Expressive\\Router; use Fig\\Http\\Message\\RequestMethodInterface as RequestMethod; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class Route implements MiddlewareInterface { public const HTTP_METHOD_ANY = null; public const HTTP_METHOD_SEPARATOR = ':'; /** * @param string $path Path to match. * @param MiddlewareInterface $middleware Middleware to use when this route is matched. * @param null|string[] $methods Allowed HTTP methods; defaults to HTTP_METHOD_ANY. * @param null|string $name the route name */ public function __construct( string $path, MiddlewareInterface $middleware, array $methods = self::HTTP_METHOD_ANY, string $name = null ); /** * Proxies to the middleware composed during instantiation. */ public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface; public function getPath() : string; /** * Set the route name. */ public function setName(string $name) : void; public function getName() : string; public function getMiddleware() : MiddlewareInterface; /** * @return null|string[] Returns HTTP_METHOD_ANY or array of allowed methods. */ public function getAllowedMethods() : ?array; /** * Indicate whether the specified method is allowed by the route. * * @param string $method HTTP method to test. */ public function allowsMethod(string $method) : bool; public function setOptions(array $options) : void; public function getOptions() : array; } Typically, developers will use the route() method of either Zend\\Expressive\\Router\\PathBasedRoutingMiddleware or Zend\\Expressive\\Application (or one of the HTTP-specific routing methods of either class) to create routes, and will not need to interact with Route instances. Additionally, when working with RouteResult instances, you may pull the Route instance from that in order to obtain data about the matched route. Matching and RouteResults Internally, routing middleware calls on RouterInterface::match() , passing it the current request instance. This allows implementations to pull what they may need from the request in order to perform their routing logic; for example, they may need the request method, the URI path, the value of the HTTPS server variable, etc. Implementations are expected to return a Zend\\Expressive\\Router\\RouteResult instance, which is then injected as a request attribute under the name Zend\\Expressive\\Router\\RouteResult when passing processing of the request to the provided handler. Additionally, in the event of success, it will pull any matched parameters from the result and inject them as request attributes as well. Dispatch middleware can then retrieve the route result from the request and process it, passing the route result its own request and handler. The zend-expressive-router package also provides a number of middleware geared towards handling failed results which can be placed between routing and dispatch middleware: Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware checks to see if the route failures was due to the HTTP method, and, if so, return a 405 response with an appropriate Allow header. ( read more ) Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware checks to see if a routing failure was due to a route match using a HEAD request, and will then dispatch the appropriate route via GET request, and inject an empty body into the returned response. ( read more ) Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware checks to see if a routing failure was due to a route match using a OPTIONS request; if so, it will return a 200 response with an appropriate Allow header. ( read more ) The RouteResult signature is as follows: namespace Zend\\Expressive\\Router; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class RouteResult implements MiddlewareInterface { /** * Create an instance representing a route succes from the matching route. * * @param array $params Parameters associated with the matched route, if any. */ public static function fromRoute(Route $route, array $params = []) : self; /** * Create an instance representing a route failure. * * @param null|array $methods HTTP methods allowed for the current URI, if any. * null is equivalent to allowing any HTTP method; empty array means none. */ public static function fromRouteFailure(?array $methods) : self; /** * Process the result as middleware. * * If the result represents a failure, it passes handling to the handler. * * Otherwise, it processes the composed middleware using the provide request * and handler. */ public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface; /** * Does the result represent successful routing? */ public function isSuccess() : bool; /** * Retrieve the route that resulted in the route match. * * @return false|null|Route false if representing a routing failure; * null if not created via fromRoute(); Route instance otherwise. */ public function getMatchedRoute(); /** * Retrieve the matched route name, if possible. * * If this result represents a failure, return false; otherwise, return the * matched route name. * * @return false|string */ public function getMatchedRouteName(); /** * Returns the matched params. */ public function getMatchedParams() : array; /** * Is this a routing failure result? */ public function isFailure() : bool; /** * Does the result represent failure to route due to HTTP method? */ public function isMethodFailure() : bool; /** * Retrieve the allowed methods for the route failure. * * @return string[] HTTP methods allowed */ public function getAllowedMethods() : array; } Typically, only those implementing routers will interact with this class.","title":"Routing Interface"},{"location":"v3/features/router/interface/#routing-interface","text":"Expressive defines Zend\\Expressive\\Router\\RouterInterface , which is used by the Zend\\Expressive\\Router\\RouteMiddleware \u2014 as well as the Zend\\Expressive\\Router\\RouteCollector consumed by Zend\\Expressive\\Application \u2014 in order to provide dynamic routing capabilities to middleware. The interface serves as an abstraction to allow routers with varying capabilities to be used with an application. The interface is defined as follows: namespace Zend\\Expressive\\Router; use Psr\\Http\\Message\\ServerRequestInterface as Request; /** * Interface defining required router capabilities. */ interface RouterInterface { /** * Add a route. * * This method adds a route against which the underlying implementation may * match. Implementations MUST aggregate route instances, but MUST NOT use * the details to inject the underlying router until `match()` and/or * `generateUri()` is called. This is required to allow consumers to * modify route instances before matching (e.g., to provide route options, * inject a name, etc.). * * The method MUST raise Exception\\RuntimeException if called after either `match()` * or `generateUri()` have already been called, to ensure integrity of the * router between invocations of either of those methods. * * @throws Exception\\RuntimeException when called after match() or * generateUri() have been called. */ public function addRoute(Route $route) : void; /** * Match a request against the known routes. * * Implementations will aggregate required information from the provided * request instance, and pass them to the underlying router implementation; * when done, they will then marshal a `RouteResult` instance indicating * the results of the matching operation and return it to the caller. */ public function match(Request $request) : RouteResult; /** * Generate a URI from the named route. * * Takes the named route and any substitutions, and attempts to generate a * URI from it. Additional router-dependent options may be passed. * * The URI generated MUST NOT be escaped. If you wish to escape any part of * the URI, this should be performed afterwards; consider passing the URI * to league/uri to encode it. * * @see https://github.com/auraphp/Aura.Router/blob/3.x/docs/generating-paths.md * @see https://docs.zendframework.com/zend-router/routing/ * @throws Exception\\RuntimeException if unable to generate the given URI. */ public function generateUri(string $name, array $substitutions = [], array $options = []) : string; } Developers may create and use their own implementations. We recommend registering your implementation as the service Zend\\Expressive\\Router\\RouterInterface in your container to ensure other factories provided by zend-expressive will receive your custom service. Implementors should also read the following sections detailing the Route and RouteResult classes, to ensure that their implementations interoperate correctly.","title":"Routing Interface"},{"location":"v3/features/router/interface/#routes","text":"Routes are defined via Zend\\Expressive\\Router\\Route , and aggregate the following information: Path to match. Middleware to use when the route is matched. The value must implement Psr\\Http\\Server\\MiddlewareInterface . HTTP methods allowed for the route; if none are provided, all are assumed. Optionally, a name by which to reference the route. The Route class has the following signature: namespace Zend\\Expressive\\Router; use Fig\\Http\\Message\\RequestMethodInterface as RequestMethod; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class Route implements MiddlewareInterface { public const HTTP_METHOD_ANY = null; public const HTTP_METHOD_SEPARATOR = ':'; /** * @param string $path Path to match. * @param MiddlewareInterface $middleware Middleware to use when this route is matched. * @param null|string[] $methods Allowed HTTP methods; defaults to HTTP_METHOD_ANY. * @param null|string $name the route name */ public function __construct( string $path, MiddlewareInterface $middleware, array $methods = self::HTTP_METHOD_ANY, string $name = null ); /** * Proxies to the middleware composed during instantiation. */ public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface; public function getPath() : string; /** * Set the route name. */ public function setName(string $name) : void; public function getName() : string; public function getMiddleware() : MiddlewareInterface; /** * @return null|string[] Returns HTTP_METHOD_ANY or array of allowed methods. */ public function getAllowedMethods() : ?array; /** * Indicate whether the specified method is allowed by the route. * * @param string $method HTTP method to test. */ public function allowsMethod(string $method) : bool; public function setOptions(array $options) : void; public function getOptions() : array; } Typically, developers will use the route() method of either Zend\\Expressive\\Router\\PathBasedRoutingMiddleware or Zend\\Expressive\\Application (or one of the HTTP-specific routing methods of either class) to create routes, and will not need to interact with Route instances. Additionally, when working with RouteResult instances, you may pull the Route instance from that in order to obtain data about the matched route.","title":"Routes"},{"location":"v3/features/router/interface/#matching-and-routeresults","text":"Internally, routing middleware calls on RouterInterface::match() , passing it the current request instance. This allows implementations to pull what they may need from the request in order to perform their routing logic; for example, they may need the request method, the URI path, the value of the HTTPS server variable, etc. Implementations are expected to return a Zend\\Expressive\\Router\\RouteResult instance, which is then injected as a request attribute under the name Zend\\Expressive\\Router\\RouteResult when passing processing of the request to the provided handler. Additionally, in the event of success, it will pull any matched parameters from the result and inject them as request attributes as well. Dispatch middleware can then retrieve the route result from the request and process it, passing the route result its own request and handler. The zend-expressive-router package also provides a number of middleware geared towards handling failed results which can be placed between routing and dispatch middleware: Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware checks to see if the route failures was due to the HTTP method, and, if so, return a 405 response with an appropriate Allow header. ( read more ) Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware checks to see if a routing failure was due to a route match using a HEAD request, and will then dispatch the appropriate route via GET request, and inject an empty body into the returned response. ( read more ) Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware checks to see if a routing failure was due to a route match using a OPTIONS request; if so, it will return a 200 response with an appropriate Allow header. ( read more ) The RouteResult signature is as follows: namespace Zend\\Expressive\\Router; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; class RouteResult implements MiddlewareInterface { /** * Create an instance representing a route succes from the matching route. * * @param array $params Parameters associated with the matched route, if any. */ public static function fromRoute(Route $route, array $params = []) : self; /** * Create an instance representing a route failure. * * @param null|array $methods HTTP methods allowed for the current URI, if any. * null is equivalent to allowing any HTTP method; empty array means none. */ public static function fromRouteFailure(?array $methods) : self; /** * Process the result as middleware. * * If the result represents a failure, it passes handling to the handler. * * Otherwise, it processes the composed middleware using the provide request * and handler. */ public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface; /** * Does the result represent successful routing? */ public function isSuccess() : bool; /** * Retrieve the route that resulted in the route match. * * @return false|null|Route false if representing a routing failure; * null if not created via fromRoute(); Route instance otherwise. */ public function getMatchedRoute(); /** * Retrieve the matched route name, if possible. * * If this result represents a failure, return false; otherwise, return the * matched route name. * * @return false|string */ public function getMatchedRouteName(); /** * Returns the matched params. */ public function getMatchedParams() : array; /** * Is this a routing failure result? */ public function isFailure() : bool; /** * Does the result represent failure to route due to HTTP method? */ public function isMethodFailure() : bool; /** * Retrieve the allowed methods for the route failure. * * @return string[] HTTP methods allowed */ public function getAllowedMethods() : array; } Typically, only those implementing routers will interact with this class.","title":"Matching and RouteResults"},{"location":"v3/features/router/intro/","text":"Routing One fundamental feature of zend-expressive is that it provides mechanisms for implementing dynamic routing, a feature required in most modern web applications. As an example, you may want to allow matching both a resource, as well as individual items of that resource: /books might return a collection of books /books/zend-expressive might return the individual book identified by \"zend-expressive\". Expressive does not provide routing on its own; you must choose a routing adapter that implements Zend\\Expressive\\Router\\RouterInterface . The router is consumed by Zend\\Expressive\\Router\\Middleware\\RouteMiddleware as well as Zend\\Expressive\\Router\\RouteCollector , the latter of which is composed in the Application instance. This allows you to choose the router with the capabilities that best match your own needs, while still providing a common abstraction for defining and aggregating routes and their related middleware. Retrieving matched parameters Routing enables the ability to match dynamic path segments (or other criteria). Typically, you will want access to the values matched. The routing middleware injects any matched parameters as returned by the underlying router into the request as attributes . In the example above, let's assume the route was defined as /books/:id , where id is the name of the dynamic segment. This means that in the middleware invoked for this route, you can fetch the id attribute to discover what was matched: $id = $request->getAttribute('id'); Retrieving the matched route When routing is complete, the routing middleware injects a Zend\\Expressive\\Router\\RouteResult instance as a request attribute, using that class name as the attribute name. The RouteResult instance provides you access to the following: Matching status via the methods $result->isSuccess() , $result->isFailure() , and $result->isMethodFailure() (indicating a path-based match that did not match an allowed HTTP method). Allowed HTTP methods, via $result->getAllowedMethods() (for either success or failure). The matched Zend\\Expressive\\Router\\Route instance, via $result->getMatchedRoute() (successful matches only). The matched route name, via $result->getMatchedRouteName() (or via $result->getMatchedRoute()->getName() ; successful matches only). Matched parameters, via $result->getMatchedParams() (as noted above, these are also each injected as discrete request attributes; successful matches only). As an example, you could use middleware similar to the following to return a 403 response if routing was successful, but no Authorization header is present: use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\EmptyResponse; use Zend\\Expressive\\Router\\RouteResult; function ($request, RequestHandlerInterface $handler) use ($routesRequiringAuthorization, $validator) { if (! ($result = $request->getAttribute(RouteResult::class, false))) { // No route result present; delegate to next middleware return $handler->handle($request); } if (! in_array($result->getMatchedRouteName(), $routesRequiringAuthorization, true)) { // Not a route requiring authorization return $handler->handle($request); } $header = $request->getHeaderLine('Authorization'); if (! $validator($header)) { return new EmptyResponse(403); } return $handler->handle($request); } Note that the first step is to determine if we have a RouteResult ; if we do not have one, we should either delegate to the next middleware, or return some sort of response (generally a 404). In the case of Expressive, a later middleware will generate the 404 response for us, so we can safely delegate. URI generation Because routers have knowledge of the various paths they can match, they are also typically used within applications to generate URIs to other application resources. Expressive provides this capability in the RouterInterface , either delegating to the underlying router implementations or providing a compatible implementation of its own. At it's most basic level, you call the generateUri() method with a route name and any substitutions you want to make: $uri = $router->generateUri('book', ['id' => 'zend-expressive']); Some routers may support providing options during URI generation. Starting in zend-expressive-router 2.0, which ships with Expressive starting with version 2.0, you may also pass a third argument to generateUri() , an array of router options: $uri = $router->generateUri('book', ['id' => 'zend-expressive'], [ 'translator' => $translator, 'text_domain' => $currentLocale, ]); Supported implementations Expressive currently ships with adapters for the following routers: Aura.Router FastRoute zend-mvc Router","title":"Introduction"},{"location":"v3/features/router/intro/#routing","text":"One fundamental feature of zend-expressive is that it provides mechanisms for implementing dynamic routing, a feature required in most modern web applications. As an example, you may want to allow matching both a resource, as well as individual items of that resource: /books might return a collection of books /books/zend-expressive might return the individual book identified by \"zend-expressive\". Expressive does not provide routing on its own; you must choose a routing adapter that implements Zend\\Expressive\\Router\\RouterInterface . The router is consumed by Zend\\Expressive\\Router\\Middleware\\RouteMiddleware as well as Zend\\Expressive\\Router\\RouteCollector , the latter of which is composed in the Application instance. This allows you to choose the router with the capabilities that best match your own needs, while still providing a common abstraction for defining and aggregating routes and their related middleware.","title":"Routing"},{"location":"v3/features/router/intro/#retrieving-matched-parameters","text":"Routing enables the ability to match dynamic path segments (or other criteria). Typically, you will want access to the values matched. The routing middleware injects any matched parameters as returned by the underlying router into the request as attributes . In the example above, let's assume the route was defined as /books/:id , where id is the name of the dynamic segment. This means that in the middleware invoked for this route, you can fetch the id attribute to discover what was matched: $id = $request->getAttribute('id');","title":"Retrieving matched parameters"},{"location":"v3/features/router/intro/#retrieving-the-matched-route","text":"When routing is complete, the routing middleware injects a Zend\\Expressive\\Router\\RouteResult instance as a request attribute, using that class name as the attribute name. The RouteResult instance provides you access to the following: Matching status via the methods $result->isSuccess() , $result->isFailure() , and $result->isMethodFailure() (indicating a path-based match that did not match an allowed HTTP method). Allowed HTTP methods, via $result->getAllowedMethods() (for either success or failure). The matched Zend\\Expressive\\Router\\Route instance, via $result->getMatchedRoute() (successful matches only). The matched route name, via $result->getMatchedRouteName() (or via $result->getMatchedRoute()->getName() ; successful matches only). Matched parameters, via $result->getMatchedParams() (as noted above, these are also each injected as discrete request attributes; successful matches only). As an example, you could use middleware similar to the following to return a 403 response if routing was successful, but no Authorization header is present: use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\EmptyResponse; use Zend\\Expressive\\Router\\RouteResult; function ($request, RequestHandlerInterface $handler) use ($routesRequiringAuthorization, $validator) { if (! ($result = $request->getAttribute(RouteResult::class, false))) { // No route result present; delegate to next middleware return $handler->handle($request); } if (! in_array($result->getMatchedRouteName(), $routesRequiringAuthorization, true)) { // Not a route requiring authorization return $handler->handle($request); } $header = $request->getHeaderLine('Authorization'); if (! $validator($header)) { return new EmptyResponse(403); } return $handler->handle($request); } Note that the first step is to determine if we have a RouteResult ; if we do not have one, we should either delegate to the next middleware, or return some sort of response (generally a 404). In the case of Expressive, a later middleware will generate the 404 response for us, so we can safely delegate.","title":"Retrieving the matched route"},{"location":"v3/features/router/intro/#uri-generation","text":"Because routers have knowledge of the various paths they can match, they are also typically used within applications to generate URIs to other application resources. Expressive provides this capability in the RouterInterface , either delegating to the underlying router implementations or providing a compatible implementation of its own. At it's most basic level, you call the generateUri() method with a route name and any substitutions you want to make: $uri = $router->generateUri('book', ['id' => 'zend-expressive']); Some routers may support providing options during URI generation. Starting in zend-expressive-router 2.0, which ships with Expressive starting with version 2.0, you may also pass a third argument to generateUri() , an array of router options: $uri = $router->generateUri('book', ['id' => 'zend-expressive'], [ 'translator' => $translator, 'text_domain' => $currentLocale, ]);","title":"URI generation"},{"location":"v3/features/router/intro/#supported-implementations","text":"Expressive currently ships with adapters for the following routers: Aura.Router FastRoute zend-mvc Router","title":"Supported implementations"},{"location":"v3/features/router/piping/","text":"Routing vs Piping Expressive provides two mechanisms for adding middleware to your application: piping, which is a foundation feature of the underlying zend-stratigility implementation. routing, which is an additional feature provided by zend-expressive. Piping zend-stratigility provides a mechanism termed piping for composing middleware in an application. When you pipe middleware to the application, it is added to a queue, and dequeued in order until a middleware returns a response instance. Expressive adds the ability to segregate middleware to a specific path; as an example: $app->pipe('/api', $apiMiddleware); will execute $apiMiddleware only if the path matches /api ; otherwise, it will skip over that middleware. This path segregation, however, is limited: it will only match literal paths. This is done purposefully, to provide excellent baseline performance, and to prevent feature creep in the library. Path segregation Internally, when Application::pipe() detects two arguments, it calls Zend\\Stratigility\\path() using the two arguments in order to create a Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator instance; this latter is what performs the actual path checking. Expressive uses and exposes piping to users, with one addition: middleware may be specified by service name or an array of service names, and zend-expressive will lazy-load the service only when the middleware is invoked . In order to accomplish the lazy-loading, zend-expressive wraps the calls to fetch and dispatch the middleware inside a Zend\\Expressive\\Middleware\\LazyLoadingMiddleware instance; as such, there is no overhead to utilizing service-based middleware until it is dispatched . Routing Routing is the process of discovering values from the incoming request based on defined criteria. That criteria might look like: /book/:id (ZF2) /book/{id} (Aura.Router) /book/{id:\\d+} (FastRoute) In each of the above, if the router determines that the request matches the criteria, it will indicate: the route that matched the id parameter was matched, and the value matched Most routers allow you to define arbitrarily complex rules, and many even allow you to define: default values for unmatched parameters criteria for evaluating a match (such as a regular expression) additional criteria to meet (such as SSL usage, allowed query string variables, etc.) As such, routing is more powerful than the literal path matching used when piping, but it is also more costly (though routers such as FastRoute largely make such performance issues moot). When to Pipe In Expressive, we recommend that you pipe middleware in the following circumstances: It should (potentially) run on every execution. Examples for such usage include: Logging requests Performing content negotiation Handling cookies Error handling. Application segregation. You can write re-usable middleware, potentially even based off of Expressive, that contains its own routing logic, and compose it such that it only executes if it matches a sub-path. When to Route Use routing when: Your middleware is reacting to a given path. You want to use dynamic routing. You want to restrict usage of middleware to specific HTTP methods. You want to be able to generate URIs to your middleware. The above cover most use cases; in other words, most middleware should be added to the application as routed middleware . Controlling middleware execution order As noted in the earlier section on piping, piped middleware is queued , meaning it has a FIFO (\"first in, first out\") execution order. Additionally, zend-expressive's routing and dispatch capabilities are themselves implemented as piped middleware. To ensure your middleware is piped correctly, keep in mind the following: If middleware should execute on every request , pipe it early. Pipe routing and dispatch middleware using their dedicated application methods (more on this below), optionally with middleware between them to further shape application flow. Pipe middleware guaranteed to return a response (such as a \"not found\" handler or similar) last . As an example: $app->pipe(OriginalMessages::class); $app->pipe(ServerUrlMiddleware::class); $app->pipe(XClacksOverhead::class); $app->pipe(ErrorHandler::class); $app->pipe(RouteMiddleware::class); $app->pipe(ImplicitHeadMiddleware::class); $app->pipe(ImplicitOptionsMiddleware::class); $app->pipe(MethodNotAllowedMiddleware::class); $app->pipe(UrlHelperMiddleware::class); $app->pipe(AuthorizationCheck::class); $app->pipe(DispatchMiddleware::class); $app->pipe(NotFoundHandler::class);","title":"Routing vs Piping"},{"location":"v3/features/router/piping/#routing-vs-piping","text":"Expressive provides two mechanisms for adding middleware to your application: piping, which is a foundation feature of the underlying zend-stratigility implementation. routing, which is an additional feature provided by zend-expressive.","title":"Routing vs Piping"},{"location":"v3/features/router/piping/#piping","text":"zend-stratigility provides a mechanism termed piping for composing middleware in an application. When you pipe middleware to the application, it is added to a queue, and dequeued in order until a middleware returns a response instance. Expressive adds the ability to segregate middleware to a specific path; as an example: $app->pipe('/api', $apiMiddleware); will execute $apiMiddleware only if the path matches /api ; otherwise, it will skip over that middleware. This path segregation, however, is limited: it will only match literal paths. This is done purposefully, to provide excellent baseline performance, and to prevent feature creep in the library.","title":"Piping"},{"location":"v3/features/router/piping/#routing","text":"Routing is the process of discovering values from the incoming request based on defined criteria. That criteria might look like: /book/:id (ZF2) /book/{id} (Aura.Router) /book/{id:\\d+} (FastRoute) In each of the above, if the router determines that the request matches the criteria, it will indicate: the route that matched the id parameter was matched, and the value matched Most routers allow you to define arbitrarily complex rules, and many even allow you to define: default values for unmatched parameters criteria for evaluating a match (such as a regular expression) additional criteria to meet (such as SSL usage, allowed query string variables, etc.) As such, routing is more powerful than the literal path matching used when piping, but it is also more costly (though routers such as FastRoute largely make such performance issues moot).","title":"Routing"},{"location":"v3/features/router/piping/#when-to-pipe","text":"In Expressive, we recommend that you pipe middleware in the following circumstances: It should (potentially) run on every execution. Examples for such usage include: Logging requests Performing content negotiation Handling cookies Error handling. Application segregation. You can write re-usable middleware, potentially even based off of Expressive, that contains its own routing logic, and compose it such that it only executes if it matches a sub-path.","title":"When to Pipe"},{"location":"v3/features/router/piping/#when-to-route","text":"Use routing when: Your middleware is reacting to a given path. You want to use dynamic routing. You want to restrict usage of middleware to specific HTTP methods. You want to be able to generate URIs to your middleware. The above cover most use cases; in other words, most middleware should be added to the application as routed middleware .","title":"When to Route"},{"location":"v3/features/router/piping/#controlling-middleware-execution-order","text":"As noted in the earlier section on piping, piped middleware is queued , meaning it has a FIFO (\"first in, first out\") execution order. Additionally, zend-expressive's routing and dispatch capabilities are themselves implemented as piped middleware. To ensure your middleware is piped correctly, keep in mind the following: If middleware should execute on every request , pipe it early. Pipe routing and dispatch middleware using their dedicated application methods (more on this below), optionally with middleware between them to further shape application flow. Pipe middleware guaranteed to return a response (such as a \"not found\" handler or similar) last . As an example: $app->pipe(OriginalMessages::class); $app->pipe(ServerUrlMiddleware::class); $app->pipe(XClacksOverhead::class); $app->pipe(ErrorHandler::class); $app->pipe(RouteMiddleware::class); $app->pipe(ImplicitHeadMiddleware::class); $app->pipe(ImplicitOptionsMiddleware::class); $app->pipe(MethodNotAllowedMiddleware::class); $app->pipe(UrlHelperMiddleware::class); $app->pipe(AuthorizationCheck::class); $app->pipe(DispatchMiddleware::class); $app->pipe(NotFoundHandler::class);","title":"Controlling middleware execution order"},{"location":"v3/features/router/route-collector/","text":"The Route Collector Zend\\Expressive\\Router\\RouteCollector is a class that exists to help you create path-based routes, while simultaneously injecting them into a router instance. It composes a Zend\\Expressive\\Router\\RouterInterface instance via its constructor, and provides the following methods: route() any() delete() get() patch() post() put() These methods allow you to add routes to the underlying router. The last five all reference the HTTP method the generated route will answer to, and each have the same signature: public function {method}( string $path, Psr\\Http\\Server\\MiddlewareInterface $middleware, string $name = null ) : Zend\\Expressive\\Router\\Route The any() method has the same signature, but indicates that it will answer to any HTTP method. Finally, route() has the following signature: public function route( string $path, Psr\\Http\\Server\\MiddlewareInterface $middleware, array $methods = null, string $name = null ) : Zend\\Expressive\\Router\\Route A null value for the $methods indicates any HTTP method is allowed. Zend\\Expressive\\Application composes an instance of this class and proxies to it when any of the above methods are called. Zend\\Expressive\\Router\\Middleware\\RouteMiddleware , by default, composes the same router instance, allowing it to honor the definitions created.","title":"The Route Collector"},{"location":"v3/features/router/route-collector/#the-route-collector","text":"Zend\\Expressive\\Router\\RouteCollector is a class that exists to help you create path-based routes, while simultaneously injecting them into a router instance. It composes a Zend\\Expressive\\Router\\RouterInterface instance via its constructor, and provides the following methods: route() any() delete() get() patch() post() put() These methods allow you to add routes to the underlying router. The last five all reference the HTTP method the generated route will answer to, and each have the same signature: public function {method}( string $path, Psr\\Http\\Server\\MiddlewareInterface $middleware, string $name = null ) : Zend\\Expressive\\Router\\Route The any() method has the same signature, but indicates that it will answer to any HTTP method. Finally, route() has the following signature: public function route( string $path, Psr\\Http\\Server\\MiddlewareInterface $middleware, array $methods = null, string $name = null ) : Zend\\Expressive\\Router\\Route A null value for the $methods indicates any HTTP method is allowed. Zend\\Expressive\\Application composes an instance of this class and proxies to it when any of the above methods are called. Zend\\Expressive\\Router\\Middleware\\RouteMiddleware , by default, composes the same router instance, allowing it to honor the definitions created.","title":"The Route Collector"},{"location":"v3/features/router/uri-generation/","text":"URI Generation One aspect of the Zend\\Expressive\\Router\\RouterInterface is that it provides a generateUri() method. This method accepts a route name, and optionally an associative array of substitutions to use in the generated URI (e.g., if the URI has any named placeholders). You may also pass router-specific options to use during URI generation as a third argument. Naming routes By default, routes use a combination of the path and HTTP methods supported as the name: If you call route() with no HTTP methods, the name is the literal path with no changes. php $app->route('/foo', $middleware); // \"foo\" If you call get() , post() , put() , patch() , or delete() , the name will be the literal path, followed by a caret ( ^ ), followed by the uppercase HTTP method name: php $app->get('/foo', $middleware); // \"foo^GET\" Alternately, these methods return a Route instance, and you can set the name on it: php $app->get('/foo', $middleware)->setName('foo'); // \"foo\" If you call route() and specify a list of HTTP methods accepted, the name will be the literal path, followed by a caret ( ^ ), followed by a colon ( : )-separated list of the uppercase HTTP method names, in the order in which they were added. php $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\" Like the HTTP-specific methods, route() also returns a Route instance, and you can set the name on it: php $route = $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\" $route->setName('foo'); // \"foo\" Clearly, this can become difficult to remember. As such, Expressive offers the ability to specify a custom string for the route name as an additional, optional argument to any of the above: $app->route('/foo', $middleware, 'foo'); // 'foo' $app->get('/foo/:id', $middleware, 'foo-item'); // 'foo-item' $app->route('/foo', $middleware, ['GET', 'POST'], 'foo-collection'); // 'foo-collection' As noted above, these methods also return Route instances, allowing you to set the name after-the-fact; this is particularly useful with the route() method, where you may want to omit the HTTP methods if any HTTP method is allowed: $app->route('/foo', $middleware)->setName('foo'); // 'foo' We recommend that if you plan on generating URIs for given routes, you provide a custom name. Names must be unique In order for the URI generation functionality to work, routes must be uniquely named. This can be tricky when you use the same route path for multiple routes: $$$$FENCED_CODE_BLOCK_5e03bde9eb1644.00704939 You could, of course, name the second route \"create-book\" or similar, but you then have multiple names capable of generating the same URI. Since URIs do not have a concept of HTTP method built in, we recommend naming either the route matching GET or the first route in the sequence: $$$$FENCED_CODE_BLOCK_5e03bde9eb1757.95465075 Generating URIs Once you know the name of a URI you wish to generate, you can do so from the router instance: $uri = $router->generateUri('foo-item', ['id' => 'bar']); // \"/foo/bar\" You can omit the second argument if no substitutions are necessary. Compose the router For this to work, you'll need to compose the router instance in any class that requires the URI generation facility. Inject the Zend\\Expressive\\Router\\RouterInterface service in these situations. Alternately, use the UrlHelper instead.","title":"URI Generation"},{"location":"v3/features/router/uri-generation/#uri-generation","text":"One aspect of the Zend\\Expressive\\Router\\RouterInterface is that it provides a generateUri() method. This method accepts a route name, and optionally an associative array of substitutions to use in the generated URI (e.g., if the URI has any named placeholders). You may also pass router-specific options to use during URI generation as a third argument.","title":"URI Generation"},{"location":"v3/features/router/uri-generation/#naming-routes","text":"By default, routes use a combination of the path and HTTP methods supported as the name: If you call route() with no HTTP methods, the name is the literal path with no changes. php $app->route('/foo', $middleware); // \"foo\" If you call get() , post() , put() , patch() , or delete() , the name will be the literal path, followed by a caret ( ^ ), followed by the uppercase HTTP method name: php $app->get('/foo', $middleware); // \"foo^GET\" Alternately, these methods return a Route instance, and you can set the name on it: php $app->get('/foo', $middleware)->setName('foo'); // \"foo\" If you call route() and specify a list of HTTP methods accepted, the name will be the literal path, followed by a caret ( ^ ), followed by a colon ( : )-separated list of the uppercase HTTP method names, in the order in which they were added. php $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\" Like the HTTP-specific methods, route() also returns a Route instance, and you can set the name on it: php $route = $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\" $route->setName('foo'); // \"foo\" Clearly, this can become difficult to remember. As such, Expressive offers the ability to specify a custom string for the route name as an additional, optional argument to any of the above: $app->route('/foo', $middleware, 'foo'); // 'foo' $app->get('/foo/:id', $middleware, 'foo-item'); // 'foo-item' $app->route('/foo', $middleware, ['GET', 'POST'], 'foo-collection'); // 'foo-collection' As noted above, these methods also return Route instances, allowing you to set the name after-the-fact; this is particularly useful with the route() method, where you may want to omit the HTTP methods if any HTTP method is allowed: $app->route('/foo', $middleware)->setName('foo'); // 'foo' We recommend that if you plan on generating URIs for given routes, you provide a custom name.","title":"Naming routes"},{"location":"v3/features/router/uri-generation/#generating-uris","text":"Once you know the name of a URI you wish to generate, you can do so from the router instance: $uri = $router->generateUri('foo-item', ['id' => 'bar']); // \"/foo/bar\" You can omit the second argument if no substitutions are necessary.","title":"Generating URIs"},{"location":"v3/features/router/zf2/","text":"Using zend-router zend-router provides several router implementations used for ZF2+ applications; the default is Zend\\Router\\Http\\TreeRouteStack , which can compose a number of different routes of differing types in order to perform routing. The ZF2 bridge we provide, Zend\\Expressive\\Router\\ZendRouter , uses the TreeRouteStack , and injects Segment routes to it; these are in turn injected with Method routes, and a special \"method not allowed\" route at negative priority to enable us to distinguish between failure to match the path and failure to match the HTTP method. The TreeRouteStack offers some unique features: Route \"prototypes\". These are essentially like child routes that must also match in order for a given route to match. These are useful for implementing functionality such as ensuring the request comes in over HTTPS, or over a specific subdomain. Base URL functionality. If a base URL is injected, comparisons will be relative to that URL. This is mostly unnecessary with Stratigility-based middleware, but could solve some edge cases. To specify these, you need access to the underlying TreeRouteStack instance, however, and the RouterInterface does not provide an accessor! The answer, then, is to use dependency injection. This can be done in two ways: programmatically, or via a factory to use in conjunction with your container instance. Installing the ZF2 Router To use the ZF2 router, you will need to install the zend-mvc router integration: $ composer require zendframework/zend-expressive-zendrouter The package provides both a factory for the router, and a ConfigProvider that wires the router with your application. Advanced configuration If you want to provide custom setup or configuration, you can do so. In this example, we will be defining two factories: A factory to register as and generate an Zend\\Router\\Http\\TreeRouteStack instance. A factory registered as Zend\\Expressive\\Router\\RouterInterface , which creates and returns a Zend\\Expressive\\Router\\ZendRouter instance composing the Zend\\Mvc\\Router\\Http\\TreeRouteStack instance. The factories might look like the following: // in src/App/Container/TreeRouteStackFactory.php: namespace App\\Container; use Psr\\Container\\ContainerInterface; use Zend\\Http\\Router\\TreeRouteStack; class TreeRouteStackFactory { /** * @param ContainerInterface $container * @return TreeRouteStack */ public function __invoke(ContainerInterface $container) { $router = new TreeRouteStack(); $router->addPrototypes(/* ... */); $router->setBaseUrl(/* ... */); return $router; } } // in src/App/Container/RouterFactory.php namespace App\\Container; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge; class RouterFactory { /** * @param ContainerInterface $container * @return Zf2Bridge */ public function __invoke(ContainerInterface $container) { return new Zf2Bridge($container->get(Zend\\Mvc\\Router\\Http\\TreeRouteStack::class)); } } From here, you will need to register your factories with your IoC container. // in a config/autoload/ file, or within a ConfigProvider class: return [ 'factories' => [ \\Zend\\Router\\Http\\TreeRouteStack::class => App\\Container\\TreeRouteStackFactory::class, \\Zend\\Expressive\\Router\\RouterInterface::class => App\\Container\\RouterFactory::class, ], ];","title":"Using zend-router"},{"location":"v3/features/router/zf2/#using-zend-router","text":"zend-router provides several router implementations used for ZF2+ applications; the default is Zend\\Router\\Http\\TreeRouteStack , which can compose a number of different routes of differing types in order to perform routing. The ZF2 bridge we provide, Zend\\Expressive\\Router\\ZendRouter , uses the TreeRouteStack , and injects Segment routes to it; these are in turn injected with Method routes, and a special \"method not allowed\" route at negative priority to enable us to distinguish between failure to match the path and failure to match the HTTP method. The TreeRouteStack offers some unique features: Route \"prototypes\". These are essentially like child routes that must also match in order for a given route to match. These are useful for implementing functionality such as ensuring the request comes in over HTTPS, or over a specific subdomain. Base URL functionality. If a base URL is injected, comparisons will be relative to that URL. This is mostly unnecessary with Stratigility-based middleware, but could solve some edge cases. To specify these, you need access to the underlying TreeRouteStack instance, however, and the RouterInterface does not provide an accessor! The answer, then, is to use dependency injection. This can be done in two ways: programmatically, or via a factory to use in conjunction with your container instance.","title":"Using zend-router"},{"location":"v3/features/router/zf2/#installing-the-zf2-router","text":"To use the ZF2 router, you will need to install the zend-mvc router integration: $ composer require zendframework/zend-expressive-zendrouter The package provides both a factory for the router, and a ConfigProvider that wires the router with your application.","title":"Installing the ZF2 Router"},{"location":"v3/features/router/zf2/#advanced-configuration","text":"If you want to provide custom setup or configuration, you can do so. In this example, we will be defining two factories: A factory to register as and generate an Zend\\Router\\Http\\TreeRouteStack instance. A factory registered as Zend\\Expressive\\Router\\RouterInterface , which creates and returns a Zend\\Expressive\\Router\\ZendRouter instance composing the Zend\\Mvc\\Router\\Http\\TreeRouteStack instance. The factories might look like the following: // in src/App/Container/TreeRouteStackFactory.php: namespace App\\Container; use Psr\\Container\\ContainerInterface; use Zend\\Http\\Router\\TreeRouteStack; class TreeRouteStackFactory { /** * @param ContainerInterface $container * @return TreeRouteStack */ public function __invoke(ContainerInterface $container) { $router = new TreeRouteStack(); $router->addPrototypes(/* ... */); $router->setBaseUrl(/* ... */); return $router; } } // in src/App/Container/RouterFactory.php namespace App\\Container; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge; class RouterFactory { /** * @param ContainerInterface $container * @return Zf2Bridge */ public function __invoke(ContainerInterface $container) { return new Zf2Bridge($container->get(Zend\\Mvc\\Router\\Http\\TreeRouteStack::class)); } } From here, you will need to register your factories with your IoC container. // in a config/autoload/ file, or within a ConfigProvider class: return [ 'factories' => [ \\Zend\\Router\\Http\\TreeRouteStack::class => App\\Container\\TreeRouteStackFactory::class, \\Zend\\Expressive\\Router\\RouterInterface::class => App\\Container\\RouterFactory::class, ], ];","title":"Advanced configuration"},{"location":"v3/features/template/interface/","text":"The Template Renderer Interface Expressive defines Zend\\Expressive\\Template\\TemplateRendererInterface , which can be injected into middleware in order to create templated response bodies. The interface is defined as follows: namespace Zend\\Expressive\\Template; interface TemplateRendererInterface { public const TEMPLATE_ALL = '*'; /** * Render a template, optionally with parameters. * * Implementations MUST support the `namespace::template` naming convention, * and allow omitting the filename extension. * * @param array|object $params */ public function render(string $name, $params = []) : string; /** * Add a template path to the engine. * * Adds a template path, with optional namespace the templates in that path * provide. */ public function addPath(string $path, string $namespace = null) : void; /** * Retrieve configured paths from the engine. * * @return TemplatePath[] */ public function getPaths() : array; /** * Add a default parameter to use with a template. * * Use this method to provide a default parameter to use when a template is * rendered. The parameter may be overridden by providing it when calling * `render()`, or by calling this method again with a null value. * * The parameter will be specific to the template name provided. To make * the parameter available to any template, pass the TEMPLATE_ALL constant * for the template name. * * If the default parameter existed previously, subsequent invocations with * the same template name and parameter name will overwrite. * * @param string $templateName Name of template to which the param applies; * use TEMPLATE_ALL to apply to all templates. * @param mixed $value */ public function addDefaultParam(string $templateName, string $param, $value) : void; } Namespaces Unfortunately, namespace syntax varies between different template engine implementations. As an example: Plates uses the syntax namespace::template . Twig uses the syntax @namespace/template . zend-view does not natively support namespaces, though custom resolvers can provide the functionality. To make different engines compatible, we require implementations to support the syntax namespace::template (where namespace:: is optional) when rendering. Additionally, we require that engines allow omitting the filename suffix. When using a TemplateRendererInterface implementation, feel free to use namespaced templates, and to omit the filename suffix; this will make your code portable and allow it to use alternate template engines. Paths Most template engines and implementations will require that you specify one or more paths to templates; these are then used when resolving a template name to the actual template. You may use the addPath() method to do so: $renderer->addPath('templates'); Template engines adapted for zend-expressive are also required to allow namespacing templates; when adding a path, you specify the template namespace that it fulfills, and the engine will only return a template from that path if the namespace provided matches the namespace for the path. // Resolves to a path registered with the namespace \"error\"; // this example is specific to the Plates engine. $content = $renderer->render('error::404'); You can provide a namespace when registering a path via an optional second argument: // Registers the \"error\" namespace to the path \"templates/error/\" $renderer->addPath('templates/error/', 'error'); Rendering To render a template, call the render() method. This method requires the name of a template as the first argument: $content = $renderer->render('foo'); You can specify a namespaced template using the syntax namespace::template ; the template segment of the template name may use additional directory separators when necessary. One key reason to use templates is to dynamically provide data to inject in the template. You may do so by passing either an associative array or an object as the second argument to render() : $content = $renderer->render('message', [ 'greeting' => 'Hello', 'recipient' => 'World', ]); It is up to the underlying template engine to determine how to perform the injections. Default params The TemplateRendererInterface defines the method addDefaultParam() . This method can be used to specify default parameters to use when rendering a template. The signature is: public function addDefaultParam($templateName, $param, $value) If you want a parameter to be used for every template, you can specify the constant TemplateRendererInterface::TEMPLATE_ALL for the $templateName parameter. When rendering, parameters are considered in the following order, with later items having precedence over earlier ones: Default parameters specified for all templates. Default parameters specified for the template specified at rendering. Parameters specified when rendering. As an example, if we did the following: $renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'foo', 'bar'); $renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'bar', 'baz'); $renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'baz', 'bat'); $renderer->addDefaultParam('example', 'foo', 'template default foo'); $renderer->addDefaultParam('example', 'bar', 'template default bar'); $content = $renderer->render('example', [ 'foo' => 'override', ]); Then we can expect the following substitutions will occur when rendering: References to the \"foo\" variable will contain \"override\". References to the \"bar\" variable will contain \"template default bar\". References to the \"baz\" variable will contain \"bat\". Support for default params The support for default params will often be renderer-specific. The reason is because the render() signature does not specify a type for $params , in order to allow passing alternative arguments such as view models. In such cases, the implementation will indicate its behavior when default parameters are specified, but a given $params argument does not support it. At the time of writing, each of the Plates, Twig, and zend-view implementations support the feature.","title":"Template Renderer Interface"},{"location":"v3/features/template/interface/#the-template-renderer-interface","text":"Expressive defines Zend\\Expressive\\Template\\TemplateRendererInterface , which can be injected into middleware in order to create templated response bodies. The interface is defined as follows: namespace Zend\\Expressive\\Template; interface TemplateRendererInterface { public const TEMPLATE_ALL = '*'; /** * Render a template, optionally with parameters. * * Implementations MUST support the `namespace::template` naming convention, * and allow omitting the filename extension. * * @param array|object $params */ public function render(string $name, $params = []) : string; /** * Add a template path to the engine. * * Adds a template path, with optional namespace the templates in that path * provide. */ public function addPath(string $path, string $namespace = null) : void; /** * Retrieve configured paths from the engine. * * @return TemplatePath[] */ public function getPaths() : array; /** * Add a default parameter to use with a template. * * Use this method to provide a default parameter to use when a template is * rendered. The parameter may be overridden by providing it when calling * `render()`, or by calling this method again with a null value. * * The parameter will be specific to the template name provided. To make * the parameter available to any template, pass the TEMPLATE_ALL constant * for the template name. * * If the default parameter existed previously, subsequent invocations with * the same template name and parameter name will overwrite. * * @param string $templateName Name of template to which the param applies; * use TEMPLATE_ALL to apply to all templates. * @param mixed $value */ public function addDefaultParam(string $templateName, string $param, $value) : void; }","title":"The Template Renderer Interface"},{"location":"v3/features/template/interface/#paths","text":"Most template engines and implementations will require that you specify one or more paths to templates; these are then used when resolving a template name to the actual template. You may use the addPath() method to do so: $renderer->addPath('templates'); Template engines adapted for zend-expressive are also required to allow namespacing templates; when adding a path, you specify the template namespace that it fulfills, and the engine will only return a template from that path if the namespace provided matches the namespace for the path. // Resolves to a path registered with the namespace \"error\"; // this example is specific to the Plates engine. $content = $renderer->render('error::404'); You can provide a namespace when registering a path via an optional second argument: // Registers the \"error\" namespace to the path \"templates/error/\" $renderer->addPath('templates/error/', 'error');","title":"Paths"},{"location":"v3/features/template/interface/#rendering","text":"To render a template, call the render() method. This method requires the name of a template as the first argument: $content = $renderer->render('foo'); You can specify a namespaced template using the syntax namespace::template ; the template segment of the template name may use additional directory separators when necessary. One key reason to use templates is to dynamically provide data to inject in the template. You may do so by passing either an associative array or an object as the second argument to render() : $content = $renderer->render('message', [ 'greeting' => 'Hello', 'recipient' => 'World', ]); It is up to the underlying template engine to determine how to perform the injections.","title":"Rendering"},{"location":"v3/features/template/intro/","text":"Templating By default, no middleware or handlers in Expressive are templated. We do not even provide a default templating engine, as the choice of templating engine is often very specific to the project and/or organization. We do, however, provide abstraction for templating via the interface Zend\\Expressive\\Template\\TemplateRendererInterface , which allows you to write middleware that is engine-agnostic. For Expressive, this means: All adapters MUST support template namespacing. Namespaces MUST be referenced using the notation namespace::template when rendering. Adapters MUST allow rendering templates that omit the extension; they will, of course, resolve to whatever default extension they require (or as configured). Adapters SHOULD allow passing an extension in the template name, but how that is handled is left up to the adapter. Adapters SHOULD abstract layout capabilities. Many templating systems provide this out of the box, or similar, compatible features such as template inheritance. This should be transparent to end-users; they should be able to simply render a template and assume it has the full content to return. In this documentation, we'll detail the features of this interface, the various implementations we provide, and how you can configure, inject, and consume templating in your middleware. We currently support: Plates Twig zend-view Each has an associated container factory; details are found in the factories documentation .","title":"Introduction"},{"location":"v3/features/template/intro/#templating","text":"By default, no middleware or handlers in Expressive are templated. We do not even provide a default templating engine, as the choice of templating engine is often very specific to the project and/or organization. We do, however, provide abstraction for templating via the interface Zend\\Expressive\\Template\\TemplateRendererInterface , which allows you to write middleware that is engine-agnostic. For Expressive, this means: All adapters MUST support template namespacing. Namespaces MUST be referenced using the notation namespace::template when rendering. Adapters MUST allow rendering templates that omit the extension; they will, of course, resolve to whatever default extension they require (or as configured). Adapters SHOULD allow passing an extension in the template name, but how that is handled is left up to the adapter. Adapters SHOULD abstract layout capabilities. Many templating systems provide this out of the box, or similar, compatible features such as template inheritance. This should be transparent to end-users; they should be able to simply render a template and assume it has the full content to return. In this documentation, we'll detail the features of this interface, the various implementations we provide, and how you can configure, inject, and consume templating in your middleware. We currently support: Plates Twig zend-view Each has an associated container factory; details are found in the factories documentation .","title":"Templating"},{"location":"v3/features/template/plates/","text":"Using Plates Plates is a native PHP template system maintained by The League of Extraordinary Packages . it provides: Layout facilities. Template inheritance. Helpers for escaping, and the ability to provide custom helper extensions. We provide a TemplateRendererInterface wrapper for Plates via Zend\\Expressive\\Plates\\PlatesRenderer . Installing Plates To use the Plates wrapper, you must install the Plates integration: $ composer require zendframework/zend-expressive-platesrenderer Using the wrapper If instantiated without arguments, Zend\\Expressive\\Plates\\PlatesRenderer will create an instance of the Plates engine, which it will then proxy to. use Zend\\Expressive\\Plates\\PlatesRenderer; $renderer = new PlatesRenderer(); Alternately, you can instantiate and configure the engine yourself, and pass it to the Zend\\Expressive\\Plates\\PlatesRenderer constructor: use League\\Plates\\Engine as PlatesEngine; use Zend\\Expressive\\Plates\\PlatesRenderer; // Create the engine instance: $plates = new PlatesEngine(); // Configure it: $plates->addFolder('error', 'templates/error/'); $plates->loadExtension(new CustomExtension()); // Inject: $renderer = new PlatesRenderer($plates); Configuration and Factory zend-expressive-platesrenderer ships with the factory Zend\\Expressive\\Plates\\PlatesRendererFactory , which will both create the Plates engine instance, and the PlatesRenderer instance. If you are using zend-component-installer , this will be automatically wired for you during installation. The factory looks for the following configuration in the config service, using any it finds: // In config/autoload/templates.global.php: return [ 'plates' => [ 'extensions' => [ // string service names or class names of Plates extensions ], ], 'templates' => [ 'extension' => 'phtml', // change this if you use a different file // extension for templates 'paths' => [ // namespace => [paths] pairs ], ], ]; The factory will also inject two extensions by default, Zend\\Expressive\\Plates\\Extension\\UrlExtension and Zend\\Expressive\\Plates\\Extension\\EscaperExtension , both listed in more detail below. Shipped Extensions zend-expressive-plates provides the following extensions. UrlExtension Zend\\Expressive\\Plates\\Extension\\UrlExtension composes each of the UrlHelper and ServerUrlHelper , and provides the following template methods: public function url( string $routeName = null, array $routeParams = [], array $queryParams = [], ?string $fragmentIdentifier = null, array $options = [] ) : string; public function serverurl(string $path = null) : string; // Since zend-expressive-platesrender 2.1.0: public function route() : ?Zend\\Expressive\\Router\\RouteResult As an example: <a href=\"<?= $this->url('blog', ['stub' => $this->stub]) ?>\">A blog post on this</a> <?php $routing = $this->route(); $routingIsValid = $routing && $routing->isSuccess(); $route = $routingIsValid ? $routing->getMatchedRouteName() : 'blog'; $routeParams = $routingIsValid ? $routing->getMatchedParams() : []; ?> <a href=\"<?= $this->url($route, $routeParams) ?>\">For more information</a> EscaperExtension Zend\\Expressive\\Plates\\Extension\\EscaperExtension proxies to functionality provided in the zend-escaper package. It looks for the following configuration in the config service: // In config/autoload/templates.global.php: return [ 'plates' => [ 'encoding' => ?string, // character encoding of generated content ], ]; By default it assumes UTF-8 for the encoding. The extension registers the following template methods: public function escapeHtml(string $html) : string; public function escapeHtmlAttr(string $attribute) : string; public function escapeJs(string $js) : string; public function escapeCss(string $css) : string; public function escapeUrl(string $url) : string; As examples: <html> <head> <meta name=\"author\" content=\"<?= $this->escapeHtmlAttr($this->author) ?>\"> <link rel=\"alternative\" href=\"<?= $this->escapeUrl($this->alternative) ?>\"> <style><?= $this->escapeCss($this->styles) ?></style> <script><?= $this->escapeJs($this->script) ?></script> </head> <body> <?= $this->escapeHtml($this->content) ?> </body> </html>","title":"Using Plates"},{"location":"v3/features/template/plates/#using-plates","text":"Plates is a native PHP template system maintained by The League of Extraordinary Packages . it provides: Layout facilities. Template inheritance. Helpers for escaping, and the ability to provide custom helper extensions. We provide a TemplateRendererInterface wrapper for Plates via Zend\\Expressive\\Plates\\PlatesRenderer .","title":"Using Plates"},{"location":"v3/features/template/plates/#installing-plates","text":"To use the Plates wrapper, you must install the Plates integration: $ composer require zendframework/zend-expressive-platesrenderer","title":"Installing Plates"},{"location":"v3/features/template/plates/#using-the-wrapper","text":"If instantiated without arguments, Zend\\Expressive\\Plates\\PlatesRenderer will create an instance of the Plates engine, which it will then proxy to. use Zend\\Expressive\\Plates\\PlatesRenderer; $renderer = new PlatesRenderer(); Alternately, you can instantiate and configure the engine yourself, and pass it to the Zend\\Expressive\\Plates\\PlatesRenderer constructor: use League\\Plates\\Engine as PlatesEngine; use Zend\\Expressive\\Plates\\PlatesRenderer; // Create the engine instance: $plates = new PlatesEngine(); // Configure it: $plates->addFolder('error', 'templates/error/'); $plates->loadExtension(new CustomExtension()); // Inject: $renderer = new PlatesRenderer($plates);","title":"Using the wrapper"},{"location":"v3/features/template/plates/#configuration-and-factory","text":"zend-expressive-platesrenderer ships with the factory Zend\\Expressive\\Plates\\PlatesRendererFactory , which will both create the Plates engine instance, and the PlatesRenderer instance. If you are using zend-component-installer , this will be automatically wired for you during installation. The factory looks for the following configuration in the config service, using any it finds: // In config/autoload/templates.global.php: return [ 'plates' => [ 'extensions' => [ // string service names or class names of Plates extensions ], ], 'templates' => [ 'extension' => 'phtml', // change this if you use a different file // extension for templates 'paths' => [ // namespace => [paths] pairs ], ], ]; The factory will also inject two extensions by default, Zend\\Expressive\\Plates\\Extension\\UrlExtension and Zend\\Expressive\\Plates\\Extension\\EscaperExtension , both listed in more detail below.","title":"Configuration and Factory"},{"location":"v3/features/template/plates/#shipped-extensions","text":"zend-expressive-plates provides the following extensions.","title":"Shipped Extensions"},{"location":"v3/features/template/request-handlers/","text":"Templated request handlers The primary use case for templating is within request handlers, to provide templated responses. To do this, you will: Inject an instance of Zend\\Expressive\\Template\\TemplateRendererInterface into your request handler. Potentially add paths to the templating instance. Render a template. Add the results of rendering to your response. Injecting a TemplateRendererInterface We encourage the use of dependency injection. As such, we recommend writing your request handler to accept the TemplateRendererInterface via either the constructor or a setter. As an example: namespace Acme\\Blog; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class EntryHandler implements RequestHandlerInterface { private $templateRenderer; public function __construct(TemplateRendererInterface $renderer) { $this->templateRenderer = $renderer; } public function handler(ServerRequestInterface $request) : ResponseInterface { // ... } } This will necessitate having a factory for your request handler: namespace Acme\\Blog\\Container; use Acme\\Blog\\EntryHandler; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class EntryHandlerFactory { public function __invoke(ContainerInterface $container) { return new EntryHandler( $container->get(TemplateRendererInterface::class) ); } } And, of course, you'll need to tell your container to use the factory; see the container documentation for more information on how you might accomplish that. Consuming templates Now that we have the templating engine injected into our request handler, we can consume it. Most often, we will want to render a template, optionally with substitutions to pass to it. This will typically look like the following: namespace Acme\\Blog; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Template\\TemplateRendererInterface; class EntryHandler implements RequestHandlerInterface { private $templateRenderer; public function __construct(TemplateRendererInterface $renderer) { $this->templateRenderer = $renderer; } public function handle(ServerRequestInterface $request) : ResponseInterface { // do some work... return new HtmlResponse( $this->templateRenderer->render('blog::entry', [ 'entry' => $entry, ]) ); } }","title":"Templated Request Handlers"},{"location":"v3/features/template/request-handlers/#templated-request-handlers","text":"The primary use case for templating is within request handlers, to provide templated responses. To do this, you will: Inject an instance of Zend\\Expressive\\Template\\TemplateRendererInterface into your request handler. Potentially add paths to the templating instance. Render a template. Add the results of rendering to your response.","title":"Templated request handlers"},{"location":"v3/features/template/request-handlers/#injecting-a-templaterendererinterface","text":"We encourage the use of dependency injection. As such, we recommend writing your request handler to accept the TemplateRendererInterface via either the constructor or a setter. As an example: namespace Acme\\Blog; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class EntryHandler implements RequestHandlerInterface { private $templateRenderer; public function __construct(TemplateRendererInterface $renderer) { $this->templateRenderer = $renderer; } public function handler(ServerRequestInterface $request) : ResponseInterface { // ... } } This will necessitate having a factory for your request handler: namespace Acme\\Blog\\Container; use Acme\\Blog\\EntryHandler; use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; class EntryHandlerFactory { public function __invoke(ContainerInterface $container) { return new EntryHandler( $container->get(TemplateRendererInterface::class) ); } } And, of course, you'll need to tell your container to use the factory; see the container documentation for more information on how you might accomplish that.","title":"Injecting a TemplateRendererInterface"},{"location":"v3/features/template/request-handlers/#consuming-templates","text":"Now that we have the templating engine injected into our request handler, we can consume it. Most often, we will want to render a template, optionally with substitutions to pass to it. This will typically look like the following: namespace Acme\\Blog; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Template\\TemplateRendererInterface; class EntryHandler implements RequestHandlerInterface { private $templateRenderer; public function __construct(TemplateRendererInterface $renderer) { $this->templateRenderer = $renderer; } public function handle(ServerRequestInterface $request) : ResponseInterface { // do some work... return new HtmlResponse( $this->templateRenderer->render('blog::entry', [ 'entry' => $entry, ]) ); } }","title":"Consuming templates"},{"location":"v3/features/template/twig/","text":"Using Twig Twig is a template language and engine provided as a standalone component by SensioLabs. It provides: Layout facilities. Template inheritance. Helpers for escaping, and the ability to provide custom helper extensions. We provide a TemplateRendererInterface wrapper for Twig via Zend\\Expressive\\Twig\\TwigRenderer . Installing Twig To use the Twig wrapper, you must first install the Twig integration: $ composer require zendframework/zend-expressive-twigrenderer Using the wrapper If instantiated without arguments, Zend\\Expressive\\Twig\\TwigRenderer will create an instance of the Twig engine, which it will then proxy to. use Zend\\Expressive\\Twig\\TwigRenderer; $renderer = new TwigRenderer(); Alternately, you can instantiate and configure the engine yourself, and pass it to the Zend\\Expressive\\Twig\\TwigRenderer constructor: use Twig_Environment; use Twig_Loader_Array; use Zend\\Expressive\\Twig\\TwigRenderer; // Create the engine instance: $loader = new Twig_Loader_Array(include 'config/templates.php'); $twig = new Twig_Environment($loader); // Configure it: $twig->addExtension(new CustomExtension()); $twig->loadExtension(new CustomExtension(); // Inject: $renderer = new TwigRenderer($twig); Included extensions and functions The included Twig extension adds support for url generation. The extension is automatically activated if the UrlHelper and ServerUrlHelper are registered with the container. The following template functions are exposed: path : Render the relative path for a given route and parameters. If there is no route, it returns the current path. twig {{ path('article_show', {'id': '3'}) }} Generates: /article/3 url : Render the absolute url for a given route with its route parameters, query string arguments, and fragment. If there is no route, it returns the current url. twig {{ url('article_show', {'id': '3'}, {'foo': 'bar'}, 'fragment') }} Generates: http://example.com/article/3?foo=bar#fragment absolute_url : Render the absolute url from a given path. If the path is empty, it returns the current url. twig {{ absolute_url('path/to/something') }} Generates: http://example.com/path/to/something asset Render an (optionally versioned) asset url. twig {{ asset('path/to/asset/name.ext', version=3) }} Generates: path/to/asset/name.ext?v=3 To get the absolute url for an asset: twig {{ absolute_url(asset('path/to/asset/name.ext', version=3)) }} Generates: http://example.com/path/to/asset/name.ext?v=3 Configuration The following details configuration specific to Twig, as consumed by the TwigRendererFactory : return [ 'templates' => [ 'extension' => 'file extension used by templates; defaults to html.twig', 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ], 'twig' => [ 'autoescape' => 'html', // Auto-escaping strategy [html|js|css|url|false] 'cache_dir' => 'path to cached templates', 'assets_url' => 'base URL for assets', 'assets_version' => 'base version for assets', 'extensions' => [ // extension service names or instances ], 'globals' => [ // Global variables passed to twig templates 'ga_tracking' => 'UA-XXXXX-X' ], 'optimizations' => -1, // -1: Enable all (default), 0: disable optimizations 'runtime_loaders' => [ // runtime loader names or instances ], 'timezone' => 'default timezone identifier, e.g. America/New_York', 'auto_reload' => true, // Recompile the template whenever the source code changes ], ]; When specifying the twig.extensions values, always use fully qualified class names or actual extension instances to ensure compatibility with any version of Twig used. Version 2 of Twig requires that a fully qualified class name is used, and not a short-name alias.","title":"Using Twig"},{"location":"v3/features/template/twig/#using-twig","text":"Twig is a template language and engine provided as a standalone component by SensioLabs. It provides: Layout facilities. Template inheritance. Helpers for escaping, and the ability to provide custom helper extensions. We provide a TemplateRendererInterface wrapper for Twig via Zend\\Expressive\\Twig\\TwigRenderer .","title":"Using Twig"},{"location":"v3/features/template/twig/#installing-twig","text":"To use the Twig wrapper, you must first install the Twig integration: $ composer require zendframework/zend-expressive-twigrenderer","title":"Installing Twig"},{"location":"v3/features/template/twig/#using-the-wrapper","text":"If instantiated without arguments, Zend\\Expressive\\Twig\\TwigRenderer will create an instance of the Twig engine, which it will then proxy to. use Zend\\Expressive\\Twig\\TwigRenderer; $renderer = new TwigRenderer(); Alternately, you can instantiate and configure the engine yourself, and pass it to the Zend\\Expressive\\Twig\\TwigRenderer constructor: use Twig_Environment; use Twig_Loader_Array; use Zend\\Expressive\\Twig\\TwigRenderer; // Create the engine instance: $loader = new Twig_Loader_Array(include 'config/templates.php'); $twig = new Twig_Environment($loader); // Configure it: $twig->addExtension(new CustomExtension()); $twig->loadExtension(new CustomExtension(); // Inject: $renderer = new TwigRenderer($twig);","title":"Using the wrapper"},{"location":"v3/features/template/twig/#included-extensions-and-functions","text":"The included Twig extension adds support for url generation. The extension is automatically activated if the UrlHelper and ServerUrlHelper are registered with the container. The following template functions are exposed: path : Render the relative path for a given route and parameters. If there is no route, it returns the current path. twig {{ path('article_show', {'id': '3'}) }} Generates: /article/3 url : Render the absolute url for a given route with its route parameters, query string arguments, and fragment. If there is no route, it returns the current url. twig {{ url('article_show', {'id': '3'}, {'foo': 'bar'}, 'fragment') }} Generates: http://example.com/article/3?foo=bar#fragment absolute_url : Render the absolute url from a given path. If the path is empty, it returns the current url. twig {{ absolute_url('path/to/something') }} Generates: http://example.com/path/to/something asset Render an (optionally versioned) asset url. twig {{ asset('path/to/asset/name.ext', version=3) }} Generates: path/to/asset/name.ext?v=3 To get the absolute url for an asset: twig {{ absolute_url(asset('path/to/asset/name.ext', version=3)) }} Generates: http://example.com/path/to/asset/name.ext?v=3","title":"Included extensions and functions"},{"location":"v3/features/template/twig/#configuration","text":"The following details configuration specific to Twig, as consumed by the TwigRendererFactory : return [ 'templates' => [ 'extension' => 'file extension used by templates; defaults to html.twig', 'paths' => [ // namespace / path pairs // // Numeric namespaces imply the default/main namespace. Paths may be // strings or arrays of string paths to associate with the namespace. ], ], 'twig' => [ 'autoescape' => 'html', // Auto-escaping strategy [html|js|css|url|false] 'cache_dir' => 'path to cached templates', 'assets_url' => 'base URL for assets', 'assets_version' => 'base version for assets', 'extensions' => [ // extension service names or instances ], 'globals' => [ // Global variables passed to twig templates 'ga_tracking' => 'UA-XXXXX-X' ], 'optimizations' => -1, // -1: Enable all (default), 0: disable optimizations 'runtime_loaders' => [ // runtime loader names or instances ], 'timezone' => 'default timezone identifier, e.g. America/New_York', 'auto_reload' => true, // Recompile the template whenever the source code changes ], ]; When specifying the twig.extensions values, always use fully qualified class names or actual extension instances to ensure compatibility with any version of Twig used. Version 2 of Twig requires that a fully qualified class name is used, and not a short-name alias.","title":"Configuration"},{"location":"v3/features/template/zend-view/","text":"Using zend-view zend-view provides a native PHP template system via its PhpRenderer , and is maintained by Zend Framework. It provides: Layout facilities. Helpers for escaping, and the ability to provide custom helper extensions. We provide a TemplateRendererInterface wrapper for zend-view's PhpRenderer via Zend\\Expressive\\ZendView\\ZendViewRenderer . Installing zend-view To use the zend-view wrapper, you must first install the zend-view integration: $ composer require zendframework/zend-expressive-zendviewrenderer Using the wrapper If instantiated without arguments, Zend\\Expressive\\ZendView\\ZendViewRenderer will create an instance of the PhpRenderer , which it will then proxy to. use Zend\\Expressive\\ZendView\\ZendViewRenderer; $renderer = new ZendViewRenderer(); Alternately, you can instantiate and configure the engine yourself, and pass it to the Zend\\Expressive\\ZendView\\ZendViewRenderer constructor: use Zend\\Expressive\\ZendView\\ZendViewRenderer; use Zend\\View\\Renderer\\PhpRenderer; use Zend\\View\\Resolver; // Create the engine instance: $renderer = new PhpRenderer(); // Configure it: $resolver = new Resolver\\AggregateResolver(); $resolver->attach( new Resolver\\TemplateMapResolver(include 'config/templates.php'), 100 ); $resolver->attach( (new Resolver\\TemplatePathStack()) ->setPaths(include 'config/template_paths.php') ); $renderer->setResolver($resolver); // Inject: $renderer = new ZendViewRenderer($renderer); Namespaced path resolving Expressive defines a custom zend-view resolver, Zend\\Expressive\\ZendView\\NamespacedPathStackResolver . This resolver provides the ability to segregate paths by namespace, and later resolve a template according to the namespace, using the namespace::template notation required of TemplateRendererInterface implementations. The ZendView adapter ensures that: An AggregateResolver is registered with the renderer. If the registered resolver is not an AggregateResolver , it creates one and adds the original resolver to it. A NamespacedPathStackResolver is registered with the AggregateResolver , at a low priority (0), ensuring attempts to resolve hit it later. With resolvers such as the TemplateMapResolver , you can also resolve namespaced templates, mapping them directly to the template on the filesystem that matches; adding such a resolver can be a nice performance boost! Layouts Unlike the other supported template engines, zend-view does not support layouts out-of-the-box. Expressive abstracts this fact away, providing two facilities for doing so: You may pass a layout template name or Zend\\View\\Model\\ModelInterface instance representing the layout as the second argument to the constructor. You may pass a \"layout\" parameter during rendering, with a value of either a layout template name or a Zend\\View\\Model\\ModelInterface instance representing the layout. Passing a layout this way will override any layout provided to the constructor. In each case, the zend-view implementation will do a depth-first, recursive render in order to provide content within the selected layout. Since 1.3: You may also pass a boolean false value to either addDefaultParam() or via the template variables for the layout key; doing so will disable the layout. Layout name passed to constructor use Zend\\Expressive\\ZendView\\ZendViewRenderer; // Create the engine instance with a layout name: $renderer = new ZendViewRenderer(null, 'layout::layout'); Layout view model passed to constructor use Zend\\Expressive\\ZendView\\ZendViewRenderer; use Zend\\View\\Model\\ViewModel; // Create the layout view model: $layout = new ViewModel([ 'encoding' => 'utf-8', 'cssPath' => '/css/prod/', ]); $layout->setTemplate('layout::layout'); // Create the engine instance with the layout: $renderer = new ZendViewRenderer(null, $layout); Provide a layout name when rendering $content = $renderer->render('blog/entry', [ 'layout' => 'layout::blog', 'entry' => $entry, ]); Provide a layout view model when rendering use Zend\\View\\Model\\ViewModel; // Create the layout view model: $layout = new ViewModel([ 'encoding' => 'utf-8', 'cssPath' => '/css/blog/', ]); $layout->setTemplate('layout::layout'); $content = $renderer->render('blog/entry', [ 'layout' => $layout, 'entry' => $entry, ]); Helpers Expressive provides overrides of specific view helpers in order to better integrate with PSR-7 . These include: Zend\\Expressive\\ZendView\\UrlHelper . This helper consumes the application's Zend\\Expressive\\Router\\RouterInterface instance in order to generate URIs. Its signature is: url($routeName, array $routeParams = [], array $queryParams = [], $fragmentIdentifier = null, array $options = []) Zend\\Expressive\\ZendView\\ServerUrlHelper . This helper consumes the URI from the application's request in order to provide fully qualified URIs. Its signature is: serverUrl($path = null) . To use this particular helper, you will need to inject it with the request URI somewhere within your application: php $serverUrlHelper->setUri($request->getUri()); We recommend doing this within a pre-pipeline middleware. Recommendations We recommend the following practices when using the zend-view adapter: If using a layout, create a factory to return the layout view model as a service; this allows you to inject it into middleware and add variables to it. While we support passing the layout as a rendering parameter, be aware that if you change engines, this may not be supported.","title":"Using zend-view"},{"location":"v3/features/template/zend-view/#using-zend-view","text":"zend-view provides a native PHP template system via its PhpRenderer , and is maintained by Zend Framework. It provides: Layout facilities. Helpers for escaping, and the ability to provide custom helper extensions. We provide a TemplateRendererInterface wrapper for zend-view's PhpRenderer via Zend\\Expressive\\ZendView\\ZendViewRenderer .","title":"Using zend-view"},{"location":"v3/features/template/zend-view/#installing-zend-view","text":"To use the zend-view wrapper, you must first install the zend-view integration: $ composer require zendframework/zend-expressive-zendviewrenderer","title":"Installing zend-view"},{"location":"v3/features/template/zend-view/#using-the-wrapper","text":"If instantiated without arguments, Zend\\Expressive\\ZendView\\ZendViewRenderer will create an instance of the PhpRenderer , which it will then proxy to. use Zend\\Expressive\\ZendView\\ZendViewRenderer; $renderer = new ZendViewRenderer(); Alternately, you can instantiate and configure the engine yourself, and pass it to the Zend\\Expressive\\ZendView\\ZendViewRenderer constructor: use Zend\\Expressive\\ZendView\\ZendViewRenderer; use Zend\\View\\Renderer\\PhpRenderer; use Zend\\View\\Resolver; // Create the engine instance: $renderer = new PhpRenderer(); // Configure it: $resolver = new Resolver\\AggregateResolver(); $resolver->attach( new Resolver\\TemplateMapResolver(include 'config/templates.php'), 100 ); $resolver->attach( (new Resolver\\TemplatePathStack()) ->setPaths(include 'config/template_paths.php') ); $renderer->setResolver($resolver); // Inject: $renderer = new ZendViewRenderer($renderer);","title":"Using the wrapper"},{"location":"v3/features/template/zend-view/#layouts","text":"Unlike the other supported template engines, zend-view does not support layouts out-of-the-box. Expressive abstracts this fact away, providing two facilities for doing so: You may pass a layout template name or Zend\\View\\Model\\ModelInterface instance representing the layout as the second argument to the constructor. You may pass a \"layout\" parameter during rendering, with a value of either a layout template name or a Zend\\View\\Model\\ModelInterface instance representing the layout. Passing a layout this way will override any layout provided to the constructor. In each case, the zend-view implementation will do a depth-first, recursive render in order to provide content within the selected layout. Since 1.3: You may also pass a boolean false value to either addDefaultParam() or via the template variables for the layout key; doing so will disable the layout.","title":"Layouts"},{"location":"v3/features/template/zend-view/#helpers","text":"Expressive provides overrides of specific view helpers in order to better integrate with PSR-7 . These include: Zend\\Expressive\\ZendView\\UrlHelper . This helper consumes the application's Zend\\Expressive\\Router\\RouterInterface instance in order to generate URIs. Its signature is: url($routeName, array $routeParams = [], array $queryParams = [], $fragmentIdentifier = null, array $options = []) Zend\\Expressive\\ZendView\\ServerUrlHelper . This helper consumes the URI from the application's request in order to provide fully qualified URIs. Its signature is: serverUrl($path = null) . To use this particular helper, you will need to inject it with the request URI somewhere within your application: php $serverUrlHelper->setUri($request->getUri()); We recommend doing this within a pre-pipeline middleware.","title":"Helpers"},{"location":"v3/features/template/zend-view/#recommendations","text":"We recommend the following practices when using the zend-view adapter: If using a layout, create a factory to return the layout view model as a service; this allows you to inject it into middleware and add variables to it. While we support passing the layout as a rendering parameter, be aware that if you change engines, this may not be supported.","title":"Recommendations"},{"location":"v3/getting-started/features/","text":"Overview Expressive allows you to write PSR-15 middleware applications for the web. PSR-15 consumes PSR-7 HTTP Message Interfaces; these are the incoming request and outgoing response for your application. By using both PSR-15 and PSR-7, we ensure that your applications will work in other contexts that are compatible with these standards. Middleware is any code sitting between a request and a response; it typically analyzes the request to aggregate incoming data, delegates it to another layer to process, and then creates and returns a response. Middleware can and should be relegated only to those tasks, and should be relatively easy to write and maintain. PSR-15 also defines request handlers ; these are classes that receive a request and return a response, without delegating to other layers of the application. These are generally the inner-most layers of your application. Middleware is also designed for composability; you should be able to nest middleware and re-use middleware. With Expressive, you can build middleware applications such as the following: APIs Websites Single Page Applications and more. Features Expressive builds on zend-stratigility to provide a robust convenience layer on which to build applications. The features it provides include: Routing Stratigility provides limited, literal matching only via its PathMiddlewareDecorator . Expressive allows you to utilize dynamic routing capabilities from a variety of routers, providing much more fine-grained matching capabilities. The routing layer also allows restricting matched routes to specific HTTP methods, and will return \"405 Not Allowed\" responses with an \"Allow\" HTTP header containing allowed HTTP methods for invalid requests. Routing is abstracted in Expressive, allowing the developer to choose the routing library that best fits the project needs. By default, we provide wrappers for Aura.Router, FastRoute, and the zend-router. PSR-11 Container Expressive encourages the use of Dependency Injection, and defines its Application class to compose a PSR-11 ContainerInterface instance. The container is used to lazy-load middleware, whether it is piped (Stratigility interface) or routed (Expressive). Templating While Expressive does not assume templating is being used, it provides a templating abstraction. Developers can write middleware that typehints on this abstraction, and assume that the underlying adapter will provide layout support and namespaced template support. Error Handling Applications should handle errors gracefully, but also handle them differently in development versus production. Expressive provides both basic error handling via Stratigility's own ErrorHandler implementation, providing specialized error response generators that can perform templating or use Whoops. Flow Overview Below is a diagram detailing the workflow used by Expressive. The Application acts as an \"onion\"; in the diagram above, the top is the outer-most layer of the onion, while the bottom is the inner-most. The Application dispatches each middleware. Each middleware receives a request and a delegate for handing off processing of the request should the middleware not be able to fully process it itself. Internally, the delegate composes a queue of middleware, and invokes the next in the queue when invoked. Any given middleware can return a response , at which point execution winds its way back out the onion. Pipelines The terminology \"pipeline\" is often used to describe the onion. One way of looking at the \"onion\" is as a queue , which is first-in-first-out (FIFO) in operation. This means that the first middleware on the queue is executed first, and this invokes the next, and so on (and hence the \"next\" terminology). When looked at from this perspective: In most cases, the entire queue will not be traversed. The inner-most layer of the onion represents the last item in the queue, and should be guaranteed to return a response; usually this is indicative of a malformed request (HTTP 400 response status) and/or inability to route the middleware to a handler (HTTP 404 response status). Responses are returned back through the pipeline, in reverse order of traversal. Double pass middleware The system described above is what is known as lambda middleware . Each middleware receives the request and a handler, and you pass only the request to the handler when wanting to hand off processing: $$$$FENCED_CODE_BLOCK_5e03bde9e8b9a5.49694778 In Expressive 1.X, the default middleware style was what is known as double pass middleware. Double pass middleware receives both the request and a response in addition to the handler, and passes both the request and response to the handler when invoking it: $$$$FENCED_CODE_BLOCK_5e03bde9e8beb6.66976453 It is termed \"double pass\" because you pass both the request and response when delegating to the next layer. Expressive 3 no longer supports double-pass middleware directly. However, if you decorate it using Zend\\Stratigility\\doublePassMiddleware() , we can consume it. That function requires first the double-pass middleware, and then a response prototype (which will be passed as the $response argument to the middleware): $$$$FENCED_CODE_BLOCK_5e03bde9e8c020.80435924 If you use double-pass middleware, do not use the $response instance passed to it unless you are returning it specifically (e.g., because you are not delegating to another layer). The Application allows arbitrary middleware to be injected, with each being executed in the order in which they are attached; returning a response from middleware prevents any middleware attached later from executing. The middleware pipeline is executed in the order of attachment. Expressive provides default implementations of \"routing\" and \"dispatch\" middleware, which you will attach to the middleware pipeline. These are implemented as the classes Zend\\Expressive\\Router\\Middleware\\RouteMiddleware and Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware , respectively. Routing within Expressive consists of decomposing the request to match it to middleware that can handle that given request. This typically consists of a combination of matching the requested URI path along with allowed HTTP methods: map a GET request to the path /api/ping to the PingMiddleware map a POST request to the path /contact/process to the HandleContactMiddleware etc. Dispatching is simply the act of calling the middleware mapped by routing. The two events are modeled as separate middleware to allow you to act on the results of routing before attempting to dispatch the mapped middleware; this can be useful for implementing route-based authentication or validation, or, as we provide by default, handling HEAD and OPTIONS requests, or providing 405 Method Not Allowed responses. The majority of your application will consist of routing rules that map to routed middleware and request handlers. Middleware piped to the application earlier than routing should be middleware that you wish to execute for every request. These might include: bootstrapping parsing of request body parameters addition of debugging tools embedded middleware pipelines/application that you want to match at a given literal path etc. Such middleware may decide that a request is invalid, and return a response; doing so means no further middleware will be executed! This is an important feature of middleware architectures, as it allows you to define application-specific workflows optimized for performance, security, etc. Middleware piped to the application after the routing and dispatch middleware will execute in one of two conditions: routing failed routed middleware called on the next middleware instead of returning a response. As such, the largest use case for such middleware is to provide a \"default\" error response for your application, usually as an HTTP 404 Not Found response. The main points to remember are: The application is a queue, and operates in FIFO order. Each middleware can choose whether to return a response, which will cause the queue to unwind, or to traverse to the next middleware. Most of the time, you will be defining routed middleware , and the routing rules that map to them. You get to control the workflow of your application by deciding the order in which middleware is queued.","title":"Overview and Features"},{"location":"v3/getting-started/features/#overview","text":"Expressive allows you to write PSR-15 middleware applications for the web. PSR-15 consumes PSR-7 HTTP Message Interfaces; these are the incoming request and outgoing response for your application. By using both PSR-15 and PSR-7, we ensure that your applications will work in other contexts that are compatible with these standards. Middleware is any code sitting between a request and a response; it typically analyzes the request to aggregate incoming data, delegates it to another layer to process, and then creates and returns a response. Middleware can and should be relegated only to those tasks, and should be relatively easy to write and maintain. PSR-15 also defines request handlers ; these are classes that receive a request and return a response, without delegating to other layers of the application. These are generally the inner-most layers of your application. Middleware is also designed for composability; you should be able to nest middleware and re-use middleware. With Expressive, you can build middleware applications such as the following: APIs Websites Single Page Applications and more.","title":"Overview"},{"location":"v3/getting-started/features/#features","text":"Expressive builds on zend-stratigility to provide a robust convenience layer on which to build applications. The features it provides include: Routing Stratigility provides limited, literal matching only via its PathMiddlewareDecorator . Expressive allows you to utilize dynamic routing capabilities from a variety of routers, providing much more fine-grained matching capabilities. The routing layer also allows restricting matched routes to specific HTTP methods, and will return \"405 Not Allowed\" responses with an \"Allow\" HTTP header containing allowed HTTP methods for invalid requests. Routing is abstracted in Expressive, allowing the developer to choose the routing library that best fits the project needs. By default, we provide wrappers for Aura.Router, FastRoute, and the zend-router. PSR-11 Container Expressive encourages the use of Dependency Injection, and defines its Application class to compose a PSR-11 ContainerInterface instance. The container is used to lazy-load middleware, whether it is piped (Stratigility interface) or routed (Expressive). Templating While Expressive does not assume templating is being used, it provides a templating abstraction. Developers can write middleware that typehints on this abstraction, and assume that the underlying adapter will provide layout support and namespaced template support. Error Handling Applications should handle errors gracefully, but also handle them differently in development versus production. Expressive provides both basic error handling via Stratigility's own ErrorHandler implementation, providing specialized error response generators that can perform templating or use Whoops.","title":"Features"},{"location":"v3/getting-started/features/#flow-overview","text":"Below is a diagram detailing the workflow used by Expressive. The Application acts as an \"onion\"; in the diagram above, the top is the outer-most layer of the onion, while the bottom is the inner-most. The Application dispatches each middleware. Each middleware receives a request and a delegate for handing off processing of the request should the middleware not be able to fully process it itself. Internally, the delegate composes a queue of middleware, and invokes the next in the queue when invoked. Any given middleware can return a response , at which point execution winds its way back out the onion.","title":"Flow Overview"},{"location":"v3/getting-started/quick-start/","text":"Quick Start The easiest way to get started with Expressive is to use the skeleton application and installer . The skeleton provides a generic structure for creating your applications, and prompts you to choose a router, dependency injection container, template renderer, and error handler from the outset. Create a new project First, we'll create a new project, using Composer's create-project command: $ composer create-project zendframework/zend-expressive-skeleton expressive This will prompt you to choose: Whether to install a minimal skeleton (no default middleware), a flat application structure (all code under src/ ), or a modular structure (directories under src/ are modules, each with source code and potentially templates, configuration, assets, etc.). The default is a \"flat\" structure; you can always add modules to it later. A dependency injection container. We recommend using the default, zend-servicemanager. A router. We recommend using the default, FastRoute. A template renderer. You can ignore this when creating an API project, but if you will be creating any HTML pages, we recommend installing one. We prefer Plates. An error handler. Whoops is a very nice option for development, as it gives you extensive, browseable information for exceptions and errors raised. Start a web server The Skeleton + Installer creates a full application structure that's ready-to-go when complete. You can test it out using built-in web server . From the project root directory, execute the following: $ composer run --timeout=0 serve This starts up a web server on localhost port 8080; browse to http://localhost:8080/ to see if your application responds correctly! Setting a timeout Composer commands time out after 300 seconds (5 minutes). On Linux-based systems, the php -S command that composer serve spawns continues running as a background process, but on other systems halts when the timeout occurs. As such, we recommend running the serve script using a timeout. This can be done by using composer run to execute the serve script, with a --timeout option. When set to 0 , as in the previous example, no timeout will be used, and it will run until you cancel the process (usually via Ctrl-C ). Alternately, you can specify a finite timeout; as an example, the following will extend the timeout to a full day: $$$$FENCED_CODE_BLOCK_5e03bde9e8e247.85414280 Development Tools We ship tools in our skeleton application to make development easier. Development Mode zf-development-mode allows you to enable and disable development mode from your cli. $ composer development-enable # enable development mode $ composer development-disable # disable development mode $ composer development-status # show development status The development configuration is set in config/autoload/development.local.php.dist . It also allows you to specify configuration and modules that should only be enabled when in development, and not when in production. Clear config cache Production settings are the default, which means enabling the configuration cache. However, it must be easy for developers to clear the configuration cache. That's what this command does. $ composer clear-config-cache Testing Your Code PHPUnit and PHP_CodeSniffer are now installed by default. To execute tests and detect coding standards violations, run the following command: $ composer check Security Advisories We have included the security-advisories package to notify you about installed dependencies with known security vulnerabilities. Each time you run composer update , composer install , or composer require , it prevents installation of software with known and documented security issues. Tooling integration The skeleton ships with zend-expressive-tooling by default, and integrates with it by exposing it via composer: $ composer expressive The tooling provides a number of commands; see the CLI tooling chapter for more details. Modules Composer will prompt you during installation to ask if you want a minimal application (no structure or default middleware provided), flat application (all source code under the same tree, and the default selection), or modular application. This latter option allows you to segregate discrete areas of application functionality into modules , which can contain source code, templates, assets, and more; these can later be repackaged for re-use if desired. Support for modules is available via the zend-component-installer and zend-config-aggregator packages; the zend-expressive-tooling . package provides tools for creating and manipulating modules in your application. Component Installer Whenever you add a component or module that exposes itself as such, the zend-component-installer composer plugin will prompt you, asking if and where you want to inject its configuration. This ensures that components are wired automatically for you. In most cases, you will choose to inject in the config/config.php file; for tools intended only for usage during development, choose config/development.config.php.dist . Config Aggregator The zend-config-aggregator library collects and merges configuration from different sources. It also supports configuration caching. As an example, your config/config.php file might read as follows in order to aggregate configuration from development mode settings, application configuration, and theoretical User , Blog , and App modules: <?php // config/config.php $aggregator = new ConfigAggregator([ // Module configuration App\\ConfigProvider::class, BlogModule\\ConfigProvider::class, UserModule\\ConfigProvider::class, // Load application config in a pre-defined order in such a way that local settings // overwrite global settings. (Loaded as first to last): // - `global.php` // - `*.global.php` // - `local.php` // - `*.local.php` new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'), // Load development config if it exists new PhpFileProvider('config/development.config.php'), ], 'data/config-cache.php'); return $aggregator->getMergedConfig(); The configuration is merged in the same order as it is passed, with later entries having precedence. Config Providers ConfigAggregator works by aggregating \"Config Providers\" passed to its constructor. Each provider should be a callable class that requires no constructor parameters, where invocation returns a configuration array (or a PHP generator) to be merged. Libraries or modules can have configuration providers that provide default values for a library or module. For the UserModule\\ConfigProvider class loaded in the ConfigAggregator above, the ConfigProvider might look like this: <?php namespace UserModule; class ConfigProvider { /** * Returns the configuration array * * To add some sort of a structure, each section is defined in a separate * method which returns an array with its configuration. * * @return array */ public function __invoke() { return [ 'dependencies' => $this->getDependencies(), 'users' => $this->getConfig(), ]; } /** * Returns the container dependencies * * @return array */ public function getDependencies() : array { return [ 'factories' => [ Action\\LoginAction::class => Factory\\Action\\LoginActionFactory::class, Middleware\\AuthenticationMiddleware::class => Factory\\Middleware\\AuthenticationMiddlewareFactory::class, ], ]; } /** * Returns the default module configuration * * @return array */ public function getConfig() : array { return [ 'paths' => [ 'enable_registration' => true, 'enable_username' => false, 'enable_display_name' => true, ], ]; } } expressive module commands To aid in the creation, registration, and deregistration of modules in your application, you can use the CLI tooling provided by default. All commands are exposed via composer expressive , and include the following: composer expressive module:create <modulename> will create the default directory structure for the named module, create a ConfigProvider for the module, add an autoloading rule to composer.json , and register the ConfigProvider with the application configuration. composer expressive module:register <modulename> will add an autoloading rule to composer.json for the module, and register its ConfigProvider , if found, with the application configuration. expressive module:deregister <modulename> will remove any autoloading rules for the module from composer.json , and deregister its ConfigProvider , if found, from the application configuration. Adding Middleware The skeleton makes the assumption that you will be writing your middleware as classes, and uses piping and routing to add your middleware. Piping Piping is a foundation feature of the underlying zend-stratigility implementation. You can setup the middleware pipeline in config/pipeline.php . In this section, we'll demonstrate setting up a basic pipeline that includes error handling, segregated applications, routing, middleware dispatch, and more. The error handler should be the first (most outer) middleware to catch all exceptions. $app->pipe(ErrorHandler::class); $app->pipe(ServerUrlMiddleware::class); After the ErrorHandler you can pipe more middleware that you want to execute on every request, such as bootstrapping, pre-conditions, and modifications to outgoing responses: $app->pipe(ServerUrlMiddleware::class); Piped middleware may be callables, middleware instances, or service names. Middleware may also be passed as an array; each item in the array must resolve to middleware eventually (i.e., callable or service name); underneath, Expressive creates Zend\\Stratigility\\MiddlewarePipe instances with each of the middleware listed piped to it. Middleware can be attached to specific paths, allowing you to mix and match applications under a common domain. The handlers in each middleware attached this way will see a URI with the MATCHED PATH SEGMENT REMOVED!!! $app->pipe('/api', $apiMiddleware); $app->pipe('/docs', $apiDocMiddleware); $app->pipe('/files', $filesMiddleware); Next, you should register the routing middleware in the middleware pipeline: $app->pipe(RouteMiddleware::class); Add more middleware that needs to introspect the routing results; this might include: handling for HTTP HEAD requests handling for HTTP OPTIONS requests handling for matched paths where the HTTP method is not allowed middleware for handling URI generation route-based authentication route-based validation etc. $app->pipe(ImplicitHeadMiddleware::class); $app->pipe(ImplicitOptionsMiddleware::class); $app->pipe(MethodNotAllowedMiddleware::class); $app->pipe(UrlHelperMiddleware::class); Next, register the dispatch middleware in the middleware pipeline: $app->pipe(DispatchMiddleware::class); At this point, if no response is return by any middleware, we need to provide a way of notifying the user of this; by default, we use the NotFoundHandler , but you can provide any other fallback middleware you wish: $app->pipe(NotFoundHandler::class); The public/index.php file will require the config/pipeline.php file, and invoke the returned result. When it invokes it, it passes the application instance, a Zend\\Expressive\\MiddlewareFactory instance, and the PSR-11 container you are using. The full example then looks something like this: // In config/pipeline.php: use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\MiddlewareFactory; use Zend\\Expressive\\Helper\\ServerUrlMiddleware; use Zend\\Expressive\\Helper\\UrlHelperMiddleware; use Zend\\Expressive\\Middleware\\NotFoundHandler; use Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware; use Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware; use Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware; use Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware; use Zend\\Expressive\\Router\\Middleware\\RouteMiddleware; use Zend\\Stratigility\\Middleware\\ErrorHandler; return function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void { $app->pipe(ErrorHandler::class); $app->pipe(ServerUrlMiddleware::class); // These assume that the variables listed are defined in this scope: $app->pipe('/api', $apiMiddleware); $app->pipe('/docs', $apiDocMiddleware); $app->pipe('/files', $filesMiddleware); $app->pipe(RouteMiddleware::class); $app->pipe(ImplicitHeadMiddleware::class); $app->pipe(ImplicitOptionsMiddleware::class); $app->pipe(MethodNotAllowedMiddleware::class); $app->pipe(UrlHelperMiddleware::class); $app->pipe(DispatchMiddleware::class); $app->pipe(NotFoundHandler::class); }; Routing Routing is an additional feature provided by Expressive. Routing is setup in config/routes.php . You can setup routes with a single request method: $app->get('/', App\\Action\\HomePageAction::class, 'home'); $app->post('/album', App\\Action\\AlbumCreateAction::class, 'album.create'); $app->put('/album/:id', App\\Action\\AlbumUpdateAction::class, 'album.put'); $app->patch('/album/:id', App\\Action\\AlbumUpdateAction::class, 'album.patch'); $app->delete('/album/:id', App\\Action\\AlbumDeleteAction::class, 'album.delete'); Or with multiple request methods: $app->route('/contact', App\\Action\\ContactAction::class, ['GET', 'POST', ...], 'contact'); Or handling all request methods: $app->any('/contact', App\\Action\\ContactAction::class)->setName('contact'); Alternately, to be explicit, the above could be written as: $app->route( '/contact', App\\Action\\ContactAction::class, Zend\\Expressive\\Router\\Route::HTTP_METHOD_ANY, 'contact' ); We recommend a single middleware class per combination of route and request method. Similar to the config/pipeline.php file, the config/routes.php file is expected to return a callable: // In config/routes.php: use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\MiddlewareFactory; return function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void { $app->get('/books', \\App\\Handler\\ListBooksHandler::class, 'books'); }; Next Steps The skeleton provides a default structure for templates, if you choose to use them. Let's see how you can create your first vanilla middleware, and templated middleware. Creating middleware Middleware must implement Psr\\Http\\Server\\MiddlewareInterface ; this interface defines a single method, process() , which accepts a Psr\\Http\\Message\\ServerRequestInterface instance and a Psr\\Http\\Server\\RequestHandlerInterface instance, and returns a Psr\\Http\\Message\\ResponseInterface instance. Write middleware when you may want to delegate to another layer of the application in order to create a response; do this by calling the handle() method of the handler passed to it. Generally speaking, you will write middleware when you want to conditionally return a response based on the request, and/or alter the response returned by another layer of the application . The skeleton defines an App namespace for you; you can place middleware anywhere within it. We'll create a simple middleware here that will run on every request, and alter the response to add a header. We can use our tooling to create the middleware file: $ composer expressive middleware:create \"App\\XClacksOverheadMiddleware\" This command will create a PSR-15 middleware implementation, a factory for it, and register the two in the application's container configuration. It tells you the location of both files. Now let's edit the middleware class file. Replace the contents of the process() method with: $response = $handler->handle($request); return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett'); Now that we've created our middleware, we still have to tell the pipeline about it. Open the file config/pipeline.php file, and find the line that read: $app->pipe(ErrorHandler::class); Add the following line after it: $app->pipe(App\\XClacksOverheadMiddleware::class); If you browse to the home page (or any other page, for that matter) and introspect the headers returned with the response using your browser's development tools, you'll now see the following entry: X-Clacks-Overhead: GNU Terry Pratchett You've created your first middleware! Creating request handlers You may route to either middleware or request handlers. In this section, we'll define a request handler and route to it. Request handlers must implement Psr\\Http\\Server\\RequestHandlerInterface ; this interface defines a single method, handle() , which accepts a Psr\\Http\\Message\\ServerRequestInterface instance and returns a Psr\\Http\\Message\\ResponseInterface instance. Write request handlers when you will not be delegating to another layer of the application, and will be creating and returning a response directly. Generally speaking, you will route to request handlers . The skeleton defines an App namespace for you, and suggests placing request handlers under the namespace App\\Handler . Let's create a \"Hello\" request handler. We can use our tooling to create the file: $ composer expressive handler:create \"App\\Handler\\HelloHandler\" The command will tell you the location in the filesystem in which it created the new class; it will also create a factory for you, and register that factory with the container! Additionally, if you have a template renderer in place, it will create a template file for you. make a note of the locations of both the class file and template file. Open the class file, and now let's edit the handle() contents to read as follows: $target = $request->getQueryParams()['target'] ?? 'World'; $target = htmlspecialchars($target, ENT_HTML5, 'UTF-8'); return new HtmlResponse($this->renderer->render( 'app::hello', ['target' => $target] )); Templateless handler If you did not select a template engine when creating your application, the contents of your handle() method will be empty to begin. In that case, alter the above example as follows: Add the statement use Zend\\Diactoros\\Response\\HtmlResponse; to the use statements at the top of the file. Alter the response creation to read: $$$$FENCED_CODE_BLOCK_5e03bde9e8e6b0.30473962 You can also skip the next step below where we edit the template file. The above looks for a query string parameter \"target\", and uses its value to provide to the template, which is then rendered and returned in an HTML response. Now, let's edit the template file to have the one of the following header lines (use the one for your chosen template renderer): Plates php <!-- plates --> <h1>Hello <?= $this->e($target) ?></h1> zend-view php <!-- zend-view --> <h1>Hello <?= $this->target ?></h1> Twig twig <!-- twig --> <h1>Hello {{ target }}</h1> While the handler is registered with the container, the application does not yet know how to get to it. Let's fix that. Open the file config/routes.php , and add the following at the bottom of the function it exposes: $app->get('/hello', App\\Handler\\HelloHandler::class, 'hello'); Once you've completed the above, give it a try by going to each of the following URIs: http://localhost:8080/hello http://localhost:8080/hello?target=ME You should see the message change as you go between the two URIs! Congratulations! Congratulations! You've now created your application, and started writing middleware! It's time to start learning about the rest of the features of Expressive: Containers Routing Templating Error Handling","title":"Quick Start"},{"location":"v3/getting-started/quick-start/#quick-start","text":"The easiest way to get started with Expressive is to use the skeleton application and installer . The skeleton provides a generic structure for creating your applications, and prompts you to choose a router, dependency injection container, template renderer, and error handler from the outset.","title":"Quick Start"},{"location":"v3/getting-started/quick-start/#create-a-new-project","text":"First, we'll create a new project, using Composer's create-project command: $ composer create-project zendframework/zend-expressive-skeleton expressive This will prompt you to choose: Whether to install a minimal skeleton (no default middleware), a flat application structure (all code under src/ ), or a modular structure (directories under src/ are modules, each with source code and potentially templates, configuration, assets, etc.). The default is a \"flat\" structure; you can always add modules to it later. A dependency injection container. We recommend using the default, zend-servicemanager. A router. We recommend using the default, FastRoute. A template renderer. You can ignore this when creating an API project, but if you will be creating any HTML pages, we recommend installing one. We prefer Plates. An error handler. Whoops is a very nice option for development, as it gives you extensive, browseable information for exceptions and errors raised.","title":"Create a new project"},{"location":"v3/getting-started/quick-start/#start-a-web-server","text":"The Skeleton + Installer creates a full application structure that's ready-to-go when complete. You can test it out using built-in web server . From the project root directory, execute the following: $ composer run --timeout=0 serve This starts up a web server on localhost port 8080; browse to http://localhost:8080/ to see if your application responds correctly!","title":"Start a web server"},{"location":"v3/getting-started/quick-start/#development-tools","text":"We ship tools in our skeleton application to make development easier.","title":"Development Tools"},{"location":"v3/getting-started/quick-start/#modules","text":"Composer will prompt you during installation to ask if you want a minimal application (no structure or default middleware provided), flat application (all source code under the same tree, and the default selection), or modular application. This latter option allows you to segregate discrete areas of application functionality into modules , which can contain source code, templates, assets, and more; these can later be repackaged for re-use if desired. Support for modules is available via the zend-component-installer and zend-config-aggregator packages; the zend-expressive-tooling . package provides tools for creating and manipulating modules in your application.","title":"Modules"},{"location":"v3/getting-started/quick-start/#adding-middleware","text":"The skeleton makes the assumption that you will be writing your middleware as classes, and uses piping and routing to add your middleware.","title":"Adding Middleware"},{"location":"v3/getting-started/quick-start/#next-steps","text":"The skeleton provides a default structure for templates, if you choose to use them. Let's see how you can create your first vanilla middleware, and templated middleware.","title":"Next Steps"},{"location":"v3/getting-started/quick-start/#congratulations","text":"Congratulations! You've now created your application, and started writing middleware! It's time to start learning about the rest of the features of Expressive: Containers Routing Templating Error Handling","title":"Congratulations!"},{"location":"v3/reference/cli-tooling/","text":"Command Line Tooling Expressive offers a number of tools for assisting in project development. This page catalogues each. Development Mode The package zfcampus/zf-development-mode provides a simple way to toggle in and out of development mode . Doing so allows you to ship known development-specific settings within your repository, while ensuring they are not enabled in production. The tooling essentially enables optional, development-specific configuration in your application by: Copying the file config/development.config.php.dist to config/development.config.php ; this can be used to enable development-specific modules or settings (such as the debug flag). Copying the file config/autoload/development.local.php.dist to config/autoload/development.local.php ; this can be used to provide local overrides of a number of configuration settings. The package provides the tooling via vendor/bin/zf-development-mode . If you are using the Expressive skeleton, it provides aliases via Composer: $ composer development-enable $ composer development-disable $ composer development-status Add settings to your development.*.php.dist files, and commit those files to your repository; always toggle out of and into development mode after making changes, to ensure they pick up in your development environment. Expressive command-line tool The package zendframework/zend-expressive-tooling provides the script vendor/bin/expressive , which contains a number of commands related to migration, modules, and middleware. You can install it if it is not already present in your application: $ composer require --dev zendframework/zend-expressive-tooling Once installed, invoking the binary without arguments will give a listing of available tools: $ ./vendor/bin/expressive Integration with Composer In the skeleton application, we provide direct integration with Composer, allowing you to invoke the tooling using: $$$$FENCED_CODE_BLOCK_5e03bde9ecdd52.60225738 You can use either that form, or invoke the script directly as detailed above. Commands supported include: action:create [options] <action> : This is an alias for the handler:create command detailed below. factory:create [options] <class> : Create a factory for the named class. By default, the command will also register the class with its factory in the application container. handler:create [options] <handler> : Create a request handler named after <handler> . By default, the command will also generate a factory, register both with the application container, and, if a template renderer is discovered, generate a template in an appropriate location. Note: <handler> will either need to be quoted or the backslashes escaped. Example: handler:create \"ModuleName\\Handler\\IndexHandler\" or handler:create ModuleName\\\\Handler\\\\IndexHandler . middleware:create <middleware> : Create a class file for the named middleware class. The class must use a namespace already declared in your application, and will be created relative to the path associated with that namespace. migrate:interop-middleware [options] : Migrates former http-interop middleware under the src/ tree to PSR-15 middleware. migrate:middleware-to-request-handler [options] : Migrates PSR-15 middleware under the src/ tree to PSR-15 request handlers; it will only migrate those that never call on their $handler argument. module:create [--composer|-c] [--modules-path|-p] <module> : Create the named module including a filesystem skeleton, add and generate autoloading rules for it, and register the module's ConfigProvider with your application. module:register [--composer|-c] [--modules-path|-p] <module> : Add and generate autoloading rules for the named module, and register the module's ConfigProvider with your application. module:deregister [--composer|-c] [--modules-path|-p] <module> : Remove autoloading rules for the named module and regenerate autoloading rules; remove the module's ConfigProvider from the application configuration. You may obtain full help for each command by invoking: $ ./vendor/bin/expressive help <command>","title":"CLI Tooling"},{"location":"v3/reference/cli-tooling/#command-line-tooling","text":"Expressive offers a number of tools for assisting in project development. This page catalogues each.","title":"Command Line Tooling"},{"location":"v3/reference/cli-tooling/#development-mode","text":"The package zfcampus/zf-development-mode provides a simple way to toggle in and out of development mode . Doing so allows you to ship known development-specific settings within your repository, while ensuring they are not enabled in production. The tooling essentially enables optional, development-specific configuration in your application by: Copying the file config/development.config.php.dist to config/development.config.php ; this can be used to enable development-specific modules or settings (such as the debug flag). Copying the file config/autoload/development.local.php.dist to config/autoload/development.local.php ; this can be used to provide local overrides of a number of configuration settings. The package provides the tooling via vendor/bin/zf-development-mode . If you are using the Expressive skeleton, it provides aliases via Composer: $ composer development-enable $ composer development-disable $ composer development-status Add settings to your development.*.php.dist files, and commit those files to your repository; always toggle out of and into development mode after making changes, to ensure they pick up in your development environment.","title":"Development Mode"},{"location":"v3/reference/cli-tooling/#expressive-command-line-tool","text":"The package zendframework/zend-expressive-tooling provides the script vendor/bin/expressive , which contains a number of commands related to migration, modules, and middleware. You can install it if it is not already present in your application: $ composer require --dev zendframework/zend-expressive-tooling Once installed, invoking the binary without arguments will give a listing of available tools: $ ./vendor/bin/expressive","title":"Expressive command-line tool"},{"location":"v3/reference/expressive-projects/","text":"Projects powered by zend-expressive zend-expressive can be used for anything. Here are some projects, tutorials and the related source code. Have a look around and see how others have used zend-expressive. Sample Code & Tutorials Expressive Tutorial (WIP) - source AstroSplash - source php-ddd-cargo-sample - source Personal Sites mwop.net - source xtreamwayz.com - source alejandrocelaya.com - source zimuel.it - source Applications Shlink: A self-hosted URL shortener - source","title":"Expressive Projects"},{"location":"v3/reference/expressive-projects/#projects-powered-by-zend-expressive","text":"zend-expressive can be used for anything. Here are some projects, tutorials and the related source code. Have a look around and see how others have used zend-expressive.","title":"Projects powered by zend-expressive"},{"location":"v3/reference/expressive-projects/#sample-code-tutorials","text":"Expressive Tutorial (WIP) - source AstroSplash - source php-ddd-cargo-sample - source","title":"Sample Code &amp; Tutorials"},{"location":"v3/reference/expressive-projects/#personal-sites","text":"mwop.net - source xtreamwayz.com - source alejandrocelaya.com - source zimuel.it - source","title":"Personal Sites"},{"location":"v3/reference/expressive-projects/#applications","text":"Shlink: A self-hosted URL shortener - source","title":"Applications"},{"location":"v3/reference/migration/","text":"Migration to Expressive 3.0 Expressive 3.0 should not result in many upgrade problems for users. However, starting in this version, we offer a few changes affecting the following that you should be aware of, and potentially update your application to adopt: PHP 7.1 support PSR-15 support New dependencies New features Signature and behavior changes Removed classes and traits Upgrading from v2 PHP 7.1 support Starting in Expressive 3.0 we support only PHP 7.1+. PSR-15 Support All middleware and delegators now implement interfaces from PSR-15 instead of http-interop/http-middleware (a PSR-15 precursor). This means the following changes were made throughout Expressive: The process() method of all middleware now type hint the second argument against the PSR-15 RequestHandlerInterface , instead of the previous DelegateInterface . The process() method of all middleware now have a return type hint of \\Psr\\Http\\Message\\ResponseInterface . All \"delegators\" have become request handlers: these now implement the PSR-15 interface RequestHandlerInterface instead of the former DelegateInterface . The process() method of handlers (formerly delegators) have been renamed to handle() and given a return type hint of \\Psr\\Http\\Message\\ResponseInterface . This change also affects all middleware you, as an application developer, have written, and your middleware will need to be update. We provide a tool for this via zend-expressive-tooling. Make sure that package is up-to-date (a version 1 release should be installed), and run the following: $ ./vendor/bin/expressive migrate:interop-middleware This tool will locate any http-interop middleware and update it to PSR-15 middleware. New dependencies Expressive adds the following packages as dependencies: psr/http-server-middleware provides the PSR-15 interfaces, and replaces the previous dependency on http-interop/http-middleware. zendframework/zend-expressive-router ; previously, we depended on this package indirectly; now it is a direct requirement. zendframework/zend-expressive-tooling ; this was suggested previously, but is now required as a development dependency. zendframework/zend-httphandlerrunner ; this is now used for the purposes of marshaling the server request, dispatching the application, and emitting the response. The functionality is generalized enough to warrant a separate package. New features The following classes were added in version 3: Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator is a delegator factory capable of piping and routing middleware from configuration. See the recipe on autowiring routes and pipeline middleware for more information. Zend\\Expressive\\Container\\ApplicationPipelineFactory will produce an empty MiddlewarePipe for use with Zend\\Expressive\\Application . Zend\\Expressive\\Container\\EmitterFactory will produce a Zend\\HttpHandlerRunner\\Emitter\\EmitterStack instance for use with the RequestHandlerRunner instance composed by the Application . See the chapter on emitters for more details. Zend\\Expressive\\Container\\MiddlewareContainerFactory will produce a MiddlewareContainer composing the application container instance. Zend\\Expressive\\Container\\MiddlewareFactoryFactory will produce a MiddlewareFactory composing a MiddlewareContainer instance. Zend\\Expressive\\Container\\RequestHandlerRunnerFactory will produce a Zend\\HttpHandlerRunner\\RequestHandlerRunner instance for use with the Application instance. See the zend-httphandlerrunner documentation for more details on this collaborator. Zend\\Expressive\\Container\\ServerRequestErrorResponseGeneratorFactory will produce a Zend\\Expressive\\Response\\ServerRequestErrorResponseGenerator instance for use with the RequestHandlerRunner . Zend\\Expressive\\Container\\ServerRequestFactoryFactory will produce a PHP callable capable of generating a PSR-7 ServerRequestInterface instance for use with the RequestHandlerRunner . Zend\\Expressive\\MiddlewareContainer decorates a PSR-11 container, and ensures that the values pulled are PSR-15 MiddlewareInterface instances. If the container returns a PSR-15 RequestHandlerInterface , it decorates it via Zend\\Stratigility\\Middleware\\RequestHandlerMiddleware . All other types result in an exception being thrown. Zend\\Expressive\\MiddlewareFactory allows creation of MiddlewareInterface instances from a variety of argument types, and is used by Application to allow piping and routing to middleware services, arrays of services, and more. It composes a MiddlewareContainer internally. Zend\\Expressive\\Response\\ServerRequestErrorResponseGenerator can act as a response generator for the RequestHandlerRunner when its composed server request factory raises an exception. Signature and behavior changes The following signature changes were made that could affect class extensions and/or consumers. Application Zend\\Expressive\\Application was refactored dramatically for version 3. If you were instantiating it directly previously, the constructor arguments are now, in order: Zend\\Expressive\\MiddlewareFactory Zend\\Stratigility\\MiddlewarePipeInterface Zend\\Expressive\\Router\\RouteCollector Zend\\HttpHandlerRunner\\RequestHandlerRunner Zend\\Expressive\\Application::__construct(...) Application no longer supports piping or routing to double-pass middleware. If you continue to need double-pass middleware (e.g., defined by a third-party library), use Zend\\Stratigility\\doublePassMiddleware() to decorate it prior to piping or routing to it: use Zend\\Diactoros\\Response; use function Zend\\Stratigility\\doublePassMiddleware; $app->pipe(doublePassMiddleware($someDoublePassMiddleware, new Response())); $app->get('/foo', doublePassMiddleware($someDoublePassMiddleware, new Response())); Additionally, the following methods were removed : pipeRoutingMiddleware() : use pipe(\\Zend\\Expressive\\Router\\Middleware\\RouteMiddleware::class) instead. pipeDispatchMiddleware() : use pipe(\\Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware::class) instead. getContainer() getDefaultDelegate() : ensure you pipe middleware or a request handler capable of returning a response at the innermost layer; Zend\\Expressive\\Handler\\NotFoundHandler can be used for this. getEmitter() : use the Zend\\HttpHandlerRunner\\Emitter\\EmitterInterface service from the container. injectPipelineFromConfig() : use the new ApplicationConfigInjectionDelegator and/or the static method of the same name it defines. injectRoutesFromConfig() : use the new ApplicationConfigInjectionDelegator and/or the static method of the same name it defines. ApplicationFactory Zend\\Expressive\\Container\\ApplicationFactory no longer looks at the zend-expressive.programmatic_pipeline flag, nor does it inject pipeline middleware and/or routed middleware from configuration any longer. If you want to use configuration-driven pipelines and/or middleware, you may register the new class Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator as a delegator factory on the Zend\\Expressive\\Application service. NotFoundHandlerFactory Zend\\Expressive\\Container\\NotFoundHandlerFactory now returns an instance of Zend\\Expressive\\Handler\\NotFoundHandler , instead of Zend\\Expressive\\Middleware\\NotFoundHandler (which has been removed). LazyLoadingMiddleware Zend\\Expressive\\Middleware\\LazyLoadingMiddleware now composes a Zend\\Expressive\\MiddlewareContainer instance instead of a more general PSR-11 container; this is to ensure that the value returned is a PSR-15 MiddlewareInterface instance. Removed classes and traits Zend\\Expressive\\AppFactory was removed. If you were using it previously, either use Zend\\Expressive\\Application directly, or a Zend\\Stratigility\\MiddlewarePipe instance. Zend\\Expressive\\ApplicationConfigInjectionTrait ; the functionality of this trait was replaced by the Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator . Zend\\Expressive\\Delegate\\NotFoundDelegate ; use Zend\\Expressive\\Handler\\NotFoundHandler instead. Its factory, Zend\\Expressive\\Container\\NotFoundDelegateFactory , was also removed. Zend\\Expressive\\Emitter\\EmitterStack ; use Zend\\HttpHandlerRunner\\Emitter\\EmitterStack instead. Zend\\Expressive\\IsCallableInteropMiddlewareTrait ; there is no functional equivalent, nor a need for this functionality as of version 3. Zend\\Expressive\\MarshalMiddlewareTrait ; the functionality of this trait was replaced by a combination of Zend\\Expressive\\MiddlewareContainer and Zend\\Expressive\\MiddlewareFactory . Zend\\Expressive\\Middleware\\DispatchMiddleware ; use Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware instead. Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware ; use Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware instead. Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware ; use Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware instead. Zend\\Expressive\\Middleware\\NotFoundHandler ; use Zend\\Expressive\\Handler\\NotFoundHandler instead. Zend\\Expressive\\Middleware\\RouteMiddleware ; use Zend\\Expressive\\Router\\Middleware\\RouteMiddleware instead. Upgrading We provide a package you can add to your existing v2 application in order to upgrade it to version 3. Before installing and running the migration tooling, make sure you have checked in your latest changes (assuming you are using version control), or have a backup of your existing code. Install the migration tooling using the following command: $ composer require --dev zendframework/zend-expressive-migration Once installed, run the following command to migrate your application: $ ./vendor/bin/expressive-migration migrate This package does the following: Uninstalls all current dependencies (by removing the vendor/ directory). Updates existing dependency constraints for known Expressive packages to their latest stable versions. (See the tools README for details on what versions of which packages the tool uses.) Adds development dependencies on zendframework/zend-component-installer and zendframework/zend-expressive-tooling. Updates the config/pipeline.php file to: add strict type declarations. modify it to return a callable, per the v3 skeleton. update the middleware pipeline as follows: pipeRoutingMiddleware() becomes a pipe() operation referencing the zend-expressive-router RouteMiddleware . pipeDispatchMiddleware() becomes a pipe() operation referencing the zend-expressive-router DispatchMiddleware . update references to ImplicitHeadMiddleware to reference the version in zend-expressive-router. update references to ImplicitOptionsMiddleware to reference the version in zend-expressive-router. update references to Zend\\Expressive\\Middleware\\NotFoundHandler to reference Zend\\Expressive\\Handler\\NotFoundHandler . add a pipe() entry for the zend-expressive-router MethodNotAllowedMiddleware . Updates the config/routes.php file to: add strict type declarations. modify it to return a callable, per the v3 skeleton. Replaces the public/index.php file with the latest version from the skeleton. Updates config/container.php when Pimple or Aura.Di are in use: For Pimple: The package xtreamwayz/pimple-container-interop is replaced with zendframework/zend-pimple-config . The Pimple variant of container.php from the v3 skeleton is used. For Aura.Di The package aura/di is replaced with zendframework/zend-auradi-config . The Aura.Di variant of container.php from the v3 skeleton is used. Executes ./vendor/bin/expressive migrate:interop-middleware . Executes ./vendor/bin/expressive migrate:middleware-to-request-handler . Runs ./vendor/bin/phpcbf if it is installed. These steps should take care of most migration tasks. It does not update unit tests. These cannot be automatically updated, due to the amount of variance in testing strategies. When done, use a diffing tool to compare and verify all changes. Please be aware that the tool is not designed for edge cases; there may be things it does not do or cannot catch within your code. When unsure, refer to the other sections in this document to determine what else you may need to change.","title":"Migration"},{"location":"v3/reference/migration/#migration-to-expressive-30","text":"Expressive 3.0 should not result in many upgrade problems for users. However, starting in this version, we offer a few changes affecting the following that you should be aware of, and potentially update your application to adopt: PHP 7.1 support PSR-15 support New dependencies New features Signature and behavior changes Removed classes and traits Upgrading from v2","title":"Migration to Expressive 3.0"},{"location":"v3/reference/migration/#php-71-support","text":"Starting in Expressive 3.0 we support only PHP 7.1+.","title":"PHP 7.1 support"},{"location":"v3/reference/migration/#psr-15-support","text":"All middleware and delegators now implement interfaces from PSR-15 instead of http-interop/http-middleware (a PSR-15 precursor). This means the following changes were made throughout Expressive: The process() method of all middleware now type hint the second argument against the PSR-15 RequestHandlerInterface , instead of the previous DelegateInterface . The process() method of all middleware now have a return type hint of \\Psr\\Http\\Message\\ResponseInterface . All \"delegators\" have become request handlers: these now implement the PSR-15 interface RequestHandlerInterface instead of the former DelegateInterface . The process() method of handlers (formerly delegators) have been renamed to handle() and given a return type hint of \\Psr\\Http\\Message\\ResponseInterface . This change also affects all middleware you, as an application developer, have written, and your middleware will need to be update. We provide a tool for this via zend-expressive-tooling. Make sure that package is up-to-date (a version 1 release should be installed), and run the following: $ ./vendor/bin/expressive migrate:interop-middleware This tool will locate any http-interop middleware and update it to PSR-15 middleware.","title":"PSR-15 Support"},{"location":"v3/reference/migration/#new-dependencies","text":"Expressive adds the following packages as dependencies: psr/http-server-middleware provides the PSR-15 interfaces, and replaces the previous dependency on http-interop/http-middleware. zendframework/zend-expressive-router ; previously, we depended on this package indirectly; now it is a direct requirement. zendframework/zend-expressive-tooling ; this was suggested previously, but is now required as a development dependency. zendframework/zend-httphandlerrunner ; this is now used for the purposes of marshaling the server request, dispatching the application, and emitting the response. The functionality is generalized enough to warrant a separate package.","title":"New dependencies"},{"location":"v3/reference/migration/#new-features","text":"The following classes were added in version 3: Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator is a delegator factory capable of piping and routing middleware from configuration. See the recipe on autowiring routes and pipeline middleware for more information. Zend\\Expressive\\Container\\ApplicationPipelineFactory will produce an empty MiddlewarePipe for use with Zend\\Expressive\\Application . Zend\\Expressive\\Container\\EmitterFactory will produce a Zend\\HttpHandlerRunner\\Emitter\\EmitterStack instance for use with the RequestHandlerRunner instance composed by the Application . See the chapter on emitters for more details. Zend\\Expressive\\Container\\MiddlewareContainerFactory will produce a MiddlewareContainer composing the application container instance. Zend\\Expressive\\Container\\MiddlewareFactoryFactory will produce a MiddlewareFactory composing a MiddlewareContainer instance. Zend\\Expressive\\Container\\RequestHandlerRunnerFactory will produce a Zend\\HttpHandlerRunner\\RequestHandlerRunner instance for use with the Application instance. See the zend-httphandlerrunner documentation for more details on this collaborator. Zend\\Expressive\\Container\\ServerRequestErrorResponseGeneratorFactory will produce a Zend\\Expressive\\Response\\ServerRequestErrorResponseGenerator instance for use with the RequestHandlerRunner . Zend\\Expressive\\Container\\ServerRequestFactoryFactory will produce a PHP callable capable of generating a PSR-7 ServerRequestInterface instance for use with the RequestHandlerRunner . Zend\\Expressive\\MiddlewareContainer decorates a PSR-11 container, and ensures that the values pulled are PSR-15 MiddlewareInterface instances. If the container returns a PSR-15 RequestHandlerInterface , it decorates it via Zend\\Stratigility\\Middleware\\RequestHandlerMiddleware . All other types result in an exception being thrown. Zend\\Expressive\\MiddlewareFactory allows creation of MiddlewareInterface instances from a variety of argument types, and is used by Application to allow piping and routing to middleware services, arrays of services, and more. It composes a MiddlewareContainer internally. Zend\\Expressive\\Response\\ServerRequestErrorResponseGenerator can act as a response generator for the RequestHandlerRunner when its composed server request factory raises an exception.","title":"New features"},{"location":"v3/reference/migration/#signature-and-behavior-changes","text":"The following signature changes were made that could affect class extensions and/or consumers.","title":"Signature and behavior changes"},{"location":"v3/reference/migration/#removed-classes-and-traits","text":"Zend\\Expressive\\AppFactory was removed. If you were using it previously, either use Zend\\Expressive\\Application directly, or a Zend\\Stratigility\\MiddlewarePipe instance. Zend\\Expressive\\ApplicationConfigInjectionTrait ; the functionality of this trait was replaced by the Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator . Zend\\Expressive\\Delegate\\NotFoundDelegate ; use Zend\\Expressive\\Handler\\NotFoundHandler instead. Its factory, Zend\\Expressive\\Container\\NotFoundDelegateFactory , was also removed. Zend\\Expressive\\Emitter\\EmitterStack ; use Zend\\HttpHandlerRunner\\Emitter\\EmitterStack instead. Zend\\Expressive\\IsCallableInteropMiddlewareTrait ; there is no functional equivalent, nor a need for this functionality as of version 3. Zend\\Expressive\\MarshalMiddlewareTrait ; the functionality of this trait was replaced by a combination of Zend\\Expressive\\MiddlewareContainer and Zend\\Expressive\\MiddlewareFactory . Zend\\Expressive\\Middleware\\DispatchMiddleware ; use Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware instead. Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware ; use Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware instead. Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware ; use Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware instead. Zend\\Expressive\\Middleware\\NotFoundHandler ; use Zend\\Expressive\\Handler\\NotFoundHandler instead. Zend\\Expressive\\Middleware\\RouteMiddleware ; use Zend\\Expressive\\Router\\Middleware\\RouteMiddleware instead.","title":"Removed classes and traits"},{"location":"v3/reference/migration/#upgrading","text":"We provide a package you can add to your existing v2 application in order to upgrade it to version 3. Before installing and running the migration tooling, make sure you have checked in your latest changes (assuming you are using version control), or have a backup of your existing code. Install the migration tooling using the following command: $ composer require --dev zendframework/zend-expressive-migration Once installed, run the following command to migrate your application: $ ./vendor/bin/expressive-migration migrate This package does the following: Uninstalls all current dependencies (by removing the vendor/ directory). Updates existing dependency constraints for known Expressive packages to their latest stable versions. (See the tools README for details on what versions of which packages the tool uses.) Adds development dependencies on zendframework/zend-component-installer and zendframework/zend-expressive-tooling. Updates the config/pipeline.php file to: add strict type declarations. modify it to return a callable, per the v3 skeleton. update the middleware pipeline as follows: pipeRoutingMiddleware() becomes a pipe() operation referencing the zend-expressive-router RouteMiddleware . pipeDispatchMiddleware() becomes a pipe() operation referencing the zend-expressive-router DispatchMiddleware . update references to ImplicitHeadMiddleware to reference the version in zend-expressive-router. update references to ImplicitOptionsMiddleware to reference the version in zend-expressive-router. update references to Zend\\Expressive\\Middleware\\NotFoundHandler to reference Zend\\Expressive\\Handler\\NotFoundHandler . add a pipe() entry for the zend-expressive-router MethodNotAllowedMiddleware . Updates the config/routes.php file to: add strict type declarations. modify it to return a callable, per the v3 skeleton. Replaces the public/index.php file with the latest version from the skeleton. Updates config/container.php when Pimple or Aura.Di are in use: For Pimple: The package xtreamwayz/pimple-container-interop is replaced with zendframework/zend-pimple-config . The Pimple variant of container.php from the v3 skeleton is used. For Aura.Di The package aura/di is replaced with zendframework/zend-auradi-config . The Aura.Di variant of container.php from the v3 skeleton is used. Executes ./vendor/bin/expressive migrate:interop-middleware . Executes ./vendor/bin/expressive migrate:middleware-to-request-handler . Runs ./vendor/bin/phpcbf if it is installed. These steps should take care of most migration tasks. It does not update unit tests. These cannot be automatically updated, due to the amount of variance in testing strategies. When done, use a diffing tool to compare and verify all changes. Please be aware that the tool is not designed for edge cases; there may be things it does not do or cannot catch within your code. When unsure, refer to the other sections in this document to determine what else you may need to change.","title":"Upgrading"}]}